diff --git a/base/BUILD.gn b/base/BUILD.gn
index b940c4bca3d82..aa3d3eb7eeee0 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -3386,6 +3386,7 @@ test("base_unittests") {
     "profiler/stack_sampling_profiler_unittest.cc",
     "profiler/thread_group_profiler_unittest.cc",
     "rand_util_unittest.cc",
+    "ranges/algorithm_unittest.cc",
     "ranges/functional_unittest.cc",
     "run_loop_unittest.cc",
     "safe_numerics_unittest.cc",
diff --git a/base/ranges/algorithm.h b/base/ranges/algorithm.h
index 86d2ab45a0bdd..9c97d483a6a35 100644
--- a/base/ranges/algorithm.h
+++ b/base/ranges/algorithm.h
@@ -2,100 +2,5115 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/40284755): Remove this and spanify to fix the errors.
+#pragma allow_unsafe_buffers
+#endif
+
 #ifndef BASE_RANGES_ALGORITHM_H_
 #define BASE_RANGES_ALGORITHM_H_
 
 #include <algorithm>
+#include <functional>
+#include <initializer_list>
+#include <iterator>
+#include <ranges>
+#include <type_traits>
+#include <utility>
+
+#include "base/check.h"
+#include "base/compiler_specific.h"
+#include "base/memory/raw_ptr_exclusion.h"
+#include "base/ranges/functional.h"
+#include "base/ranges/ranges.h"
+
+namespace base {
+
+namespace internal {
+
+// Returns a transformed version of the unary predicate `pred` applying `proj`
+// to its argument before invoking `pred` on it.
+// Ensures that the return type of `invoke(pred, ...)` is convertible to bool.
+template <typename Pred, typename Proj>
+constexpr auto ProjectedUnaryPredicate(Pred& pred, Proj& proj) noexcept {
+  return [&pred, &proj](auto&& arg) -> bool {
+    return std::invoke(pred,
+                       std::invoke(proj, std::forward<decltype(arg)>(arg)));
+  };
+}
+
+// Helper concept that is true if the binary predicate can be invoked on the
+// result of projecting T and projecting U. See `BinaryPredicateProjector` for
+// additional background.
+template <typename BinaryPred,
+          typename ProjT,
+          typename ProjU,
+          typename T,
+          typename U>
+concept BinaryPredicateProjectorIsInvokable = requires(BinaryPred& predicate,
+                                                       ProjT& project_t,
+                                                       ProjU& project_u,
+                                                       T&& t,
+                                                       U&& u) {
+  {
+    std::invoke(predicate, std::invoke(project_t, std::forward<T>(t)),
+                std::invoke(project_u, std::forward<U>(u)))
+  } -> std::same_as<bool>;
+};
+
+// Returns a transformed version of the binary predicate `pred` applying `proj1`
+// and `proj2` to its arguments before invoking `pred` on them.
+//
+// Provides an opt-in to considers all four permutations of projections and
+// argument types. This is sometimes necessary to allow usage with legacy
+// non-ranges std:: algorithms that don't support projections.
+//
+// These permutations are assigned different priorities to break ambiguities in
+// case several permutations are possible, e.g. when Proj1 and Proj2 are the
+// same type.
+//
+// Note that even when opting in to using all permutations of projections,
+// calling code should still ensure that the canonical mapping of {Proj1, Proj2}
+// to {LHS, RHS} compiles for all members of the range. This can be done by
+// adding the following constraint:
+//
+//   typename =
+//       std::indirect_result_t<Pred&,
+//                              std::projected<iterator_t<Range1>, Proj1>,
+//                              std::projected<iterator_t<Range2>, Proj2>>
+//
+// Ensures that the return type of `invoke(pred, ...)` is convertible to bool.
+template <typename Pred, typename Proj1, typename Proj2, bool kPermute = false>
+class BinaryPredicateProjector {
+ public:
+  constexpr BinaryPredicateProjector(Pred& pred, Proj1& proj1, Proj2& proj2)
+      : pred_(pred), proj1_(proj1), proj2_(proj2) {}
+
+ private:
+  template <typename T, typename U>
+  constexpr auto GetProjs() const {
+    if constexpr (BinaryPredicateProjectorIsInvokable<Pred, Proj1, Proj2, T,
+                                                      U>) {
+      return std::pair<Proj1&, Proj2&>(proj1_, proj2_);
+    } else if constexpr (kPermute &&
+                         BinaryPredicateProjectorIsInvokable<Pred, Proj2, Proj1,
+                                                             T, U>) {
+      return std::pair<Proj2&, Proj1&>(proj2_, proj1_);
+    } else if constexpr (kPermute &&
+                         BinaryPredicateProjectorIsInvokable<Pred, Proj1, Proj1,
+                                                             T, U>) {
+      return std::pair<Proj1&, Proj1&>(proj1_, proj1_);
+    } else if constexpr (kPermute &&
+                         BinaryPredicateProjectorIsInvokable<Pred, Proj2, Proj2,
+                                                             T, U>) {
+      return std::pair<Proj2&, Proj2&>(proj2_, proj2_);
+    }
+  }
+
+ public:
+  template <typename T, typename U>
+  constexpr bool operator()(T&& lhs, U&& rhs) const {
+    auto projs = GetProjs<T, U>();
+    return std::invoke(pred_, std::invoke(projs.first, std::forward<T>(lhs)),
+                       std::invoke(projs.second, std::forward<U>(rhs)));
+  }
+
+ private:
+  // RAW_PTR_EXCLUSION: Binary size increase (~120K on Android).
+  RAW_PTR_EXCLUSION Pred& pred_;
+  RAW_PTR_EXCLUSION Proj1& proj1_;
+  RAW_PTR_EXCLUSION Proj2& proj2_;
+};
+
+// Small wrappers around BinaryPredicateProjector to make the calling side more
+// readable.
+template <typename Pred, typename Proj1, typename Proj2>
+constexpr auto ProjectedBinaryPredicate(Pred& pred,
+                                        Proj1& proj1,
+                                        Proj2& proj2) noexcept {
+  return BinaryPredicateProjector<Pred, Proj1, Proj2>(pred, proj1, proj2);
+}
+
+template <typename Pred, typename Proj1, typename Proj2>
+constexpr auto PermutedProjectedBinaryPredicate(Pred& pred,
+                                                Proj1& proj1,
+                                                Proj2& proj2) noexcept {
+  return BinaryPredicateProjector<Pred, Proj1, Proj2, true>(pred, proj1, proj2);
+}
+
+// This alias is used below to restrict iterator based APIs to types for which
+// `iterator_category` and the pre-increment and post-increment operators are
+// defined. This is required in situations where otherwise an undesired overload
+// would be chosen, e.g. copy_if. In spirit this is similar to C++20's
+// std::input_or_output_iterator, a concept that each iterator should satisfy.
+template <typename Iter,
+          typename = decltype(++std::declval<Iter&>()),
+          typename = decltype(std::declval<Iter&>()++)>
+using iterator_category_t =
+    typename std::iterator_traits<Iter>::iterator_category;
+
+// This alias is used below to restrict range based APIs to types for which
+// `iterator_category_t` is defined for the underlying iterator. This is
+// required in situations where otherwise an undesired overload would be chosen,
+// e.g. transform. In spirit this is similar to C++20's std::ranges::range, a
+// concept that each range should satisfy.
+template <typename Range>
+using range_category_t = iterator_category_t<ranges::iterator_t<Range>>;
+
+}  // namespace internal
+
+namespace ranges {
+
+// [alg.nonmodifying] Non-modifying sequence operations
+// Reference: https://wg21.link/alg.nonmodifying
+
+// [alg.all.of] All of
+// Reference: https://wg21.link/alg.all.of
+
+// Let `E(i)` be `invoke(pred, invoke(proj, *i))`.
+//
+// Returns: `false` if `E(i)` is `false` for some iterator `i` in the range
+// `[first, last)`, and `true` otherwise.
+//
+// Complexity: At most `last - first` applications of the predicate and any
+// projection.
+//
+// Reference: https://wg21.link/alg.all.of#:~:text=ranges::all_of(I
+template <typename InputIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>>
+constexpr bool all_of(InputIterator first,
+                      InputIterator last,
+                      Pred pred,
+                      Proj proj = {}) {
+  for (; first != last; ++first) {
+    if (!std::invoke(pred, std::invoke(proj, *first))) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+// Let `E(i)` be `invoke(pred, invoke(proj, *i))`.
+//
+// Returns: `false` if `E(i)` is `false` for some iterator `i` in `range`, and
+// `true` otherwise.
+//
+// Complexity: At most `size(range)` applications of the predicate and any
+// projection.
+//
+// Reference: https://wg21.link/alg.all.of#:~:text=ranges::all_of(R
+template <typename Range,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr bool all_of(Range&& range, Pred pred, Proj proj = {}) {
+  return ranges::all_of(std::ranges::begin(range), std::ranges::end(range),
+                        std::move(pred), std::move(proj));
+}
+
+// [alg.any.of] Any of
+// Reference: https://wg21.link/alg.any.of
+
+// Let `E(i)` be `invoke(pred, invoke(proj, *i))`.
+//
+// Returns: `true` if `E(i)` is `true` for some iterator `i` in the range
+// `[first, last)`, and `false` otherwise.
+//
+// Complexity: At most `last - first` applications of the predicate and any
+// projection.
+//
+// Reference: https://wg21.link/alg.any.of#:~:text=ranges::any_of(I
+template <typename InputIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>>
+constexpr bool any_of(InputIterator first,
+                      InputIterator last,
+                      Pred pred,
+                      Proj proj = {}) {
+  for (; first != last; ++first) {
+    if (std::invoke(pred, std::invoke(proj, *first))) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+// Let `E(i)` be `invoke(pred, invoke(proj, *i))`.
+//
+// Returns: `true` if `E(i)` is `true` for some iterator `i` in `range`, and
+// `false` otherwise.
+//
+// Complexity: At most `size(range)` applications of the predicate and any
+// projection.
+//
+// Reference: https://wg21.link/alg.any.of#:~:text=ranges::any_of(R
+template <typename Range,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr bool any_of(Range&& range, Pred pred, Proj proj = {}) {
+  return ranges::any_of(std::ranges::begin(range), std::ranges::end(range),
+                        std::move(pred), std::move(proj));
+}
+
+// [alg.none.of] None of
+// Reference: https://wg21.link/alg.none.of
+
+// Let `E(i)` be `invoke(pred, invoke(proj, *i))`.
+//
+// Returns: `false` if `E(i)` is `true` for some iterator `i` in the range
+// `[first, last)`, and `true` otherwise.
+//
+// Complexity: At most `last - first` applications of the predicate and any
+// projection.
+//
+// Reference: https://wg21.link/alg.none.of#:~:text=ranges::none_of(I
+template <typename InputIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>>
+constexpr bool none_of(InputIterator first,
+                       InputIterator last,
+                       Pred pred,
+                       Proj proj = {}) {
+  for (; first != last; ++first) {
+    if (std::invoke(pred, std::invoke(proj, *first))) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+// Let `E(i)` be `invoke(pred, invoke(proj, *i))`.
+//
+// Returns: `false` if `E(i)` is `true` for some iterator `i` in `range`, and
+// `true` otherwise.
+//
+// Complexity: At most `size(range)` applications of the predicate and any
+// projection.
+//
+// Reference: https://wg21.link/alg.none.of#:~:text=ranges::none_of(R
+template <typename Range,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr bool none_of(Range&& range, Pred pred, Proj proj = {}) {
+  return ranges::none_of(std::ranges::begin(range), std::ranges::end(range),
+                         std::move(pred), std::move(proj));
+}
+
+// [alg.foreach] For each
+// Reference: https://wg21.link/alg.foreach
+
+// Reference: https://wg21.link/algorithm.syn#:~:text=for_each_result
+template <typename I, typename F>
+using for_each_result = std::ranges::in_fun_result<I, F>;
+
+// Effects: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the
+// range `[first, last)`, starting from `first` and proceeding to `last - 1`.
+//
+// Returns: `{last, std::move(f)}`.
+//
+// Complexity: Applies `f` and `proj` exactly `last - first` times.
+//
+// Remarks: If `f` returns a result, the result is ignored.
+//
+// Reference: https://wg21.link/alg.foreach#:~:text=ranges::for_each(I
+template <typename InputIterator,
+          typename Fun,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>>
+constexpr auto for_each(InputIterator first,
+                        InputIterator last,
+                        Fun f,
+                        Proj proj = {}) {
+  for (; first != last; ++first) {
+    std::invoke(f, std::invoke(proj, *first));
+  }
+  return for_each_result<InputIterator, Fun>{first, std::move(f)};
+}
+
+// Effects: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the
+// range `range`, starting from `begin(range)` and proceeding to `end(range) -
+// 1`.
+//
+// Returns: `{last, std::move(f)}`.
+//
+// Complexity: Applies `f` and `proj` exactly `size(range)` times.
+//
+// Remarks: If `f` returns a result, the result is ignored.
+//
+// Reference: https://wg21.link/alg.foreach#:~:text=ranges::for_each(R
+template <typename Range,
+          typename Fun,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto for_each(Range&& range, Fun f, Proj proj = {}) {
+  return ranges::for_each(std::ranges::begin(range), std::ranges::end(range),
+                          std::move(f), std::move(proj));
+}
+
+// Reference: https://wg21.link/algorithm.syn#:~:text=for_each_n_result
+template <typename I, typename F>
+using for_each_n_result = std::ranges::in_fun_result<I, F>;
+
+// Preconditions: `n >= 0` is `true`.
+//
+// Effects: Calls `invoke(f, invoke(proj, *i))` for every iterator `i` in the
+// range `[first, first + n)` in order.
+//
+// Returns: `{first + n, std::move(f)}`.
+//
+// Remarks: If `f` returns a result, the result is ignored.
+//
+// Reference: https://wg21.link/alg.foreach#:~:text=ranges::for_each_n
+template <typename InputIterator,
+          typename Size,
+          typename Fun,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>>
+constexpr auto for_each_n(InputIterator first, Size n, Fun f, Proj proj = {}) {
+  while (n > 0) {
+    std::invoke(f, std::invoke(proj, *first));
+    ++first;
+    --n;
+  }
+
+  return for_each_n_result<InputIterator, Fun>{first, std::move(f)};
+}
+
+// [alg.find] Find
+// Reference: https://wg21.link/alg.find
+
+// Let `E(i)` be `bool(invoke(proj, *i) == value)`.
+//
+// Returns: The first iterator `i` in the range `[first, last)` for which `E(i)`
+// is `true`. Returns `last` if no such iterator is found.
+//
+// Complexity: At most `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.find#:~:text=ranges::find(I
+template <typename InputIterator,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>>
+constexpr auto find(InputIterator first,
+                    InputIterator last,
+                    const T& value,
+                    Proj proj = {}) {
+  for (; first != last; ++first) {
+    if (std::invoke(proj, *first) == value) {
+      break;
+    }
+  }
+
+  return first;
+}
+
+// Let `E(i)` be `bool(invoke(proj, *i) == value)`.
+//
+// Returns: The first iterator `i` in `range` for which `E(i)` is `true`.
+// Returns `end(range)` if no such iterator is found.
+//
+// Complexity: At most `size(range)` applications of the corresponding predicate
+// and any projection.
+//
+// Reference: https://wg21.link/alg.find#:~:text=ranges::find(R
+template <typename Range,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto find(Range&& range, const T& value, Proj proj = {}) {
+  return ranges::find(std::ranges::begin(range), std::ranges::end(range), value,
+                      std::move(proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`.
+//
+// Returns: The first iterator `i` in the range `[first, last)` for which `E(i)`
+// is `true`. Returns `last` if no such iterator is found.
+//
+// Complexity: At most `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.find#:~:text=ranges::find_if(I
+template <typename InputIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>>
+constexpr auto find_if(InputIterator first,
+                       InputIterator last,
+                       Pred pred,
+                       Proj proj = {}) {
+  return std::find_if(first, last,
+                      internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`.
+//
+// Returns: The first iterator `i` in `range` for which `E(i)` is `true`.
+// Returns `end(range)` if no such iterator is found.
+//
+// Complexity: At most `size(range)` applications of the corresponding predicate
+// and any projection.
+//
+// Reference: https://wg21.link/alg.find#:~:text=ranges::find_if(R
+template <typename Range,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto find_if(Range&& range, Pred pred, Proj proj = {}) {
+  return ranges::find_if(std::ranges::begin(range), std::ranges::end(range),
+                         std::move(pred), std::move(proj));
+}
+
+// Let `E(i)` be `bool(!invoke(pred, invoke(proj, *i)))`.
+//
+// Returns: The first iterator `i` in the range `[first, last)` for which `E(i)`
+// is `true`. Returns `last` if no such iterator is found.
+//
+// Complexity: At most `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.find#:~:text=ranges::find_if_not(I
+template <typename InputIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>>
+constexpr auto find_if_not(InputIterator first,
+                           InputIterator last,
+                           Pred pred,
+                           Proj proj = {}) {
+  return std::find_if_not(first, last,
+                          internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// Let `E(i)` be `bool(!invoke(pred, invoke(proj, *i)))`.
+//
+// Returns: The first iterator `i` in `range` for which `E(i)` is `true`.
+// Returns `end(range)` if no such iterator is found.
+//
+// Complexity: At most `size(range)` applications of the corresponding predicate
+// and any projection.
+//
+// Reference: https://wg21.link/alg.find#:~:text=ranges::find_if_not(R
+template <typename Range,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto find_if_not(Range&& range, Pred pred, Proj proj = {}) {
+  return ranges::find_if_not(std::ranges::begin(range), std::ranges::end(range),
+                             std::move(pred), std::move(proj));
+}
+
+// [alg.find.end] Find end
+// Reference: https://wg21.link/alg.find.end
+
+// Let:
+// - `E(i,n)` be `invoke(pred, invoke(proj1, *(i + n)),
+//                             invoke(proj2, *(first2 + n)))`
+//
+// - `i` be `last1` if `[first2, last2)` is empty, or if
+//   `(last2 - first2) > (last1 - first1)` is `true`, or if there is no iterator
+//   in the range `[first1, last1 - (last2 - first2))` such that for every
+//   non-negative integer `n < (last2 - first2)`, `E(i,n)` is `true`. Otherwise
+//   `i` is the last such iterator in `[first1, last1 - (last2 - first2))`.
+//
+// Returns: `i`
+// Note: std::ranges::find_end(I1 first1,...) returns a range, rather than an
+// iterator. For simplicitly we match std::find_end's return type instead.
+//
+// Complexity:
+// At most `(last2 - first2) * (last1 - first1 - (last2 - first2) + 1)`
+// applications of the corresponding predicate and any projections.
+//
+// Reference: https://wg21.link/alg.find.end#:~:text=ranges::find_end(I1
+template <
+    typename ForwardIterator1,
+    typename ForwardIterator2,
+    typename Pred = ranges::equal_to,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator1>,
+    typename = internal::iterator_category_t<ForwardIterator2>,
+    typename = std::indirect_result_t<Pred&,
+                                      std::projected<ForwardIterator1, Proj1>,
+                                      std::projected<ForwardIterator2, Proj2>>>
+constexpr auto find_end(ForwardIterator1 first1,
+                        ForwardIterator1 last1,
+                        ForwardIterator2 first2,
+                        ForwardIterator2 last2,
+                        Pred pred = {},
+                        Proj1 proj1 = {},
+                        Proj2 proj2 = {}) {
+  return std::find_end(first1, last1, first2, last2,
+                       internal::ProjectedBinaryPredicate(pred, proj1, proj2));
+}
+
+// Let:
+// - `E(i,n)` be `invoke(pred, invoke(proj1, *(i + n)),
+//                             invoke(proj2, *(first2 + n)))`
+//
+// - `i` be `end(range1)` if `range2` is empty, or if
+//   `size(range2) > size(range1)` is `true`, or if there is no iterator in the
+//   range `[begin(range1), end(range1) - size(range2))` such that for every
+//   non-negative integer `n < size(range2)`, `E(i,n)` is `true`. Otherwise `i`
+//   is the last such iterator in `[begin(range1), end(range1) - size(range2))`.
+//
+// Returns: `i`
+// Note: std::ranges::find_end(R1&& r1,...) returns a range, rather than an
+// iterator. For simplicitly we match std::find_end's return type instead.
+//
+// Complexity: At most `size(range2) * (size(range1) - size(range2) + 1)`
+// applications of the corresponding predicate and any projections.
+//
+// Reference: https://wg21.link/alg.find.end#:~:text=ranges::find_end(R1
+template <typename Range1,
+          typename Range2,
+          typename Pred = ranges::equal_to,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename =
+              std::indirect_result_t<Pred&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>>
+constexpr auto find_end(Range1&& range1,
+                        Range2&& range2,
+                        Pred pred = {},
+                        Proj1 proj1 = {},
+                        Proj2 proj2 = {}) {
+  return ranges::find_end(std::ranges::begin(range1), std::ranges::end(range1),
+                          std::ranges::begin(range2), std::ranges::end(range2),
+                          std::move(pred), std::move(proj1), std::move(proj2));
+}
+
+// [alg.find.first.of] Find first
+// Reference: https://wg21.link/alg.find.first.of
+
+// Let `E(i,j)` be `bool(invoke(pred, invoke(proj1, *i), invoke(proj2, *j)))`.
+//
+// Effects: Finds an element that matches one of a set of values.
+//
+// Returns: The first iterator `i` in the range `[first1, last1)` such that for
+// some iterator `j` in the range `[first2, last2)` `E(i,j)` holds. Returns
+// `last1` if `[first2, last2)` is empty or if no such iterator is found.
+//
+// Complexity: At most `(last1 - first1) * (last2 - first2)` applications of the
+// corresponding predicate and any projections.
+//
+// Reference:
+// https://wg21.link/alg.find.first.of#:~:text=ranges::find_first_of(I1
+template <
+    typename ForwardIterator1,
+    typename ForwardIterator2,
+    typename Pred = ranges::equal_to,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator1>,
+    typename = internal::iterator_category_t<ForwardIterator2>,
+    typename = std::indirect_result_t<Pred&,
+                                      std::projected<ForwardIterator1, Proj1>,
+                                      std::projected<ForwardIterator2, Proj2>>>
+constexpr auto find_first_of(ForwardIterator1 first1,
+                             ForwardIterator1 last1,
+                             ForwardIterator2 first2,
+                             ForwardIterator2 last2,
+                             Pred pred = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}) {
+  return std::find_first_of(
+      first1, last1, first2, last2,
+      internal::ProjectedBinaryPredicate(pred, proj1, proj2));
+}
+
+// Let `E(i,j)` be `bool(invoke(pred, invoke(proj1, *i), invoke(proj2, *j)))`.
+//
+// Effects: Finds an element that matches one of a set of values.
+//
+// Returns: The first iterator `i` in `range1` such that for some iterator `j`
+// in `range2` `E(i,j)` holds. Returns `end(range1)` if `range2` is empty or if
+// no such iterator is found.
+//
+// Complexity: At most `size(range1) * size(range2)` applications of the
+// corresponding predicate and any projections.
+//
+// Reference:
+// https://wg21.link/alg.find.first.of#:~:text=ranges::find_first_of(R1
+template <typename Range1,
+          typename Range2,
+          typename Pred = ranges::equal_to,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename =
+              std::indirect_result_t<Pred&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>>
+constexpr auto find_first_of(Range1&& range1,
+                             Range2&& range2,
+                             Pred pred = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}) {
+  return ranges::find_first_of(
+      std::ranges::begin(range1), std::ranges::end(range1),
+      std::ranges::begin(range2), std::ranges::end(range2), std::move(pred),
+      std::move(proj1), std::move(proj2));
+}
+
+// [alg.adjacent.find] Adjacent find
+// Reference: https://wg21.link/alg.adjacent.find
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i), invoke(proj, *(i + 1))))`.
+//
+// Returns: The first iterator `i` such that both `i` and `i + 1` are in the
+// range `[first, last)` for which `E(i)` holds. Returns `last` if no such
+// iterator is found.
+//
+// Complexity: Exactly `min((i - first) + 1, (last - first) - 1)` applications
+// of the corresponding predicate, where `i` is `adjacent_find`'s return value.
+//
+// Reference:
+// https://wg21.link/alg.adjacent.find#:~:text=ranges::adjacent_find(I
+template <typename ForwardIterator,
+          typename Pred = ranges::equal_to,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto adjacent_find(ForwardIterator first,
+                             ForwardIterator last,
+                             Pred pred = {},
+                             Proj proj = {}) {
+  // Implementation inspired by cppreference.com:
+  // https://en.cppreference.com/w/cpp/algorithm/adjacent_find
+  //
+  // A reimplementation is required, because std::adjacent_find is not constexpr
+  // prior to C++20. Once we have C++20, we should switch to standard library
+  // implementation.
+  if (first == last) {
+    return last;
+  }
+
+  for (ForwardIterator next = first; ++next != last; ++first) {
+    if (std::invoke(pred, std::invoke(proj, *first),
+                    std::invoke(proj, *next))) {
+      return first;
+    }
+  }
+
+  return last;
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i), invoke(proj, *(i + 1))))`.
+//
+// Returns: The first iterator `i` such that both `i` and `i + 1` are in the
+// range `range` for which `E(i)` holds. Returns `end(range)` if no such
+// iterator is found.
+//
+// Complexity: Exactly `min((i - begin(range)) + 1, size(range) - 1)`
+// applications of the corresponding predicate, where `i` is `adjacent_find`'s
+// return value.
+//
+// Reference:
+// https://wg21.link/alg.adjacent.find#:~:text=ranges::adjacent_find(R
+template <typename Range,
+          typename Pred = ranges::equal_to,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto adjacent_find(Range&& range, Pred pred = {}, Proj proj = {}) {
+  return ranges::adjacent_find(std::ranges::begin(range),
+                               std::ranges::end(range), std::move(pred),
+                               std::move(proj));
+}
+
+// [alg.count] Count
+// Reference: https://wg21.link/alg.count
+
+// Let `E(i)` be `invoke(proj, *i) == value`.
+//
+// Effects: Returns the number of iterators `i` in the range `[first, last)` for
+// which `E(i)` holds.
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.count#:~:text=ranges::count(I
+template <typename InputIterator,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>>
+constexpr auto count(InputIterator first,
+                     InputIterator last,
+                     const T& value,
+                     Proj proj = {}) {
+  // Note: In order to be able to apply `proj` to each element in [first, last)
+  // we are dispatching to std::count_if instead of std::count.
+  return std::count_if(first, last, [&proj, &value](auto&& lhs) {
+    return std::invoke(proj, std::forward<decltype(lhs)>(lhs)) == value;
+  });
+}
+
+// Let `E(i)` be `invoke(proj, *i) == value`.
+//
+// Effects: Returns the number of iterators `i` in `range` for which `E(i)`
+// holds.
+//
+// Complexity: Exactly `size(range)` applications of the corresponding predicate
+// and any projection.
+//
+// Reference: https://wg21.link/alg.count#:~:text=ranges::count(R
+template <typename Range,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto count(Range&& range, const T& value, Proj proj = {}) {
+  return ranges::count(std::ranges::begin(range), std::ranges::end(range),
+                       value, std::move(proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`.
+//
+// Effects: Returns the number of iterators `i` in the range `[first, last)` for
+// which `E(i)` holds.
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.count#:~:text=ranges::count_if(I
+template <typename InputIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>>
+constexpr auto count_if(InputIterator first,
+                        InputIterator last,
+                        Pred pred,
+                        Proj proj = {}) {
+  return std::count_if(first, last,
+                       internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`.
+//
+// Effects: Returns the number of iterators `i` in `range` for which `E(i)`
+// holds.
+//
+// Complexity: Exactly `size(range)` applications of the corresponding predicate
+// and any projection.
+//
+// Reference: https://wg21.link/alg.count#:~:text=ranges::count_if(R
+template <typename Range,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto count_if(Range&& range, Pred pred, Proj proj = {}) {
+  return ranges::count_if(std::ranges::begin(range), std::ranges::end(range),
+                          std::move(pred), std::move(proj));
+}
+
+// [mismatch] Mismatch
+// Reference: https://wg21.link/mismatch
+
+// Let `E(n)` be `!invoke(pred, invoke(proj1, *(first1 + n)),
+//                              invoke(proj2, *(first2 + n)))`.
+//
+// Let `N` be `min(last1 - first1, last2 - first2)`.
+//
+// Returns: `{ first1 + n, first2 + n }`, where `n` is the smallest integer in
+// `[0, N)` such that `E(n)` holds, or `N` if no such integer exists.
+//
+// Complexity: At most `N` applications of the corresponding predicate and any
+// projections.
+//
+// Reference: https://wg21.link/mismatch#:~:text=ranges::mismatch(I1
+template <
+    typename ForwardIterator1,
+    typename ForwardIterator2,
+    typename Pred = ranges::equal_to,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator1>,
+    typename = internal::iterator_category_t<ForwardIterator2>,
+    typename = std::indirect_result_t<Pred&,
+                                      std::projected<ForwardIterator1, Proj1>,
+                                      std::projected<ForwardIterator2, Proj2>>>
+constexpr auto mismatch(ForwardIterator1 first1,
+                        ForwardIterator1 last1,
+                        ForwardIterator2 first2,
+                        ForwardIterator2 last2,
+                        Pred pred = {},
+                        Proj1 proj1 = {},
+                        Proj2 proj2 = {}) {
+  return std::mismatch(first1, last1, first2, last2,
+                       internal::ProjectedBinaryPredicate(pred, proj1, proj2));
+}
+
+// Let `E(n)` be `!invoke(pred, invoke(proj1, *(begin(range1) + n)),
+//                              invoke(proj2, *(begin(range2) + n)))`.
+//
+// Let `N` be `min(size(range1), size(range2))`.
+//
+// Returns: `{ begin(range1) + n, begin(range2) + n }`, where `n` is the
+// smallest integer in `[0, N)` such that `E(n)` holds, or `N` if no such
+// integer exists.
+//
+// Complexity: At most `N` applications of the corresponding predicate and any
+// projections.
+//
+// Reference: https://wg21.link/mismatch#:~:text=ranges::mismatch(R1
+template <typename Range1,
+          typename Range2,
+          typename Pred = ranges::equal_to,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename =
+              std::indirect_result_t<Pred&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>>
+constexpr auto mismatch(Range1&& range1,
+                        Range2&& range2,
+                        Pred pred = {},
+                        Proj1 proj1 = {},
+                        Proj2 proj2 = {}) {
+  return ranges::mismatch(std::ranges::begin(range1), std::ranges::end(range1),
+                          std::ranges::begin(range2), std::ranges::end(range2),
+                          std::move(pred), std::move(proj1), std::move(proj2));
+}
+
+// [alg.equal] Equal
+// Reference: https://wg21.link/alg.equal
+
+// Let `E(i)` be
+//   `invoke(pred, invoke(proj1, *i), invoke(proj2, *(first2 + (i - first1))))`.
+//
+// Returns: If `last1 - first1 != last2 - first2`, return `false.` Otherwise
+// return `true` if `E(i)` holds for every iterator `i` in the range `[first1,
+// last1)`. Otherwise, returns `false`.
+//
+// Complexity: If the types of `first1`, `last1`, `first2`, and `last2` meet the
+// `RandomAccessIterator` requirements and `last1 - first1 != last2 - first2`,
+// then no applications of the corresponding predicate and each projection;
+// otherwise, at most `min(last1 - first1, last2 - first2)` applications of the
+// corresponding predicate and any projections.
+//
+// Reference: https://wg21.link/alg.equal#:~:text=ranges::equal(I1
+template <
+    typename ForwardIterator1,
+    typename ForwardIterator2,
+    typename Pred = ranges::equal_to,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator1>,
+    typename = internal::iterator_category_t<ForwardIterator2>,
+    typename = std::indirect_result_t<Pred&,
+                                      std::projected<ForwardIterator1, Proj1>,
+                                      std::projected<ForwardIterator2, Proj2>>>
+constexpr bool equal(ForwardIterator1 first1,
+                     ForwardIterator1 last1,
+                     ForwardIterator2 first2,
+                     ForwardIterator2 last2,
+                     Pred pred = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}) {
+  if (std::is_constant_evaluated()) {
+    for (; first1 != last1 && first2 != last2; ++first1, ++first2) {
+      if (!std::invoke(pred, std::invoke(proj1, *first1),
+                       std::invoke(proj2, *first2))) {
+        return false;
+      }
+    }
+
+    return first1 == last1 && first2 == last2;
+  }
+
+  return std::equal(first1, last1, first2, last2,
+                    internal::ProjectedBinaryPredicate(pred, proj1, proj2));
+}
+
+// Let `E(i)` be
+//   `invoke(pred, invoke(proj1, *i),
+//                 invoke(proj2, *(begin(range2) + (i - begin(range1)))))`.
+//
+// Returns: If `size(range1) != size(range2)`, return `false.` Otherwise return
+// `true` if `E(i)` holds for every iterator `i` in `range1`. Otherwise, returns
+// `false`.
+//
+// Complexity: If the types of `begin(range1)`, `end(range1)`, `begin(range2)`,
+// and `end(range2)` meet the `RandomAccessIterator` requirements and
+// `size(range1) != size(range2)`, then no applications of the corresponding
+// predicate and each projection;
+// otherwise, at most `min(size(range1), size(range2))` applications of the
+// corresponding predicate and any projections.
+//
+// Reference: https://wg21.link/alg.equal#:~:text=ranges::equal(R1
+template <typename Range1,
+          typename Range2,
+          typename Pred = ranges::equal_to,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename =
+              std::indirect_result_t<Pred&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>>
+constexpr bool equal(Range1&& range1,
+                     Range2&& range2,
+                     Pred pred = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}) {
+  return ranges::equal(std::ranges::begin(range1), std::ranges::end(range1),
+                       std::ranges::begin(range2), std::ranges::end(range2),
+                       std::move(pred), std::move(proj1), std::move(proj2));
+}
+
+// [alg.is.permutation] Is permutation
+// Reference: https://wg21.link/alg.is.permutation
+
+// Returns: If `last1 - first1 != last2 - first2`, return `false`. Otherwise
+// return `true` if there exists a permutation of the elements in the range
+// `[first2, last2)`, bounded by `[pfirst, plast)`, such that
+// `ranges::equal(first1, last1, pfirst, plast, pred, proj, proj)` returns
+// `true`; otherwise, returns `false`.
+//
+// Complexity: No applications of the corresponding predicate if
+// ForwardIterator1 and ForwardIterator2 meet the requirements of random access
+// iterators and `last1 - first1 != last2 - first2`. Otherwise, exactly
+// `last1 - first1` applications of the corresponding predicate and projections
+// if `ranges::equal(first1, last1, first2, last2, pred, proj, proj)` would
+// return true;
+// otherwise, at worst `O(N^2)`, where `N` has the value `last1 - first1`.
+//
+// Reference:
+// https://wg21.link/alg.is.permutation#:~:text=ranges::is_permutation(I1
+template <
+    typename ForwardIterator1,
+    typename ForwardIterator2,
+    typename Pred = ranges::equal_to,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator1>,
+    typename = internal::iterator_category_t<ForwardIterator2>,
+    typename = std::indirect_result_t<Pred&,
+                                      std::projected<ForwardIterator1, Proj1>,
+                                      std::projected<ForwardIterator2, Proj2>>>
+constexpr bool is_permutation(ForwardIterator1 first1,
+                              ForwardIterator1 last1,
+                              ForwardIterator2 first2,
+                              ForwardIterator2 last2,
+                              Pred pred = {},
+                              Proj1 proj1 = {},
+                              Proj2 proj2 = {}) {
+  // Needs to opt-in to all permutations, since std::is_permutation expects
+  // pred(proj1(lhs), proj1(rhs)) to compile.
+  return std::is_permutation(
+      first1, last1, first2, last2,
+      internal::PermutedProjectedBinaryPredicate(pred, proj1, proj2));
+}
+
+// Returns: If `size(range1) != size(range2)`, return `false`. Otherwise return
+// `true` if there exists a permutation of the elements in `range2`, bounded by
+// `[pbegin, pend)`, such that
+// `ranges::equal(range1, [pbegin, pend), pred, proj, proj)` returns `true`;
+// otherwise, returns `false`.
+//
+// Complexity: No applications of the corresponding predicate if Range1 and
+// Range2 meet the requirements of random access ranges and
+// `size(range1) != size(range2)`. Otherwise, exactly `size(range1)`
+// applications of the corresponding predicate and projections if
+// `ranges::equal(range1, range2, pred, proj, proj)` would return true;
+// otherwise, at worst `O(N^2)`, where `N` has the value `size(range1)`.
+//
+// Reference:
+// https://wg21.link/alg.is.permutation#:~:text=ranges::is_permutation(R1
+template <typename Range1,
+          typename Range2,
+          typename Pred = ranges::equal_to,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename =
+              std::indirect_result_t<Pred&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>>
+constexpr bool is_permutation(Range1&& range1,
+                              Range2&& range2,
+                              Pred pred = {},
+                              Proj1 proj1 = {},
+                              Proj2 proj2 = {}) {
+  return ranges::is_permutation(
+      std::ranges::begin(range1), std::ranges::end(range1),
+      std::ranges::begin(range2), std::ranges::end(range2), std::move(pred),
+      std::move(proj1), std::move(proj2));
+}
+
+// [alg.search] Search
+// Reference: https://wg21.link/alg.search
+
+// Returns: `i`, where `i` is the first iterator in the range
+// `[first1, last1 - (last2 - first2))` such that for every non-negative integer
+// `n` less than `last2 - first2` the condition
+// `bool(invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n))))`
+// is `true`.
+// Returns `last1` if no such iterator exists.
+// Note: std::ranges::search(I1 first1,...) returns a range, rather than an
+// iterator. For simplicitly we match std::search's return type instead.
+//
+// Complexity: At most `(last1 - first1) * (last2 - first2)` applications of the
+// corresponding predicate and projections.
+//
+// Reference: https://wg21.link/alg.search#:~:text=ranges::search(I1
+template <
+    typename ForwardIterator1,
+    typename ForwardIterator2,
+    typename Pred = ranges::equal_to,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator1>,
+    typename = internal::iterator_category_t<ForwardIterator2>,
+    typename = std::indirect_result_t<Pred&,
+                                      std::projected<ForwardIterator1, Proj1>,
+                                      std::projected<ForwardIterator2, Proj2>>>
+constexpr auto search(ForwardIterator1 first1,
+                      ForwardIterator1 last1,
+                      ForwardIterator2 first2,
+                      ForwardIterator2 last2,
+                      Pred pred = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}) {
+  return std::search(first1, last1, first2, last2,
+                     internal::ProjectedBinaryPredicate(pred, proj1, proj2));
+}
+
+// Returns: `i`, where `i` is the first iterator in the range
+// `[begin(range1), end(range1) - size(range2))` such that for every
+// non-negative integer `n` less than `size(range2)` the condition
+// `bool(invoke(pred, invoke(proj1, *(i + n)),
+//                    invoke(proj2, *(begin(range2) + n))))` is `true`.
+// Returns `end(range1)` if no such iterator exists.
+// Note: std::ranges::search(R1&& r1,...) returns a range, rather than an
+// iterator. For simplicitly we match std::search's return type instead.
+//
+// Complexity: At most `size(range1) * size(range2)` applications of the
+// corresponding predicate and projections.
+//
+// Reference: https://wg21.link/alg.search#:~:text=ranges::search(R1
+template <typename Range1,
+          typename Range2,
+          typename Pred = ranges::equal_to,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename =
+              std::indirect_result_t<Pred&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>>
+constexpr auto search(Range1&& range1,
+                      Range2&& range2,
+                      Pred pred = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}) {
+  return ranges::search(std::ranges::begin(range1), std::ranges::end(range1),
+                        std::ranges::begin(range2), std::ranges::end(range2),
+                        std::move(pred), std::move(proj1), std::move(proj2));
+}
+
+// Mandates: The type `Size` is convertible to an integral type.
+//
+// Returns: `i` where `i` is the first iterator in the range
+// `[first, last - count)` such that for every non-negative integer `n` less
+// than `count`, the following condition holds:
+// `invoke(pred, invoke(proj, *(i + n)), value)`.
+// Returns `last` if no such iterator is found.
+// Note: std::ranges::search_n(I1 first1,...) returns a range, rather than an
+// iterator. For simplicitly we match std::search_n's return type instead.
+//
+// Complexity: At most `last - first` applications of the corresponding
+// predicate and projection.
+//
+// Reference: https://wg21.link/alg.search#:~:text=ranges::search_n(I
+template <typename ForwardIterator,
+          typename Size,
+          typename T,
+          typename Pred = ranges::equal_to,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto search_n(ForwardIterator first,
+                        ForwardIterator last,
+                        Size count,
+                        const T& value,
+                        Pred pred = {},
+                        Proj proj = {}) {
+  // The second arg is guaranteed to be `value`, so we'll simply apply the
+  // std::identity projection.
+  std::identity value_proj;
+  return std::search_n(
+      first, last, count, value,
+      internal::ProjectedBinaryPredicate(pred, proj, value_proj));
+}
+
+// Mandates: The type `Size` is convertible to an integral type.
+//
+// Returns: `i` where `i` is the first iterator in the range
+// `[begin(range), end(range) - count)` such that for every non-negative integer
+// `n` less than `count`, the following condition holds:
+// `invoke(pred, invoke(proj, *(i + n)), value)`.
+// Returns `end(arnge)` if no such iterator is found.
+// Note: std::ranges::search_n(R1&& r1,...) returns a range, rather than an
+// iterator. For simplicitly we match std::search_n's return type instead.
+//
+// Complexity: At most `size(range)` applications of the corresponding predicate
+// and projection.
+//
+// Reference: https://wg21.link/alg.search#:~:text=ranges::search_n(R
+template <typename Range,
+          typename Size,
+          typename T,
+          typename Pred = ranges::equal_to,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto search_n(Range&& range,
+                        Size count,
+                        const T& value,
+                        Pred pred = {},
+                        Proj proj = {}) {
+  return ranges::search_n(std::ranges::begin(range), std::ranges::end(range),
+                          count, value, std::move(pred), std::move(proj));
+}
+
+// [alg.modifying.operations] Mutating sequence operations
+// Reference: https://wg21.link/alg.modifying.operations
+
+// [alg.copy] Copy
+// Reference: https://wg21.link/alg.copy
+
+// Let N be `last - first`.
+//
+// Preconditions: `result` is not in the range `[first, last)`.
+//
+// Effects: Copies elements in the range `[first, last)` into the range
+// `[result, result + N)` starting from `first` and proceeding to `last`. For
+// each non-negative integer `n < N` , performs `*(result + n) = *(first + n)`.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.copy#:~:text=ranges::copy(I
+template <typename InputIterator,
+          typename OutputIterator,
+          typename = internal::iterator_category_t<InputIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto copy(InputIterator first,
+                    InputIterator last,
+                    OutputIterator result) {
+  return std::copy(first, last, result);
+}
+
+// Let N be `size(range)`.
+//
+// Preconditions: `result` is not in `range`.
+//
+// Effects: Copies elements in `range` into the range `[result, result + N)`
+// starting from `begin(range)` and proceeding to `end(range)`. For each
+// non-negative integer `n < N` , performs
+// *(result + n) = *(begin(range) + n)`.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.copy#:~:text=ranges::copy(R
+template <typename Range,
+          typename OutputIterator,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto copy(Range&& range, OutputIterator result) {
+  return ranges::copy(std::ranges::begin(range), std::ranges::end(range),
+                      result);
+}
+
+// Let `N` be `max(0, n)`.
+//
+// Mandates: The type `Size` is convertible to an integral type.
+//
+// Effects: For each non-negative integer `i < N`, performs
+// `*(result + i) = *(first + i)`.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.copy#:~:text=ranges::copy_n
+template <typename InputIterator,
+          typename Size,
+          typename OutputIterator,
+          typename = internal::iterator_category_t<InputIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto copy_n(InputIterator first, Size n, OutputIterator result) {
+  return std::copy_n(first, n, result);
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`, and `N` be the number
+// of iterators `i` in the range `[first, last)` for which the condition `E(i)`
+// holds.
+//
+// Preconditions: The ranges `[first, last)` and
+// `[result, result + (last - first))` do not overlap.
+//
+// Effects: Copies all of the elements referred to by the iterator `i` in the
+// range `[first, last)` for which `E(i)` is true.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/alg.copy#:~:text=ranges::copy_if(I
+template <typename InputIterator,
+          typename OutputIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto copy_if(InputIterator first,
+                       InputIterator last,
+                       OutputIterator result,
+                       Pred pred,
+                       Proj proj = {}) {
+  return std::copy_if(first, last, result,
+                      internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`, and `N` be the number
+// of iterators `i` in `range` for which the condition `E(i)` holds.
+//
+// Preconditions: `range`  and `[result, result + size(range))` do not overlap.
+//
+// Effects: Copies all of the elements referred to by the iterator `i` in
+// `range` for which `E(i)` is true.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `size(range)` applications of the corresponding predicate
+// and any projection.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/alg.copy#:~:text=ranges::copy_if(R
+template <typename Range,
+          typename OutputIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto copy_if(Range&& range,
+                       OutputIterator result,
+                       Pred pred,
+                       Proj proj = {}) {
+  return ranges::copy_if(std::ranges::begin(range), std::ranges::end(range),
+                         result, std::move(pred), std::move(proj));
+}
+
+// Let `N` be `last - first`.
+//
+// Preconditions: `result` is not in the range `(first, last]`.
+//
+// Effects: Copies elements in the range `[first, last)` into the range
+// `[result - N, result)` starting from `last - 1` and proceeding to `first`.
+// For each positive integer `n  N`, performs `*(result - n) = *(last - n)`.
+//
+// Returns: `result - N`
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.copy#:~:text=ranges::copy_backward(I1
+template <typename BidirectionalIterator1,
+          typename BidirectionalIterator2,
+          typename = internal::iterator_category_t<BidirectionalIterator1>,
+          typename = internal::iterator_category_t<BidirectionalIterator2>>
+constexpr auto copy_backward(BidirectionalIterator1 first,
+                             BidirectionalIterator1 last,
+                             BidirectionalIterator2 result) {
+  return std::copy_backward(first, last, result);
+}
+
+// Let `N` be `size(range)`.
+//
+// Preconditions: `result` is not in the range `(begin(range), end(range)]`.
+//
+// Effects: Copies elements in `range` into the range `[result - N, result)`
+// starting from `end(range) - 1` and proceeding to `begin(range)`. For each
+// positive integer `n  N`, performs `*(result - n) = *(end(range) - n)`.
+//
+// Returns: `result - N`
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.copy#:~:text=ranges::copy_backward(R
+template <typename Range,
+          typename BidirectionalIterator,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<BidirectionalIterator>>
+constexpr auto copy_backward(Range&& range, BidirectionalIterator result) {
+  return ranges::copy_backward(std::ranges::begin(range),
+                               std::ranges::end(range), result);
+}
+
+// [alg.move] Move
+// Reference: https://wg21.link/alg.move
+
+// Let `E(n)` be `std::move(*(first + n))`.
+//
+// Let `N` be `last - first`.
+//
+// Preconditions: `result` is not in the range `[first, last)`.
+//
+// Effects: Moves elements in the range `[first, last)` into the range `[result,
+// result + N)` starting from `first` and proceeding to `last`. For each
+// non-negative integer `n < N`, performs `*(result + n) = E(n)`.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.move#:~:text=ranges::move(I
+template <typename InputIterator,
+          typename OutputIterator,
+          typename = internal::iterator_category_t<InputIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto move(InputIterator first,
+                    InputIterator last,
+                    OutputIterator result) {
+  return std::move(first, last, result);
+}
+
+// Let `E(n)` be `std::move(*(begin(range) + n))`.
+//
+// Let `N` be `size(range)`.
+//
+// Preconditions: `result` is not in `range`.
+//
+// Effects: Moves elements in `range` into the range `[result, result + N)`
+// starting from `begin(range)` and proceeding to `end(range)`. For each
+// non-negative integer `n < N`, performs `*(result + n) = E(n)`.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.move#:~:text=ranges::move(R
+template <typename Range,
+          typename OutputIterator,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto move(Range&& range, OutputIterator result) {
+  return ranges::move(std::ranges::begin(range), std::ranges::end(range),
+                      result);
+}
+
+// Let `E(n)` be `std::move(*(last - n))`.
+//
+// Let `N` be `last - first`.
+//
+// Preconditions: `result` is not in the range `(first, last]`.
+//
+// Effects: Moves elements in the range `[first, last)` into the range
+// `[result - N, result)` starting from `last - 1` and proceeding to `first`.
+// For each positive integer `n  N`, performs `*(result - n) = E(n)`.
+//
+// Returns: `result - N`
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.move#:~:text=ranges::move_backward(I1
+template <typename BidirectionalIterator1,
+          typename BidirectionalIterator2,
+          typename = internal::iterator_category_t<BidirectionalIterator1>,
+          typename = internal::iterator_category_t<BidirectionalIterator2>>
+constexpr auto move_backward(BidirectionalIterator1 first,
+                             BidirectionalIterator1 last,
+                             BidirectionalIterator2 result) {
+  return std::move_backward(first, last, result);
+}
+
+// Let `E(n)` be `std::move(*(end(range) - n))`.
+//
+// Let `N` be `size(range)`.
+//
+// Preconditions: `result` is not in the range `(begin(range), end(range)]`.
+//
+// Effects: Moves elements in `range` into the range `[result - N, result)`
+// starting from `end(range) - 1` and proceeding to `begin(range)`. For each
+// positive integer `n  N`, performs `*(result - n) = E(n)`.
+//
+// Returns: `result - N`
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.move#:~:text=ranges::move_backward(R
+template <typename Range,
+          typename BidirectionalIterator,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<BidirectionalIterator>>
+constexpr auto move_backward(Range&& range, BidirectionalIterator result) {
+  return ranges::move_backward(std::ranges::begin(range),
+                               std::ranges::end(range), result);
+}
+
+// [alg.swap] Swap
+// Reference: https://wg21.link/alg.swap
+
+// Let `M` be `min(last1 - first1, last2 - first2)`.
+//
+// Preconditions: The two ranges `[first1, last1)` and `[first2, last2)` do not
+// overlap. `*(first1 + n)` is swappable with `*(first2 + n)`.
+//
+// Effects: For each non-negative integer `n < M` performs
+// `swap(*(first1 + n), *(first2 + n))`
+//
+// Returns: `first2 + M`
+//
+// Complexity: Exactly `M` swaps.
+//
+// Reference: https://wg21.link/alg.swap#:~:text=ranges::swap_ranges(I1
+template <typename ForwardIterator1,
+          typename ForwardIterator2,
+          typename = internal::iterator_category_t<ForwardIterator1>,
+          typename = internal::iterator_category_t<ForwardIterator2>>
+constexpr auto swap_ranges(ForwardIterator1 first1,
+                           ForwardIterator1 last1,
+                           ForwardIterator2 first2,
+                           ForwardIterator2 last2) {
+  // std::swap_ranges does not have a `last2` overload. Thus we need to
+  // adjust `last1` to ensure to not read past `last2`.
+  last1 = std::next(first1, std::min(std::distance(first1, last1),
+                                     std::distance(first2, last2)));
+  return std::swap_ranges(first1, last1, first2);
+}
+
+// Let `M` be `min(size(range1), size(range2))`.
+//
+// Preconditions: The two ranges `range1` and `range2` do not overlap.
+// `*(begin(range1) + n)` is swappable with `*(begin(range2) + n)`.
+//
+// Effects: For each non-negative integer `n < M` performs
+// `swap(*(begin(range1) + n), *(begin(range2) + n))`
+//
+// Returns: `begin(range2) + M`
+//
+// Complexity: Exactly `M` swaps.
+//
+// Reference: https://wg21.link/alg.swap#:~:text=ranges::swap_ranges(R1
+template <typename Range1,
+          typename Range2,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>>
+constexpr auto swap_ranges(Range1&& range1, Range2&& range2) {
+  return ranges::swap_ranges(
+      std::ranges::begin(range1), std::ranges::end(range1),
+      std::ranges::begin(range2), std::ranges::end(range2));
+}
+
+// [alg.transform] Transform
+// Reference: https://wg21.link/alg.transform
+
+// Let `N` be `last1 - first1`,
+// `E(i)` be `invoke(op, invoke(proj, *(first1 + (i - result))))`.
+//
+// Preconditions: `op` does not invalidate iterators or subranges, nor modify
+// elements in the ranges `[first1, first1 + N]`, and `[result, result + N]`.
+//
+// Effects: Assigns through every iterator `i` in the range
+// `[result, result + N)` a new corresponding value equal to `E(i)`.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `N` applications of `op` and any projections.
+//
+// Remarks: result may be equal to `first1`.
+//
+// Reference: https://wg21.link/alg.transform#:~:text=ranges::transform(I
+template <
+    typename InputIterator,
+    typename OutputIterator,
+    typename UnaryOperation,
+    typename Proj = std::identity,
+    typename = internal::iterator_category_t<InputIterator>,
+    typename = internal::iterator_category_t<OutputIterator>,
+    typename = std::indirect_result_t<UnaryOperation&,
+                                      std::projected<InputIterator, Proj>>>
+constexpr auto transform(InputIterator first1,
+                         InputIterator last1,
+                         OutputIterator result,
+                         UnaryOperation op,
+                         Proj proj = {}) {
+  return std::transform(first1, last1, result, [&op, &proj](auto&& arg) {
+    return std::invoke(op, std::invoke(proj, std::forward<decltype(arg)>(arg)));
+  });
+}
+
+// Let `N` be `size(range)`,
+// `E(i)` be `invoke(op, invoke(proj, *(begin(range) + (i - result))))`.
+//
+// Preconditions: `op` does not invalidate iterators or subranges, nor modify
+// elements in the ranges `[begin(range), end(range)]`, and
+// `[result, result + N]`.
+//
+// Effects: Assigns through every iterator `i` in the range
+// `[result, result + N)` a new corresponding value equal to `E(i)`.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `N` applications of `op` and any projections.
+//
+// Remarks: result may be equal to `begin(range)`.
+//
+// Reference: https://wg21.link/alg.transform#:~:text=ranges::transform(R
+template <
+    typename Range,
+    typename OutputIterator,
+    typename UnaryOperation,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = internal::iterator_category_t<OutputIterator>,
+    typename = std::indirect_result_t<UnaryOperation&,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto transform(Range&& range,
+                         OutputIterator result,
+                         UnaryOperation op,
+                         Proj proj = {}) {
+  return ranges::transform(std::ranges::begin(range), std::ranges::end(range),
+                           result, std::move(op), std::move(proj));
+}
+
+// Let:
+// `N` be `min(last1 - first1, last2 - first2)`,
+// `E(i)` be `invoke(binary_op, invoke(proj1, *(first1 + (i - result))),
+//                              invoke(proj2, *(first2 + (i - result))))`.
+//
+// Preconditions: `binary_op` does not invalidate iterators or subranges, nor
+// modify elements in the ranges `[first1, first1 + N]`, `[first2, first2 + N]`,
+// and `[result, result + N]`.
+//
+// Effects: Assigns through every iterator `i` in the range
+// `[result, result + N)` a new corresponding value equal to `E(i)`.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `N` applications of `binary_op`, and any projections.
+//
+// Remarks: `result` may be equal to `first1` or `first2`.
+//
+// Reference: https://wg21.link/alg.transform#:~:text=ranges::transform(I1
+template <
+    typename ForwardIterator1,
+    typename ForwardIterator2,
+    typename OutputIterator,
+    typename BinaryOperation,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator1>,
+    typename = internal::iterator_category_t<ForwardIterator2>,
+    typename = internal::iterator_category_t<OutputIterator>,
+    typename = std::indirect_result_t<BinaryOperation&,
+                                      std::projected<ForwardIterator1, Proj1>,
+                                      std::projected<ForwardIterator2, Proj2>>>
+constexpr auto transform(ForwardIterator1 first1,
+                         ForwardIterator1 last1,
+                         ForwardIterator2 first2,
+                         ForwardIterator2 last2,
+                         OutputIterator result,
+                         BinaryOperation binary_op,
+                         Proj1 proj1 = {},
+                         Proj2 proj2 = {}) {
+  // std::transform does not have a `last2` overload. Thus we need to adjust
+  // `last1` to ensure to not read past `last2`.
+  last1 = std::next(first1, std::min(std::distance(first1, last1),
+                                     std::distance(first2, last2)));
+  return std::transform(
+      first1, last1, first2, result,
+      [&binary_op, &proj1, &proj2](auto&& lhs, auto&& rhs) {
+        return std::invoke(
+            binary_op, std::invoke(proj1, std::forward<decltype(lhs)>(lhs)),
+            std::invoke(proj2, std::forward<decltype(rhs)>(rhs)));
+      });
+}
+
+// Let:
+// `N` be `min(size(range1), size(range2)`,
+// `E(i)` be `invoke(binary_op, invoke(proj1, *(begin(range1) + (i - result))),
+//                              invoke(proj2, *(begin(range2) + (i - result))))`
+//
+// Preconditions: `binary_op` does not invalidate iterators or subranges, nor
+// modify elements in the ranges `[begin(range1), end(range1)]`,
+// `[begin(range2), end(range2)]`, and `[result, result + N]`.
+//
+// Effects: Assigns through every iterator `i` in the range
+// `[result, result + N)` a new corresponding value equal to `E(i)`.
+//
+// Returns: `result + N`
+//
+// Complexity: Exactly `N` applications of `binary_op`, and any projections.
+//
+// Remarks: `result` may be equal to `begin(range1)` or `begin(range2)`.
+//
+// Reference: https://wg21.link/alg.transform#:~:text=ranges::transform(R1
+template <typename Range1,
+          typename Range2,
+          typename OutputIterator,
+          typename BinaryOperation,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename = internal::iterator_category_t<OutputIterator>,
+          typename =
+              std::indirect_result_t<BinaryOperation&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>>
+constexpr auto transform(Range1&& range1,
+                         Range2&& range2,
+                         OutputIterator result,
+                         BinaryOperation binary_op,
+                         Proj1 proj1 = {},
+                         Proj2 proj2 = {}) {
+  return ranges::transform(std::ranges::begin(range1), std::ranges::end(range1),
+                           std::ranges::begin(range2), std::ranges::end(range2),
+                           result, std::move(binary_op), std::move(proj1),
+                           std::move(proj2));
+}
+
+// [alg.replace] Replace
+// Reference: https://wg21.link/alg.replace
+
+// Let `E(i)` be `bool(invoke(proj, *i) == old_value)`.
+//
+// Mandates: `new_value` is writable  to `first`.
+//
+// Effects: Substitutes elements referred by the iterator `i` in the range
+// `[first, last)` with `new_value`, when `E(i)` is true.
+//
+// Returns: `last`
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.replace#:~:text=ranges::replace(I
+template <typename ForwardIterator,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto replace(ForwardIterator first,
+                       ForwardIterator last,
+                       const T& old_value,
+                       const T& new_value,
+                       Proj proj = {}) {
+  // Note: In order to be able to apply `proj` to each element in [first, last)
+  // we are dispatching to std::replace_if instead of std::replace.
+  std::replace_if(
+      first, last,
+      [&proj, &old_value](auto&& lhs) {
+        return std::invoke(proj, std::forward<decltype(lhs)>(lhs)) == old_value;
+      },
+      new_value);
+  return last;
+}
+
+// Let `E(i)` be `bool(invoke(proj, *i) == old_value)`.
+//
+// Mandates: `new_value` is writable  to `begin(range)`.
+//
+// Effects: Substitutes elements referred by the iterator `i` in `range` with
+// `new_value`, when `E(i)` is true.
+//
+// Returns: `end(range)`
+//
+// Complexity: Exactly `size(range)` applications of the corresponding predicate
+// and any projection.
+//
+// Reference: https://wg21.link/alg.replace#:~:text=ranges::replace(R
+template <typename Range,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto replace(Range&& range,
+                       const T& old_value,
+                       const T& new_value,
+                       Proj proj = {}) {
+  return ranges::replace(std::ranges::begin(range), std::ranges::end(range),
+                         old_value, new_value, std::move(proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`.
+//
+// Mandates: `new_value` is writable  to `first`.
+//
+// Effects: Substitutes elements referred by the iterator `i` in the range
+// `[first, last)` with `new_value`, when `E(i)` is true.
+//
+// Returns: `last`
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.replace#:~:text=ranges::replace_if(I
+template <typename ForwardIterator,
+          typename Predicate,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto replace_if(ForwardIterator first,
+                          ForwardIterator last,
+                          Predicate pred,
+                          const T& new_value,
+                          Proj proj = {}) {
+  std::replace_if(first, last, internal::ProjectedUnaryPredicate(pred, proj),
+                  new_value);
+  return last;
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`.
+//
+// Mandates: `new_value` is writable  to `begin(range)`.
+//
+// Effects: Substitutes elements referred by the iterator `i` in `range` with
+// `new_value`, when `E(i)` is true.
+//
+// Returns: `end(range)`
+//
+// Complexity: Exactly `size(range)` applications of the corresponding predicate
+// and any projection.
+//
+// Reference: https://wg21.link/alg.replace#:~:text=ranges::replace_if(R
+template <typename Range,
+          typename Predicate,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto replace_if(Range&& range,
+                          Predicate pred,
+                          const T& new_value,
+                          Proj proj = {}) {
+  return ranges::replace_if(std::ranges::begin(range), std::ranges::end(range),
+                            std::move(pred), new_value, std::move(proj));
+}
+
+// Let `E(i)` be `bool(invoke(proj, *(first + (i - result))) == old_value)`.
+//
+// Mandates: The results of the expressions `*first` and `new_value` are
+// writable  to `result`.
+//
+// Preconditions: The ranges `[first, last)` and `[result, result + (last -
+// first))` do not overlap.
+//
+// Effects: Assigns through every iterator `i` in the range `[result, result +
+// (last - first))` a new corresponding value, `new_value` if `E(i)` is true, or
+// `*(first + (i - result))` otherwise.
+//
+// Returns: `result + (last - first)`.
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.replace#:~:text=ranges::replace_copy(I
+template <typename InputIterator,
+          typename OutputIterator,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto replace_copy(InputIterator first,
+                            InputIterator last,
+                            OutputIterator result,
+                            const T& old_value,
+                            const T& new_value,
+                            Proj proj = {}) {
+  // Note: In order to be able to apply `proj` to each element in [first, last)
+  // we are dispatching to std::replace_copy_if instead of std::replace_copy.
+  std::replace_copy_if(
+      first, last, result,
+      [&proj, &old_value](auto&& lhs) {
+        return std::invoke(proj, std::forward<decltype(lhs)>(lhs)) == old_value;
+      },
+      new_value);
+  return last;
+}
+
+// Let `E(i)` be
+// `bool(invoke(proj, *(begin(range) + (i - result))) == old_value)`.
+//
+// Mandates: The results of the expressions `*begin(range)` and `new_value` are
+// writable  to `result`.
+//
+// Preconditions: The ranges `range` and `[result, result + size(range))` do not
+// overlap.
+//
+// Effects: Assigns through every iterator `i` in the range `[result, result +
+// size(range))` a new corresponding value, `new_value` if `E(i)` is true, or
+// `*(begin(range) + (i - result))` otherwise.
+//
+// Returns: `result + size(range)`.
+//
+// Complexity: Exactly `size(range)` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.replace#:~:text=ranges::replace_copy(R
+template <typename Range,
+          typename OutputIterator,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto replace_copy(Range&& range,
+                            OutputIterator result,
+                            const T& old_value,
+                            const T& new_value,
+                            Proj proj = {}) {
+  return ranges::replace_copy(std::ranges::begin(range),
+                              std::ranges::end(range), result, old_value,
+                              new_value, std::move(proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *(first + (i - result)))))`.
+//
+// Mandates: The results of the expressions `*first` and `new_value` are
+// writable  to `result`.
+//
+// Preconditions: The ranges `[first, last)` and `[result, result + (last -
+// first))` do not overlap.
+//
+// Effects: Assigns through every iterator `i` in the range `[result, result +
+// (last - first))` a new corresponding value, `new_value` if `E(i)` is true, or
+// `*(first + (i - result))` otherwise.
+//
+// Returns: `result + (last - first)`.
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.replace#:~:text=ranges::replace_copy_if(I
+template <typename InputIterator,
+          typename OutputIterator,
+          typename Predicate,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto replace_copy_if(InputIterator first,
+                               InputIterator last,
+                               OutputIterator result,
+                               Predicate pred,
+                               const T& new_value,
+                               Proj proj = {}) {
+  return std::replace_copy_if(first, last, result,
+                              internal::ProjectedUnaryPredicate(pred, proj),
+                              new_value);
+}
+
+// Let `E(i)` be
+// `bool(invoke(pred, invoke(proj, *(begin(range) + (i - result)))))`.
+//
+// Mandates: The results of the expressions `*begin(range)` and `new_value` are
+// writable  to `result`.
+//
+// Preconditions: The ranges `range` and `[result, result + size(range))` do not
+// overlap.
+//
+// Effects: Assigns through every iterator `i` in the range `[result, result +
+// size(range))` a new corresponding value, `new_value` if `E(i)` is true, or
+// `*(begin(range) + (i - result))` otherwise.
+//
+// Returns: `result + size(range)`.
+//
+// Complexity: Exactly `size(range)` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.replace#:~:text=ranges::replace_copy_if(R
+template <typename Range,
+          typename OutputIterator,
+          typename Predicate,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto replace_copy_if(Range&& range,
+                               OutputIterator result,
+                               Predicate pred,
+                               const T& new_value,
+                               Proj proj = {}) {
+  return ranges::replace_copy_if(std::ranges::begin(range),
+                                 std::ranges::end(range), result, pred,
+                                 new_value, std::move(proj));
+}
+
+// [alg.fill] Fill
+// Reference: https://wg21.link/alg.fill
+
+// Let `N` be `last - first`.
+//
+// Mandates: The expression `value` is writable to the output iterator.
+//
+// Effects: Assigns `value` through all the iterators in the range
+// `[first, last)`.
+//
+// Returns: `last`.
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.fill#:~:text=ranges::fill(O
+template <typename OutputIterator,
+          typename T,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto fill(OutputIterator first, OutputIterator last, const T& value) {
+  std::fill(first, last, value);
+  return last;
+}
+
+// Let `N` be `size(range)`.
+//
+// Mandates: The expression `value` is writable to the output iterator.
+//
+// Effects: Assigns `value` through all the iterators in `range`.
+//
+// Returns: `end(range)`.
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.fill#:~:text=ranges::fill(R
+template <typename Range,
+          typename T,
+          typename = internal::range_category_t<Range>>
+constexpr auto fill(Range&& range, const T& value) {
+  return ranges::fill(std::ranges::begin(range), std::ranges::end(range),
+                      value);
+}
+
+// Let `N` be `max(0, n)`.
+//
+// Mandates: The expression `value` is writable to the output iterator.
+// The type `Size` is convertible to an integral type.
+//
+// Effects: Assigns `value` through all the iterators in `[first, first + N)`.
+//
+// Returns: `first + N`.
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.fill#:~:text=ranges::fill_n(O
+template <typename OutputIterator,
+          typename Size,
+          typename T,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto fill_n(OutputIterator first, Size n, const T& value) {
+  return std::fill_n(first, n, value);
+}
+
+// [alg.generate] Generate
+// Reference: https://wg21.link/alg.generate
+
+// Let `N` be `last - first`.
+//
+// Effects: Assigns the result of successive evaluations of gen() through each
+// iterator in the range `[first, last)`.
+//
+// Returns: `last`.
+//
+// Complexity: Exactly `N` evaluations of `gen()` and assignments.
+//
+// Reference: https://wg21.link/alg.generate#:~:text=ranges::generate(O
+template <typename OutputIterator,
+          typename Generator,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto generate(OutputIterator first,
+                        OutputIterator last,
+                        Generator gen) {
+  std::generate(first, last, std::move(gen));
+  return last;
+}
+
+// Let `N` be `size(range)`.
+//
+// Effects: Assigns the result of successive evaluations of gen() through each
+// iterator in `range`.
+//
+// Returns: `end(range)`.
+//
+// Complexity: Exactly `N` evaluations of `gen()` and assignments.
+//
+// Reference: https://wg21.link/alg.generate#:~:text=ranges::generate(R
+template <typename Range,
+          typename Generator,
+          typename = internal::range_category_t<Range>>
+constexpr auto generate(Range&& range, Generator gen) {
+  return ranges::generate(std::ranges::begin(range), std::ranges::end(range),
+                          std::move(gen));
+}
+
+// Let `N` be `max(0, n)`.
+//
+// Mandates: `Size` is convertible to an integral type.
+//
+// Effects: Assigns the result of successive evaluations of gen() through each
+// iterator in the range `[first, first + N)`.
+//
+// Returns: `first + N`.
+//
+// Complexity: Exactly `N` evaluations of `gen()` and assignments.
+//
+// Reference: https://wg21.link/alg.generate#:~:text=ranges::generate_n(O
+template <typename OutputIterator,
+          typename Size,
+          typename Generator,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto generate_n(OutputIterator first, Size n, Generator gen) {
+  return std::generate_n(first, n, std::move(gen));
+}
+
+// [alg.remove] Remove
+// Reference: https://wg21.link/alg.remove
+
+// Let `E(i)` be `bool(invoke(proj, *i) == value)`.
+//
+// Effects: Eliminates all the elements referred to by iterator `i` in the range
+// `[first, last)` for which `E(i)` holds.
+//
+// Returns: The end of the resulting range.
+//
+// Remarks: Stable.
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.remove#:~:text=ranges::remove(I
+template <typename ForwardIterator,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto remove(ForwardIterator first,
+                      ForwardIterator last,
+                      const T& value,
+                      Proj proj = {}) {
+  // Note: In order to be able to apply `proj` to each element in [first, last)
+  // we are dispatching to std::remove_if instead of std::remove.
+  return std::remove_if(first, last, [&proj, &value](auto&& lhs) {
+    return std::invoke(proj, std::forward<decltype(lhs)>(lhs)) == value;
+  });
+}
+
+// Let `E(i)` be `bool(invoke(proj, *i) == value)`.
+//
+// Effects: Eliminates all the elements referred to by iterator `i` in `range`
+// for which `E(i)` holds.
+//
+// Returns: The end of the resulting range.
+//
+// Remarks: Stable.
+//
+// Complexity: Exactly `size(range)` applications of the corresponding predicate
+// and any projection.
+//
+// Reference: https://wg21.link/alg.remove#:~:text=ranges::remove(R
+template <typename Range,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto remove(Range&& range, const T& value, Proj proj = {}) {
+  return ranges::remove(std::ranges::begin(range), std::ranges::end(range),
+                        value, std::move(proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`.
+//
+// Effects: Eliminates all the elements referred to by iterator `i` in the range
+// `[first, last)` for which `E(i)` holds.
+//
+// Returns: The end of the resulting range.
+//
+// Remarks: Stable.
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Reference: https://wg21.link/alg.remove#:~:text=ranges::remove_if(I
+template <typename ForwardIterator,
+          typename Predicate,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto remove_if(ForwardIterator first,
+                         ForwardIterator last,
+                         Predicate pred,
+                         Proj proj = {}) {
+  return std::remove_if(first, last,
+                        internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`.
+//
+// Effects: Eliminates all the elements referred to by iterator `i` in `range`.
+//
+// Returns: The end of the resulting range.
+//
+// Remarks: Stable.
+//
+// Complexity: Exactly `size(range)` applications of the corresponding predicate
+// and any projection.
+//
+// Reference: https://wg21.link/alg.remove#:~:text=ranges::remove_if(R
+template <typename Range,
+          typename Predicate,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto remove_if(Range&& range, Predicate pred, Proj proj = {}) {
+  return ranges::remove_if(std::ranges::begin(range), std::ranges::end(range),
+                           std::move(pred), std::move(proj));
+}
+
+// Let `E(i)` be `bool(invoke(proj, *i) == value)`.
+//
+// Let `N` be the number of elements in `[first, last)` for which `E(i)` is
+// false.
+//
+// Mandates: `*first` is writable to `result`.
+//
+// Preconditions: The ranges `[first, last)` and `[result, result + (last -
+// first))` do not overlap.
+//
+// Effects: Copies all the elements referred to by the iterator `i` in the range
+// `[first, last)` for which `E(i)` is false.
+//
+// Returns: `result + N`.
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/alg.remove#:~:text=ranges::remove_copy(I
+template <typename InputIterator,
+          typename OutputIterator,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto remove_copy(InputIterator first,
+                           InputIterator last,
+                           OutputIterator result,
+                           const T& value,
+                           Proj proj = {}) {
+  // Note: In order to be able to apply `proj` to each element in [first, last)
+  // we are dispatching to std::remove_copy_if instead of std::remove_copy.
+  return std::remove_copy_if(first, last, result, [&proj, &value](auto&& lhs) {
+    return std::invoke(proj, std::forward<decltype(lhs)>(lhs)) == value;
+  });
+}
+
+// Let `E(i)` be `bool(invoke(proj, *i) == value)`.
+//
+// Let `N` be the number of elements in `range` for which `E(i)` is false.
+//
+// Mandates: `*begin(range)` is writable to `result`.
+//
+// Preconditions: The ranges `range` and `[result, result + size(range))` do not
+// overlap.
+//
+// Effects: Copies all the elements referred to by the iterator `i` in `range`
+//  for which `E(i)` is false.
+//
+// Returns: `result + N`.
+//
+// Complexity: Exactly `size(range)` applications of the corresponding
+// predicate and any projection.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/alg.remove#:~:text=ranges::remove_copy(R
+template <typename Range,
+          typename OutputIterator,
+          typename T,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto remove_copy(Range&& range,
+                           OutputIterator result,
+                           const T& value,
+                           Proj proj = {}) {
+  return ranges::remove_copy(std::ranges::begin(range), std::ranges::end(range),
+                             result, value, std::move(proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`.
+//
+// Let `N` be the number of elements in `[first, last)` for which `E(i)` is
+// false.
+//
+// Mandates: `*first` is writable to `result`.
+//
+// Preconditions: The ranges `[first, last)` and `[result, result + (last -
+// first))` do not overlap.
+//
+// Effects: Copies all the elements referred to by the iterator `i` in the range
+// `[first, last)` for which `E(i)` is false.
+//
+// Returns: `result + N`.
+//
+// Complexity: Exactly `last - first` applications of the corresponding
+// predicate and any projection.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/alg.remove#:~:text=ranges::remove_copy_if(I
+template <typename InputIterator,
+          typename OutputIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto remove_copy_if(InputIterator first,
+                              InputIterator last,
+                              OutputIterator result,
+                              Pred pred,
+                              Proj proj = {}) {
+  return std::remove_copy_if(first, last, result,
+                             internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// Let `E(i)` be `bool(invoke(pred, invoke(proj, *i)))`.
+//
+// Let `N` be the number of elements in `range` for which `E(i)` is false.
+//
+// Mandates: `*begin(range)` is writable to `result`.
+//
+// Preconditions: The ranges `range` and `[result, result + size(range))` do not
+// overlap.
+//
+// Effects: Copies all the elements referred to by the iterator `i` in `range`
+//  for which `E(i)` is false.
+//
+// Returns: `result + N`.
+//
+// Complexity: Exactly `size(range)` applications of the corresponding
+// predicate and any projection.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/alg.remove#:~:text=ranges::remove_copy(R
+template <typename Range,
+          typename OutputIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto remove_copy_if(Range&& range,
+                              OutputIterator result,
+                              Pred pred,
+                              Proj proj = {}) {
+  return ranges::remove_copy_if(std::ranges::begin(range),
+                                std::ranges::end(range), result,
+                                std::move(pred), std::move(proj));
+}
+
+// [alg.unique] Unique
+// Reference: https://wg21.link/alg.unique
+
+// Let `E(i)` be `bool(invoke(comp, invoke(proj, *(i - 1)), invoke(proj, *i)))`.
+//
+// Effects: For a nonempty range, eliminates all but the first element from
+// every consecutive group of equivalent elements referred to by the iterator
+// `i` in the range `[first + 1, last)` for which `E(i)` is true.
+//
+// Returns: The end of the resulting range.
+//
+// Complexity: For nonempty ranges, exactly `(last - first) - 1` applications of
+// the corresponding predicate and no more than twice as many applications of
+// any projection.
+//
+// Reference: https://wg21.link/alg.unique#:~:text=ranges::unique(I
+template <
+    typename ForwardIterator,
+    typename Comp = ranges::equal_to,
+    typename Proj = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<ForwardIterator, Proj>,
+                                      std::projected<ForwardIterator, Proj>>>
+constexpr auto unique(ForwardIterator first,
+                      ForwardIterator last,
+                      Comp comp = {},
+                      Proj proj = {}) {
+  return std::unique(first, last,
+                     internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Let `E(i)` be `bool(invoke(comp, invoke(proj, *(i - 1)), invoke(proj, *i)))`.
+//
+// Effects: For a nonempty range, eliminates all but the first element from
+// every consecutive group of equivalent elements referred to by the iterator
+// `i` in the range `[begin(range) + 1, end(range))` for which `E(i)` is true.
+//
+// Returns: The end of the resulting range.
+//
+// Complexity: For nonempty ranges, exactly `size(range) - 1` applications of
+// the corresponding predicate and no more than twice as many applications of
+// any projection.
+//
+// Reference: https://wg21.link/alg.unique#:~:text=ranges::unique(R
+template <
+    typename Range,
+    typename Comp = ranges::equal_to,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto unique(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::unique(std::ranges::begin(range), std::ranges::end(range),
+                        std::move(comp), std::move(proj));
+}
+
+// Let `E(i)` be `bool(invoke(comp, invoke(proj, *i), invoke(proj, *(i - 1))))`.
+//
+// Mandates: `*first` is writable to `result`.
+//
+// Preconditions: The ranges `[first, last)` and
+// `[result, result + (last - first))` do not overlap.
+//
+// Effects: Copies only the first element from every consecutive group of equal
+// elements referred to by the iterator `i` in the range `[first, last)` for
+// which `E(i)` holds.
+//
+// Returns: `result + N`.
+//
+// Complexity: Exactly `last - first - 1` applications of the corresponding
+// predicate and no more than twice as many applications of any projection.
+//
+// Reference: https://wg21.link/alg.unique#:~:text=ranges::unique_copy(I
+template <typename ForwardIterator,
+          typename OutputIterator,
+          typename Comp = ranges::equal_to,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto unique_copy(ForwardIterator first,
+                           ForwardIterator last,
+                           OutputIterator result,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  return std::unique_copy(first, last, result,
+                          internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Let `E(i)` be `bool(invoke(comp, invoke(proj, *i), invoke(proj, *(i - 1))))`.
+//
+// Mandates: `*begin(range)` is writable to `result`.
+//
+// Preconditions: The ranges `range` and `[result, result + size(range))` do not
+// overlap.
+//
+// Effects: Copies only the first element from every consecutive group of equal
+// elements referred to by the iterator `i` in `range` for which `E(i)` holds.
+//
+// Returns: `result + N`.
+//
+// Complexity: Exactly `size(range) - 1` applications of the corresponding
+// predicate and no more than twice as many applications of any projection.
+//
+// Reference: https://wg21.link/alg.unique#:~:text=ranges::unique_copy(R
+template <typename Range,
+          typename OutputIterator,
+          typename Comp = ranges::equal_to,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto unique_copy(Range&& range,
+                           OutputIterator result,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  return ranges::unique_copy(std::ranges::begin(range), std::ranges::end(range),
+                             result, std::move(comp), std::move(proj));
+}
+
+// [alg.reverse] Reverse
+// Reference: https://wg21.link/alg.reverse
+
+// Effects: For each non-negative integer `i < (last - first) / 2`, applies
+// `std::iter_swap` to all pairs of iterators `first + i, (last - i) - 1`.
+//
+// Returns: `last`.
+//
+// Complexity: Exactly `(last - first)/2` swaps.
+//
+// Reference: https://wg21.link/alg.reverse#:~:text=ranges::reverse(I
+template <typename BidirectionalIterator,
+          typename = internal::iterator_category_t<BidirectionalIterator>>
+constexpr auto reverse(BidirectionalIterator first,
+                       BidirectionalIterator last) {
+  std::reverse(first, last);
+  return last;
+}
+
+// Effects: For each non-negative integer `i < size(range) / 2`, applies
+// `std::iter_swap` to all pairs of iterators
+// `begin(range) + i, (end(range) - i) - 1`.
+//
+// Returns: `end(range)`.
+//
+// Complexity: Exactly `size(range)/2` swaps.
+//
+// Reference: https://wg21.link/alg.reverse#:~:text=ranges::reverse(R
+template <typename Range, typename = internal::range_category_t<Range>>
+constexpr auto reverse(Range&& range) {
+  return ranges::reverse(std::ranges::begin(range), std::ranges::end(range));
+}
+
+// Let `N` be `last - first`.
+//
+// Preconditions: The ranges `[first, last)` and `[result, result + N)` do not
+// overlap.
+//
+// Effects: Copies the range `[first, last)` to the range `[result, result + N)`
+// such that for every non-negative integer `i < N` the following assignment
+// takes place: `*(result + N - 1 - i) = *(first + i)`.
+//
+// Returns: `result + N`.
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.reverse#:~:text=ranges::reverse_copy(I
+template <typename BidirectionalIterator,
+          typename OutputIterator,
+          typename = internal::iterator_category_t<BidirectionalIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto reverse_copy(BidirectionalIterator first,
+                            BidirectionalIterator last,
+                            OutputIterator result) {
+  return std::reverse_copy(first, last, result);
+}
+
+// Let `N` be `size(range)`.
+//
+// Preconditions: The ranges `range` and `[result, result + N)` do not
+// overlap.
+//
+// Effects: Copies `range` to the range `[result, result + N)` such that for
+// every non-negative integer `i < N` the following assignment takes place:
+// `*(result + N - 1 - i) = *(begin(range) + i)`.
+//
+// Returns: `result + N`.
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.reverse#:~:text=ranges::reverse_copy(R
+template <typename Range,
+          typename OutputIterator,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto reverse_copy(Range&& range, OutputIterator result) {
+  return ranges::reverse_copy(std::ranges::begin(range),
+                              std::ranges::end(range), result);
+}
+
+// [alg.rotate] Rotate
+// Reference: https://wg21.link/alg.rotate
+
+// Preconditions: `[first, middle)` and `[middle, last)` are valid ranges.
+//
+// Effects: For each non-negative integer `i < (last - first)`, places the
+// element from the position `first + i` into position
+// `first + (i + (last - middle)) % (last - first)`.
+//
+// Returns: `first + (last - middle)`.
+//
+// Complexity: At most `last - first` swaps.
+//
+// Reference: https://wg21.link/alg.rotate#:~:text=ranges::rotate(I
+template <typename ForwardIterator,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto rotate(ForwardIterator first,
+                      ForwardIterator middle,
+                      ForwardIterator last) {
+  return std::rotate(first, middle, last);
+}
+
+// Preconditions: `[begin(range), middle)` and `[middle, end(range))` are valid
+// ranges.
+//
+// Effects: For each non-negative integer `i < size(range)`, places the element
+// from the position `begin(range) + i` into position
+// `begin(range) + (i + (end(range) - middle)) % size(range)`.
+//
+// Returns: `begin(range) + (end(range) - middle)`.
+//
+// Complexity: At most `size(range)` swaps.
+//
+// Reference: https://wg21.link/alg.rotate#:~:text=ranges::rotate(R
+template <typename Range, typename = internal::range_category_t<Range>>
+constexpr auto rotate(Range&& range, iterator_t<Range> middle) {
+  return ranges::rotate(std::ranges::begin(range), middle,
+                        std::ranges::end(range));
+}
+
+// Let `N` be `last - first`.
+//
+// Preconditions: `[first, middle)` and `[middle, last)` are valid ranges. The
+// ranges `[first, last)` and `[result, result + N)` do not overlap.
+//
+// Effects: Copies the range `[first, last)` to the range `[result, result + N)`
+// such that for each non-negative integer `i < N` the following assignment
+// takes place: `*(result + i) = *(first + (i + (middle - first)) % N)`.
+//
+// Returns: `result + N`.
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.rotate#:~:text=ranges::rotate_copy(I
+template <typename ForwardIterator,
+          typename OutputIterator,
+          typename = internal::iterator_category_t<ForwardIterator>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto rotate_copy(ForwardIterator first,
+                           ForwardIterator middle,
+                           ForwardIterator last,
+                           OutputIterator result) {
+  return std::rotate_copy(first, middle, last, result);
+}
+
+// Let `N` be `size(range)`.
+//
+// Preconditions: `[begin(range), middle)` and `[middle, end(range))` are valid
+// ranges. The ranges `range` and `[result, result + N)` do not overlap.
+//
+// Effects: Copies `range` to the range `[result, result + N)` such that for
+// each non-negative integer `i < N` the following assignment takes place:
+// `*(result + i) = *(begin(range) + (i + (middle - begin(range))) % N)`.
+//
+// Returns: `result + N`.
+//
+// Complexity: Exactly `N` assignments.
+//
+// Reference: https://wg21.link/alg.rotate#:~:text=ranges::rotate_copy(R
+template <typename Range,
+          typename OutputIterator,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator>>
+constexpr auto rotate_copy(Range&& range,
+                           iterator_t<Range> middle,
+                           OutputIterator result) {
+  return ranges::rotate_copy(std::ranges::begin(range), middle,
+                             std::ranges::end(range), result);
+}
+
+// [alg.random.sample] Sample
+// Reference: https://wg21.link/alg.random.sample
+
+// Currently not implemented due to lack of std::sample in C++14.
+// TODO(crbug.com/40126606): Consider implementing a hand-rolled version.
+
+// [alg.random.shuffle] Shuffle
+// Reference: https://wg21.link/alg.random.shuffle
+
+// Preconditions: The type `std::remove_reference_t<UniformRandomBitGenerator>`
+// meets the uniform random bit generator requirements.
+//
+// Effects: Permutes the elements in the range `[first, last)` such that each
+// possible permutation of those elements has equal probability of appearance.
+//
+// Returns: `last`.
+//
+// Complexity: Exactly `(last - first) - 1` swaps.
+//
+// Remarks: To the extent that the implementation of this function makes use of
+// random numbers, the object referenced by g shall serve as the
+// implementation's source of randomness.
+//
+// Reference: https://wg21.link/alg.random.shuffle#:~:text=ranges::shuffle(I
+template <typename RandomAccessIterator,
+          typename UniformRandomBitGenerator,
+          typename = internal::iterator_category_t<RandomAccessIterator>>
+constexpr auto shuffle(RandomAccessIterator first,
+                       RandomAccessIterator last,
+                       UniformRandomBitGenerator&& g) {
+  std::shuffle(first, last, std::forward<UniformRandomBitGenerator>(g));
+  return last;
+}
+
+// Preconditions: The type `std::remove_reference_t<UniformRandomBitGenerator>`
+// meets the uniform random bit generator requirements.
+//
+// Effects: Permutes the elements in `range` such that each possible permutation
+// of those elements has equal probability of appearance.
+//
+// Returns: `end(range)`.
+//
+// Complexity: Exactly `size(range) - 1` swaps.
+//
+// Remarks: To the extent that the implementation of this function makes use of
+// random numbers, the object referenced by g shall serve as the
+// implementation's source of randomness.
+//
+// Reference: https://wg21.link/alg.random.shuffle#:~:text=ranges::shuffle(R
+template <typename Range,
+          typename UniformRandomBitGenerator,
+          typename = internal::range_category_t<Range>>
+constexpr auto shuffle(Range&& range, UniformRandomBitGenerator&& g) {
+  return ranges::shuffle(std::ranges::begin(range), std::ranges::end(range),
+                         std::forward<UniformRandomBitGenerator>(g));
+}
+
+// [alg.nonmodifying] Sorting and related operations
+// Reference: https://wg21.link/alg.sorting
+
+// [alg.sort] Sorting
+// Reference: https://wg21.link/alg.sort
+
+// [sort] sort
+// Reference: https://wg21.link/sort
+
+// Effects: Sorts the elements in the range `[first, last)` with respect to
+// `comp` and `proj`.
+//
+// Returns: `last`.
+//
+// Complexity: Let `N` be `last - first`. `O(N log N)` comparisons and
+// projections.
+//
+// Reference: https://wg21.link/sort#:~:text=ranges::sort(I
+template <typename RandomAccessIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<RandomAccessIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<RandomAccessIterator, Proj>,
+              std::projected<RandomAccessIterator, Proj>>>
+constexpr auto sort(RandomAccessIterator first,
+                    RandomAccessIterator last,
+                    Comp comp = {},
+                    Proj proj = {}) {
+  std::sort(first, last, internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return last;
+}
+
+// Effects: Sorts the elements in `range` with respect to `comp` and `proj`.
+//
+// Returns: `end(range)`.
+//
+// Complexity: Let `N` be `size(range)`. `O(N log N)` comparisons and
+// projections.
+//
+// Reference: https://wg21.link/sort#:~:text=ranges::sort(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto sort(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::sort(std::ranges::begin(range), std::ranges::end(range),
+                      std::move(comp), std::move(proj));
+}
+
+// [stable.sort] stable_sort
+// Reference: https://wg21.link/stable.sort
+
+// Effects: Sorts the elements in the range `[first, last)` with respect to
+// `comp` and `proj`.
+//
+// Returns: `last`.
+//
+// Complexity: Let `N` be `last - first`. If enough extra memory is available,
+// `N log (N)` comparisons. Otherwise, at most `N log^2 (N)` comparisons. In
+// either case, twice as many projections as the number of comparisons.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/stable.sort#:~:text=ranges::stable_sort(I
+template <typename RandomAccessIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<RandomAccessIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<RandomAccessIterator, Proj>,
+              std::projected<RandomAccessIterator, Proj>>>
+constexpr auto stable_sort(RandomAccessIterator first,
+                           RandomAccessIterator last,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  std::stable_sort(first, last,
+                   internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return last;
+}
+
+// Effects: Sorts the elements in `range` with respect to `comp` and `proj`.
+//
+// Returns: `end(rang)`.
+//
+// Complexity: Let `N` be `size(range)`. If enough extra memory is available,
+// `N log (N)` comparisons. Otherwise, at most `N log^2 (N)` comparisons. In
+// either case, twice as many projections as the number of comparisons.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/stable.sort#:~:text=ranges::stable_sort(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto stable_sort(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::stable_sort(std::ranges::begin(range), std::ranges::end(range),
+                             std::move(comp), std::move(proj));
+}
+
+// [partial.sort] partial_sort
+// Reference: https://wg21.link/partial.sort
+
+// Preconditions: `[first, middle)` and `[middle, last)` are valid ranges.
+//
+// Effects: Places the first `middle - first` elements from the range
+// `[first, last)` as sorted with respect to `comp` and `proj` into the range
+// `[first, middle)`. The rest of the elements in the range `[middle, last)` are
+// placed in an unspecified order.
+//
+// Returns: `last`.
+//
+// Complexity: Approximately `(last - first) * log(middle - first)` comparisons,
+// and twice as many projections.
+//
+// Reference: https://wg21.link/partial.sort#:~:text=ranges::partial_sort(I
+template <typename RandomAccessIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<RandomAccessIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<RandomAccessIterator, Proj>,
+              std::projected<RandomAccessIterator, Proj>>>
+constexpr auto partial_sort(RandomAccessIterator first,
+                            RandomAccessIterator middle,
+                            RandomAccessIterator last,
+                            Comp comp = {},
+                            Proj proj = {}) {
+  std::partial_sort(first, middle, last,
+                    internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return last;
+}
+
+// Preconditions: `[begin(range), middle)` and `[middle, end(range))` are valid
+// ranges.
+//
+// Effects: Places the first `middle - begin(range)` elements from `range` as
+// sorted with respect to `comp` and `proj` into the range
+// `[begin(range), middle)`. The rest of the elements in the range
+// `[middle, end(range))` are placed in an unspecified order.
+//
+// Returns: `end(range)`.
+//
+// Complexity: Approximately `size(range) * log(middle - begin(range))`
+// comparisons, and twice as many projections.
+//
+// Reference: https://wg21.link/partial.sort#:~:text=ranges::partial_sort(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto partial_sort(Range&& range,
+                            iterator_t<Range> middle,
+                            Comp comp = {},
+                            Proj proj = {}) {
+  return ranges::partial_sort(std::ranges::begin(range), middle,
+                              std::ranges::end(range), std::move(comp),
+                              std::move(proj));
+}
+
+// [partial.sort.copy] partial_sort_copy
+// Reference: https://wg21.link/partial.sort.copy
+
+// Let `N` be `min(last - first, result_last - result_first)`.
+//
+// Preconditions: For iterators `a1` and `b1` in `[first, last)`, and iterators
+// `x2` and `y2` in `[result_first, result_last)`, after evaluating the
+// assignment `*y2 = *b1`, let `E` be the value of `bool(invoke(comp,
+// invoke(proj1, *a1), invoke(proj2, *y2)))`. Then, after evaluating the
+// assignment `*x2 = *a1`, `E` is equal to `bool(invoke(comp, invoke(proj2,
+// *x2), invoke(proj2, *y2)))`.
+//
+// Effects: Places the first `N` elements as sorted with respect to `comp` and
+// `proj2` into the range `[result_first, result_first + N)`.
+//
+// Returns: `result_first + N`.
+//
+// Complexity: Approximately `(last - first) * log N` comparisons, and twice as
+// many projections.
+//
+// Reference:
+// https://wg21.link/partial.sort.copy#:~:text=ranges::partial_sort_copy(I1
+template <
+    typename InputIterator,
+    typename RandomAccessIterator,
+    typename Comp = ranges::less,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<InputIterator>,
+    typename = internal::iterator_category_t<RandomAccessIterator>,
+    typename =
+        std::indirect_result_t<Comp&,
+                               std::projected<InputIterator, Proj1>,
+                               std::projected<RandomAccessIterator, Proj2>>,
+    typename =
+        std::indirect_result_t<Comp&,
+                               std::projected<RandomAccessIterator, Proj2>,
+                               std::projected<InputIterator, Proj1>>>
+constexpr auto partial_sort_copy(InputIterator first,
+                                 InputIterator last,
+                                 RandomAccessIterator result_first,
+                                 RandomAccessIterator result_last,
+                                 Comp comp = {},
+                                 Proj1 proj1 = {},
+                                 Proj2 proj2 = {}) {
+  // Needs to opt-in to all permutations, since std::partial_sort_copy expects
+  // comp(proj2(lhs), proj1(rhs)) to compile.
+  return std::partial_sort_copy(
+      first, last, result_first, result_last,
+      internal::PermutedProjectedBinaryPredicate(comp, proj1, proj2));
+}
+
+// Let `N` be `min(size(range), size(result_range))`.
+//
+// Preconditions: For iterators `a1` and `b1` in `range`, and iterators
+// `x2` and `y2` in `result_range`, after evaluating the assignment
+// `*y2 = *b1`, let `E` be the value of
+// `bool(invoke(comp, invoke(proj1, *a1), invoke(proj2, *y2)))`. Then, after
+// evaluating the assignment `*x2 = *a1`, `E` is equal to
+// `bool(invoke(comp, invoke(proj2, *x2), invoke(proj2, *y2)))`.
+//
+// Effects: Places the first `N` elements as sorted with respect to `comp` and
+// `proj2` into the range `[begin(result_range), begin(result_range) + N)`.
+//
+// Returns: `begin(result_range) + N`.
+//
+// Complexity: Approximately `size(range) * log N` comparisons, and twice as
+// many projections.
+//
+// Reference:
+// https://wg21.link/partial.sort.copy#:~:text=ranges::partial_sort_copy(R1
+template <typename Range1,
+          typename Range2,
+          typename Comp = ranges::less,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range2>, Proj2>,
+                                     std::projected<iterator_t<Range1>, Proj1>>>
+constexpr auto partial_sort_copy(Range1&& range,
+                                 Range2&& result_range,
+                                 Comp comp = {},
+                                 Proj1 proj1 = {},
+                                 Proj2 proj2 = {}) {
+  return ranges::partial_sort_copy(
+      std::ranges::begin(range), std::ranges::end(range),
+      std::ranges::begin(result_range), std::ranges::end(result_range),
+      std::move(comp), std::move(proj1), std::move(proj2));
+}
+
+// [is.sorted] is_sorted
+// Reference: https://wg21.link/is.sorted
+
+// Returns: The last iterator `i` in `[first, last]` for which the range
+// `[first, i)` is sorted with respect to `comp` and `proj`.
+//
+// Complexity: Linear.
+//
+// Reference: https://wg21.link/is.sorted#:~:text=ranges::is_sorted_until(I
+template <
+    typename ForwardIterator,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<ForwardIterator, Proj>,
+                                      std::projected<ForwardIterator, Proj>>>
+constexpr auto is_sorted_until(ForwardIterator first,
+                               ForwardIterator last,
+                               Comp comp = {},
+                               Proj proj = {}) {
+  // Implementation inspired by cppreference.com:
+  // https://en.cppreference.com/w/cpp/algorithm/is_sorted_until
+  //
+  // A reimplementation is required, because std::is_sorted_until is not
+  // constexpr prior to C++20. Once we have C++20, we should switch to standard
+  // library implementation.
+  if (first == last) {
+    return last;
+  }
+
+  for (ForwardIterator next = first; ++next != last; ++first) {
+    if (std::invoke(comp, std::invoke(proj, *next),
+                    std::invoke(proj, *first))) {
+      return next;
+    }
+  }
+
+  return last;
+}
+
+// Returns: The last iterator `i` in `[begin(range), end(range)]` for which the
+// range `[begin(range), i)` is sorted with respect to `comp` and `proj`.
+//
+// Complexity: Linear.
+//
+// Reference: https://wg21.link/is.sorted#:~:text=ranges::is_sorted_until(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto is_sorted_until(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::is_sorted_until(std::ranges::begin(range),
+                                 std::ranges::end(range), std::move(comp),
+                                 std::move(proj));
+}
+
+// Returns: Whether the range `[first, last)` is sorted with respect to `comp`
+// and `proj`.
+//
+// Complexity: Linear.
+//
+// Reference: https://wg21.link/is.sorted#:~:text=ranges::is_sorted(I
+template <
+    typename ForwardIterator,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<ForwardIterator, Proj>,
+                                      std::projected<ForwardIterator, Proj>>>
+constexpr auto is_sorted(ForwardIterator first,
+                         ForwardIterator last,
+                         Comp comp = {},
+                         Proj proj = {}) {
+  return ranges::is_sorted_until(first, last, std::move(comp),
+                                 std::move(proj)) == last;
+}
+
+// Returns: Whether `range` is sorted with respect to `comp` and `proj`.
+//
+// Complexity: Linear.
+//
+// Reference: https://wg21.link/is.sorted#:~:text=ranges::is_sorted(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto is_sorted(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::is_sorted(std::ranges::begin(range), std::ranges::end(range),
+                           std::move(comp), std::move(proj));
+}
+
+// [alg.nth.element] Nth element
+// Reference: https://wg21.link/alg.nth.element
+
+// Preconditions: `[first, nth)` and `[nth, last)` are valid ranges.
+//
+// Effects: After `nth_element` the element in the position pointed to by `nth`
+// is the element that would be in that position if the whole range were sorted
+// with respect to `comp` and `proj`, unless `nth == last`. Also for every
+// iterator `i` in the range `[first, nth)` and every iterator `j` in the range
+// `[nth, last)` it holds that:
+// `bool(invoke(comp, invoke(proj, *j), invoke(proj, *i)))` is false.
+//
+// Returns: `last`.
+//
+// Complexity: Linear on average.
+//
+// Reference: https://wg21.link/alg.nth.element#:~:text=ranges::nth_element(I
+template <typename RandomAccessIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<RandomAccessIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<RandomAccessIterator, Proj>,
+              std::projected<RandomAccessIterator, Proj>>>
+constexpr auto nth_element(RandomAccessIterator first,
+                           RandomAccessIterator nth,
+                           RandomAccessIterator last,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  std::nth_element(first, nth, last,
+                   internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return last;
+}
+
+// Preconditions: `[begin(range), nth)` and `[nth, end(range))` are valid
+// ranges.
+//
+// Effects: After `nth_element` the element in the position pointed to by `nth`
+// is the element that would be in that position if the whole range were sorted
+// with respect to `comp` and `proj`, unless `nth == end(range)`. Also for every
+// iterator `i` in the range `[begin(range), nth)` and every iterator `j` in the
+// range `[nth, end(range))` it holds that:
+// `bool(invoke(comp, invoke(proj, *j), invoke(proj, *i)))` is false.
+//
+// Returns: `end(range)`.
+//
+// Complexity: Linear on average.
+//
+// Reference: https://wg21.link/alg.nth.element#:~:text=ranges::nth_element(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto nth_element(Range&& range,
+                           iterator_t<Range> nth,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  return ranges::nth_element(std::ranges::begin(range), nth,
+                             std::ranges::end(range), std::move(comp),
+                             std::move(proj));
+}
+
+// [alg.binary.search] Binary search
+// Reference: https://wg21.link/alg.binary.search
+
+// [lower.bound] lower_bound
+// Reference: https://wg21.link/lower.bound
+
+// Preconditions: The elements `e` of `[first, last)` are partitioned with
+// respect to the expression `bool(invoke(comp, invoke(proj, e), value))`.
+//
+// Returns: The furthermost iterator `i` in the range `[first, last]` such that
+// for every iterator `j` in the range `[first, i)`,
+// `bool(invoke(comp, invoke(proj, *j), value))` is true.
+//
+// Complexity: At most `log_2(last - first) + O(1)` comparisons and projections.
+//
+// Reference: https://wg21.link/lower.bound#:~:text=ranges::lower_bound(I
+template <typename ForwardIterator,
+          typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto lower_bound(ForwardIterator first,
+                           ForwardIterator last,
+                           const T& value,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  // The second arg is guaranteed to be `value`, so we'll simply apply the
+  // std::identity projection.
+  std::identity value_proj;
+  return std::lower_bound(
+      first, last, value,
+      internal::ProjectedBinaryPredicate(comp, proj, value_proj));
+}
+
+// Preconditions: The elements `e` of `range` are partitioned with respect to
+// the expression `bool(invoke(comp, invoke(proj, e), value))`.
+//
+// Returns: The furthermost iterator `i` in the range
+// `[begin(range), end(range)]` such that for every iterator `j` in the range
+// `[begin(range), i)`, `bool(invoke(comp, invoke(proj, *j), value))` is true.
+//
+// Complexity: At most `log_2(size(range)) + O(1)` comparisons and projections.
+//
+// Reference: https://wg21.link/lower.bound#:~:text=ranges::lower_bound(R
+template <typename Range,
+          typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto lower_bound(Range&& range,
+                           const T& value,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  return ranges::lower_bound(std::ranges::begin(range), std::ranges::end(range),
+                             value, std::move(comp), std::move(proj));
+}
+
+// [upper.bound] upper_bound
+// Reference: https://wg21.link/upper.bound
+
+// Preconditions: The elements `e` of `[first, last)` are partitioned with
+// respect to the expression `!bool(invoke(comp, value, invoke(proj, e)))`.
+//
+// Returns: The furthermost iterator `i` in the range `[first, last]` such that
+// for every iterator `j` in the range `[first, i)`,
+// `!bool(invoke(comp, value, invoke(proj, *j)))` is true.
+//
+// Complexity: At most `log_2(last - first) + O(1)` comparisons and projections.
+//
+// Reference: https://wg21.link/upper.bound#:~:text=ranges::upper_bound(I
+template <typename ForwardIterator,
+          typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto upper_bound(ForwardIterator first,
+                           ForwardIterator last,
+                           const T& value,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  // The first arg is guaranteed to be `value`, so we'll simply apply the
+  // std::identity projection.
+  std::identity value_proj;
+  return std::upper_bound(
+      first, last, value,
+      internal::ProjectedBinaryPredicate(comp, value_proj, proj));
+}
+
+// Preconditions: The elements `e` of `range` are partitioned with
+// respect to the expression `!bool(invoke(comp, value, invoke(proj, e)))`.
+//
+// Returns: The furthermost iterator `i` in the range
+// `[begin(range), end(range)]` such that for every iterator `j` in the range
+// `[begin(range), i)`, `!bool(invoke(comp, value, invoke(proj, *j)))` is true.
+//
+// Complexity: At most `log_2(size(range)) + O(1)` comparisons and projections.
+//
+// Reference: https://wg21.link/upper.bound#:~:text=ranges::upper_bound(R
+template <typename Range,
+          typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto upper_bound(Range&& range,
+                           const T& value,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  return ranges::upper_bound(std::ranges::begin(range), std::ranges::end(range),
+                             value, std::move(comp), std::move(proj));
+}
+
+// [equal.range] equal_range
+// Reference: https://wg21.link/equal.range
+
+// Preconditions: The elements `e` of `[first, last)` are partitioned with
+// respect to the expressions `bool(invoke(comp, invoke(proj, e), value))` and
+// `!bool(invoke(comp, value, invoke(proj, e)))`.
+//
+// Returns: `{ranges::lower_bound(first, last, value, comp, proj),
+//            ranges::upper_bound(first, last, value, comp, proj)}`.
+//
+// Complexity: At most 2  log_2(last - first) + O(1) comparisons and
+// projections.
+//
+// Reference: https://wg21.link/equal.range#:~:text=ranges::equal_range(I
+template <typename ForwardIterator,
+          typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto equal_range(ForwardIterator first,
+                           ForwardIterator last,
+                           const T& value,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  // Note: This does not dispatch to std::equal_range, as otherwise it would not
+  // be possible to prevent applying `proj` to `value`, which can result in
+  // unintended behavior.
+  return std::make_pair(ranges::lower_bound(first, last, value, comp, proj),
+                        ranges::upper_bound(first, last, value, comp, proj));
+}
+
+// Preconditions: The elements `e` of `range` are partitioned with
+// respect to the expressions `bool(invoke(comp, invoke(proj, e), value))` and
+// `!bool(invoke(comp, value, invoke(proj, e)))`.
+//
+// Returns: `{ranges::lower_bound(range, value, comp, proj),
+//            ranges::upper_bound(range, value, comp, proj)}`.
+//
+// Complexity: At most 2  log_2(size(range)) + O(1) comparisons and
+// projections.
+//
+// Reference: https://wg21.link/equal.range#:~:text=ranges::equal_range(R
+template <typename Range,
+          typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto equal_range(Range&& range,
+                           const T& value,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  return ranges::equal_range(std::ranges::begin(range), std::ranges::end(range),
+                             value, std::move(comp), std::move(proj));
+}
+
+// [binary.search] binary_search
+// Reference: https://wg21.link/binary.search
+
+// Preconditions: The elements `e` of `[first, last)` are partitioned with
+// respect to the expressions `bool(invoke(comp, invoke(proj, e), value))` and
+// `!bool(invoke(comp, value, invoke(proj, e)))`.
+//
+// Returns: `true` if and only if for some iterator `i` in the range
+// `[first, last)`, `!bool(invoke(comp, invoke(proj, *i), value)) &&
+//                   !bool(invoke(comp, value, invoke(proj, *i)))` is true.
+//
+// Complexity: At most `log_2(last - first) + O(1)` comparisons and projections.
+//
+// Reference: https://wg21.link/binary.search#:~:text=ranges::binary_search(I
+template <typename ForwardIterator,
+          typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto binary_search(ForwardIterator first,
+                             ForwardIterator last,
+                             const T& value,
+                             Comp comp = {},
+                             Proj proj = {}) {
+  first = ranges::lower_bound(first, last, value, comp, proj);
+  return first != last && !std::invoke(comp, value, std::invoke(proj, *first));
+}
+
+// Preconditions: The elements `e` of `range` are partitioned with
+// respect to the expressions `bool(invoke(comp, invoke(proj, e), value))` and
+// `!bool(invoke(comp, value, invoke(proj, e)))`.
+//
+// Returns: `true` if and only if for some iterator `i` in `range`
+// `!bool(invoke(comp, invoke(proj, *i), value)) &&
+//  !bool(invoke(comp, value, invoke(proj, *i)))` is true.
+//
+// Complexity: At most `log_2(size(range)) + O(1)` comparisons and projections.
+//
+// Reference: https://wg21.link/binary.search#:~:text=ranges::binary_search(R
+template <typename Range,
+          typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto binary_search(Range&& range,
+                             const T& value,
+                             Comp comp = {},
+                             Proj proj = {}) {
+  return ranges::binary_search(std::ranges::begin(range),
+                               std::ranges::end(range), value, std::move(comp),
+                               std::move(proj));
+}
+
+// [alg.partitions] Partitions
+// Reference: https://wg21.link/alg.partitions
+
+// Returns: `true` if and only if the elements `e` of `[first, last)` are
+// partitioned with respect to the expression
+// `bool(invoke(pred, invoke(proj, e)))`.
+//
+// Complexity: Linear. At most `last - first` applications of `pred` and `proj`.
+//
+// Reference: https://wg21.link/alg.partitions#:~:text=ranges::is_partitioned(I
+template <typename ForwardIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto is_partitioned(ForwardIterator first,
+                              ForwardIterator last,
+                              Pred pred,
+                              Proj proj = {}) {
+  return std::is_partitioned(first, last,
+                             internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// Returns: `true` if and only if the elements `e` of `range` are partitioned
+// with respect to the expression `bool(invoke(pred, invoke(proj, e)))`.
+//
+// Complexity: Linear. At most `size(range)` applications of `pred` and `proj`.
+//
+// Reference: https://wg21.link/alg.partitions#:~:text=ranges::is_partitioned(R
+template <typename Range,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto is_partitioned(Range&& range, Pred pred, Proj proj = {}) {
+  return ranges::is_partitioned(std::ranges::begin(range),
+                                std::ranges::end(range), std::move(pred),
+                                std::move(proj));
+}
+
+// Let `E(x)` be `bool(invoke(pred, invoke(proj, x)))`.
+//
+// Effects: Places all the elements `e` in `[first, last)` that satisfy `E(e)`
+// before all the elements that do not.
+//
+// Returns: Let `i` be an iterator such that `E(*j)` is `true` for every
+// iterator `j` in `[first, i)` and `false` for every iterator `j` in
+// `[i, last)`. Returns: i.
+//
+// Complexity: Let `N = last - first`:
+// Exactly `N` applications of the predicate and projection. At most `N / 2`
+// swaps if the type of `first` models `bidirectional_iterator`, and at most `N`
+// swaps otherwise.
+//
+// Reference: https://wg21.link/alg.partitions#:~:text=ranges::partition(I
+template <typename ForwardIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto partition(ForwardIterator first,
+                         ForwardIterator last,
+                         Pred pred,
+                         Proj proj = {}) {
+  return std::partition(first, last,
+                        internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// Let `E(x)` be `bool(invoke(pred, invoke(proj, x)))`.
+//
+// Effects: Places all the elements `e` in `range` that satisfy `E(e)` before
+// all the elements that do not.
+//
+// Returns: Let `i` be an iterator such that `E(*j)` is `true` for every
+// iterator `j` in `[begin(range), i)` and `false` for every iterator `j` in
+// `[i, last)`. Returns: i.
+//
+// Complexity: Let `N = size(range)`:
+// Exactly `N` applications of the predicate and projection. At most `N / 2`
+// swaps if the type of `first` models `bidirectional_iterator`, and at most `N`
+// swaps otherwise.
+//
+// Reference: https://wg21.link/alg.partitions#:~:text=ranges::partition(R
+template <typename Range,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto partition(Range&& range, Pred pred, Proj proj = {}) {
+  return ranges::partition(std::ranges::begin(range), std::ranges::end(range),
+                           std::move(pred), std::move(proj));
+}
+
+// Let `E(x)` be `bool(invoke(pred, invoke(proj, x)))`.
+//
+// Effects: Places all the elements `e` in `[first, last)` that satisfy `E(e)`
+// before all the elements that do not. The relative order of the elements in
+// both groups is preserved.
+//
+// Returns: Let `i` be an iterator such that for every iterator `j` in
+// `[first, i)`, `E(*j)` is `true`, and for every iterator `j` in the range
+// `[i, last)`, `E(*j)` is `false`. Returns: `i`.
+//
+// Complexity: Let `N = last - first`:
+// At most `N log N` swaps, but only `O(N)` swaps if there is enough extra
+// memory. Exactly `N` applications of the predicate and projection.
+//
+// Reference:
+// https://wg21.link/alg.partitions#:~:text=ranges::stable_partition(I
+template <typename BidirectionalIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<BidirectionalIterator>>
+constexpr auto stable_partition(BidirectionalIterator first,
+                                BidirectionalIterator last,
+                                Pred pred,
+                                Proj proj = {}) {
+  return std::stable_partition(first, last,
+                               internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// Let `E(x)` be `bool(invoke(pred, invoke(proj, x)))`.
+//
+// Effects: Places all the elements `e` in `range` that satisfy `E(e)` before
+// all the elements that do not. The relative order of the elements in both
+// groups is preserved.
+//
+// Returns: Let `i` be an iterator such that for every iterator `j` in
+// `[begin(range), i)`, `E(*j)` is `true`, and for every iterator `j` in the
+// range `[i, end(range))`, `E(*j)` is `false`. Returns: `i`.
+//
+// Complexity: Let `N = size(range)`:
+// At most `N log N` swaps, but only `O(N)` swaps if there is enough extra
+// memory. Exactly `N` applications of the predicate and projection.
+//
+// Reference:
+// https://wg21.link/alg.partitions#:~:text=ranges::stable_partition(R
+template <typename Range,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto stable_partition(Range&& range, Pred pred, Proj proj = {}) {
+  return ranges::stable_partition(std::ranges::begin(range),
+                                  std::ranges::end(range), std::move(pred),
+                                  std::move(proj));
+}
+
+// Let `E(x)` be `bool(invoke(pred, invoke(proj, x)))`.
+//
+// Mandates: The expression `*first` is writable to `out_true` and `out_false`.
+//
+// Preconditions: The input range and output ranges do not overlap.
+//
+// Effects: For each iterator `i` in `[first, last)`, copies `*i` to the output
+// range beginning with `out_true` if `E(*i)` is `true`, or to the output range
+// beginning with `out_false` otherwise.
+//
+// Returns: Let `o1` be the end of the output range beginning at `out_true`, and
+// `o2` the end of the output range beginning at `out_false`.
+// Returns `{o1, o2}`.
+//
+// Complexity: Exactly `last - first` applications of `pred` and `proj`.
+//
+// Reference: https://wg21.link/alg.partitions#:~:text=ranges::partition_copy(I
+template <typename InputIterator,
+          typename OutputIterator1,
+          typename OutputIterator2,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<InputIterator>,
+          typename = internal::iterator_category_t<OutputIterator1>,
+          typename = internal::iterator_category_t<OutputIterator2>>
+constexpr auto partition_copy(InputIterator first,
+                              InputIterator last,
+                              OutputIterator1 out_true,
+                              OutputIterator2 out_false,
+                              Pred pred,
+                              Proj proj = {}) {
+  return std::partition_copy(first, last, out_true, out_false,
+                             internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// Let `E(x)` be `bool(invoke(pred, invoke(proj, x)))`.
+//
+// Mandates: The expression `*begin(range)` is writable to `out_true` and
+// `out_false`.
+//
+// Preconditions: The input range and output ranges do not overlap.
+//
+// Effects: For each iterator `i` in `range`, copies `*i` to the output range
+// beginning with `out_true` if `E(*i)` is `true`, or to the output range
+// beginning with `out_false` otherwise.
+//
+// Returns: Let `o1` be the end of the output range beginning at `out_true`, and
+// `o2` the end of the output range beginning at `out_false`.
+// Returns `{o1, o2}`.
+//
+// Complexity: Exactly `size(range)` applications of `pred` and `proj`.
+//
+// Reference: https://wg21.link/alg.partitions#:~:text=ranges::partition_copy(R
+template <typename Range,
+          typename OutputIterator1,
+          typename OutputIterator2,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>,
+          typename = internal::iterator_category_t<OutputIterator1>,
+          typename = internal::iterator_category_t<OutputIterator2>>
+constexpr auto partition_copy(Range&& range,
+                              OutputIterator1 out_true,
+                              OutputIterator2 out_false,
+                              Pred pred,
+                              Proj proj = {}) {
+  return ranges::partition_copy(std::ranges::begin(range),
+                                std::ranges::end(range), out_true, out_false,
+                                std::move(pred), std::move(proj));
+}
+
+// let `E(x)` be `bool(invoke(pred, invoke(proj, x)))`.
+//
+// Preconditions: The elements `e` of `[first, last)` are partitioned with
+// respect to `E(e)`.
+//
+// Returns: An iterator `mid` such that `E(*i)` is `true` for all iterators `i`
+// in `[first, mid)`, and `false` for all iterators `i` in `[mid, last)`.
+//
+// Complexity: `O(log(last - first))` applications of `pred` and `proj`.
+//
+// Reference: https://wg21.link/alg.partitions#:~:text=ranges::partition_point(I
+template <typename ForwardIterator,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<ForwardIterator>>
+constexpr auto partition_point(ForwardIterator first,
+                               ForwardIterator last,
+                               Pred pred,
+                               Proj proj = {}) {
+  return std::partition_point(first, last,
+                              internal::ProjectedUnaryPredicate(pred, proj));
+}
+
+// let `E(x)` be `bool(invoke(pred, invoke(proj, x)))`.
+//
+// Preconditions: The elements `e` of `range` are partitioned with respect to
+// `E(e)`.
+//
+// Returns: An iterator `mid` such that `E(*i)` is `true` for all iterators `i`
+// in `[begin(range), mid)`, and `false` for all iterators `i` in
+// `[mid, end(range))`.
+//
+// Complexity: `O(log(size(range)))` applications of `pred` and `proj`.
+//
+// Reference: https://wg21.link/alg.partitions#:~:text=ranges::partition_point(R
+template <typename Range,
+          typename Pred,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto partition_point(Range&& range, Pred pred, Proj proj = {}) {
+  return ranges::partition_point(std::ranges::begin(range),
+                                 std::ranges::end(range), std::move(pred),
+                                 std::move(proj));
+}
+
+// [alg.merge] Merge
+// Reference: https://wg21.link/alg.merge
+
+// Let `N` be `(last1 - first1) + (last2 - first2)`.
+//
+// Preconditions: The ranges `[first1, last1)` and `[first2, last2)` are sorted
+// with respect to `comp` and `proj1` or `proj2`, respectively. The resulting
+// range does not overlap with either of the original ranges.
+//
+// Effects: Copies all the elements of the two ranges `[first1, last1)` and
+// `[first2, last2)` into the range `[result, result_last)`, where `result_last`
+// is `result + N`. If an element `a` precedes `b` in an input range, `a` is
+// copied into the output range before `b`. If `e1` is an element of
+// `[first1, last1)` and `e2` of `[first2, last2)`, `e2` is copied into the
+// output range before `e1` if and only if
+// `bool(invoke(comp, invoke(proj2, e2), invoke(proj1, e1)))` is `true`.
+//
+// Returns: `result_last`.
+//
+// Complexity: At most `N - 1` comparisons and applications of each projection.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/alg.merge#:~:text=ranges::merge(I1
+template <
+    typename InputIterator1,
+    typename InputIterator2,
+    typename OutputIterator,
+    typename Comp = ranges::less,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<InputIterator1>,
+    typename = internal::iterator_category_t<InputIterator2>,
+    typename = internal::iterator_category_t<OutputIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator1, Proj1>,
+                                      std::projected<InputIterator2, Proj2>>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator2, Proj2>,
+                                      std::projected<InputIterator1, Proj1>>>
+constexpr auto merge(InputIterator1 first1,
+                     InputIterator1 last1,
+                     InputIterator2 first2,
+                     InputIterator2 last2,
+                     OutputIterator result,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}) {
+  // Needs to opt-in to all permutations, since std::merge expects
+  // comp(proj2(lhs), proj1(rhs)) to compile.
+  return std::merge(
+      first1, last1, first2, last2, result,
+      internal::PermutedProjectedBinaryPredicate(comp, proj1, proj2));
+}
+
+// Let `N` be `size(range1) + size(range2)`.
+//
+// Preconditions: The ranges `range1` and `range2` are sorted with respect to
+// `comp` and `proj1` or `proj2`, respectively. The resulting range does not
+// overlap with either of the original ranges.
+//
+// Effects: Copies all the elements of the two ranges `range1` and `range2` into
+// the range `[result, result_last)`, where `result_last` is `result + N`. If an
+// element `a` precedes `b` in an input range, `a` is copied into the output
+// range before `b`. If `e1` is an element of `range1` and `e2` of `range2`,
+// `e2` is copied into the output range before `e1` if and only if
+// `bool(invoke(comp, invoke(proj2, e2), invoke(proj1, e1)))` is `true`.
+//
+// Returns: `result_last`.
+//
+// Complexity: At most `N - 1` comparisons and applications of each projection.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/alg.merge#:~:text=ranges::merge(R1
+template <typename Range1,
+          typename Range2,
+          typename OutputIterator,
+          typename Comp = ranges::less,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename = internal::iterator_category_t<OutputIterator>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range2>, Proj2>,
+                                     std::projected<iterator_t<Range1>, Proj1>>>
+constexpr auto merge(Range1&& range1,
+                     Range2&& range2,
+                     OutputIterator result,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}) {
+  return ranges::merge(std::ranges::begin(range1), std::ranges::end(range1),
+                       std::ranges::begin(range2), std::ranges::end(range2),
+                       result, std::move(comp), std::move(proj1),
+                       std::move(proj2));
+}
+
+// Preconditions: `[first, middle)` and `[middle, last)` are valid ranges sorted
+// with respect to `comp` and `proj`.
+//
+// Effects: Merges two sorted consecutive ranges `[first, middle)` and
+// `[middle, last)`, putting the result of the merge into the range
+// `[first, last)`. The resulting range is sorted with respect to `comp` and
+// `proj`.
+//
+// Returns: `last`.
+//
+// Complexity: Let `N = last - first`: If enough additional memory is available,
+// exactly `N - 1` comparisons. Otherwise, `O(N log N)` comparisons. In either
+// case, twice as many projections as comparisons.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/alg.merge#:~:text=ranges::inplace_merge(I
+template <typename BidirectionalIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<BidirectionalIterator>>
+constexpr auto inplace_merge(BidirectionalIterator first,
+                             BidirectionalIterator middle,
+                             BidirectionalIterator last,
+                             Comp comp = {},
+                             Proj proj = {}) {
+  std::inplace_merge(first, middle, last,
+                     internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return last;
+}
+
+// Preconditions: `[begin(range), middle)` and `[middle, end(range))` are valid
+// ranges sorted with respect to `comp` and `proj`.
+//
+// Effects: Merges two sorted consecutive ranges `[begin(range), middle)` and
+// `[middle, end(range))`, putting the result of the merge into `range`. The
+// resulting range is sorted with respect to `comp` and `proj`.
+//
+// Returns: `end(range)`.
+//
+// Complexity: Let `N = size(range)`: If enough additional memory is available,
+// exactly `N - 1` comparisons. Otherwise, `O(N log N)` comparisons. In either
+// case, twice as many projections as comparisons.
+//
+// Remarks: Stable.
+//
+// Reference: https://wg21.link/alg.merge#:~:text=ranges::inplace_merge(R
+template <typename Range,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto inplace_merge(Range&& range,
+                             iterator_t<Range> middle,
+                             Comp comp = {},
+                             Proj proj = {}) {
+  return ranges::inplace_merge(std::ranges::begin(range), middle,
+                               std::ranges::end(range), std::move(comp),
+                               std::move(proj));
+}
+
+// [alg.set.operations] Set operations on sorted structures
+// Reference: https://wg21.link/alg.set.operations
+
+// [includes] includes
+// Reference: https://wg21.link/includes
+
+// Preconditions: The ranges `[first1, last1)` and `[first2, last2)` are sorted
+// with respect to `comp` and `proj1` or `proj2`, respectively.
+//
+// Returns: `true` if and only if `[first2, last2)` is a subsequence of
+// `[first1, last1)`.
+//
+// Complexity: At most `2 * ((last1 - first1) + (last2 - first2)) - 1`
+// comparisons and applications of each projection.
+//
+// Reference: https://wg21.link/includes#:~:text=ranges::includes(I1
+template <
+    typename InputIterator1,
+    typename InputIterator2,
+    typename Comp = ranges::less,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<InputIterator1>,
+    typename = internal::iterator_category_t<InputIterator2>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator1, Proj1>,
+                                      std::projected<InputIterator2, Proj2>>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator2, Proj2>,
+                                      std::projected<InputIterator1, Proj1>>>
+constexpr auto includes(InputIterator1 first1,
+                        InputIterator1 last1,
+                        InputIterator2 first2,
+                        InputIterator2 last2,
+                        Comp comp = {},
+                        Proj1 proj1 = {},
+                        Proj2 proj2 = {}) {
+  DCHECK(ranges::is_sorted(first1, last1, comp, proj1));
+  DCHECK(ranges::is_sorted(first2, last2, comp, proj2));
+  // Needs to opt-in to all permutations, since std::includes expects
+  // comp(proj1(lhs), proj2(rhs)) and comp(proj2(lhs), proj1(rhs)) to compile.
+  return std::includes(
+      first1, last1, first2, last2,
+      internal::PermutedProjectedBinaryPredicate(comp, proj1, proj2));
+}
+
+// Preconditions: The ranges `range1` and `range2` are sorted with respect to
+// `comp` and `proj1` or `proj2`, respectively.
+//
+// Returns: `true` if and only if `range2` is a subsequence of `range1`.
+//
+// Complexity: At most `2 * (size(range1) + size(range2)) - 1` comparisons and
+// applications of each projection.
+//
+// Reference: https://wg21.link/includes#:~:text=ranges::includes(R1
+template <typename Range1,
+          typename Range2,
+          typename Comp = ranges::less,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range2>, Proj2>,
+                                     std::projected<iterator_t<Range1>, Proj1>>>
+constexpr auto includes(Range1&& range1,
+                        Range2&& range2,
+                        Comp comp = {},
+                        Proj1 proj1 = {},
+                        Proj2 proj2 = {}) {
+  return ranges::includes(std::ranges::begin(range1), std::ranges::end(range1),
+                          std::ranges::begin(range2), std::ranges::end(range2),
+                          std::move(comp), std::move(proj1), std::move(proj2));
+}
+
+// [set.union] set_union
+// Reference: https://wg21.link/set.union
+
+// Preconditions: The ranges `[first1, last1)` and `[first2, last2)` are sorted
+// with respect to `comp` and `proj1` or `proj2`, respectively. The resulting
+// range does not overlap with either of the original ranges.
+//
+// Effects: Constructs a sorted union of the elements from the two ranges; that
+// is, the set of elements that are present in one or both of the ranges.
+//
+// Returns: The end of the constructed range.
+//
+// Complexity: At most `2 * ((last1 - first1) + (last2 - first2)) - 1`
+// comparisons and applications of each projection.
+//
+// Remarks: Stable. If `[first1, last1)` contains `m` elements that are
+// equivalent to each other and `[first2, last2)` contains `n` elements that are
+// equivalent to them, then all `m` elements from the first range are copied to
+// the output range, in order, and then the final `max(n - m , 0)` elements from
+// the second range are copied to the output range, in order.
+//
+// Reference: https://wg21.link/set.union#:~:text=ranges::set_union(I1
+template <
+    typename InputIterator1,
+    typename InputIterator2,
+    typename OutputIterator,
+    typename Comp = ranges::less,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<InputIterator1>,
+    typename = internal::iterator_category_t<InputIterator2>,
+    typename = internal::iterator_category_t<OutputIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator1, Proj1>,
+                                      std::projected<InputIterator2, Proj2>>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator2, Proj2>,
+                                      std::projected<InputIterator1, Proj1>>>
+constexpr auto set_union(InputIterator1 first1,
+                         InputIterator1 last1,
+                         InputIterator2 first2,
+                         InputIterator2 last2,
+                         OutputIterator result,
+                         Comp comp = {},
+                         Proj1 proj1 = {},
+                         Proj2 proj2 = {}) {
+  // Needs to opt-in to all permutations, since std::set_union expects
+  // comp(proj1(lhs), proj2(rhs)) and comp(proj2(lhs), proj1(rhs)) to compile.
+  return std::set_union(
+      first1, last1, first2, last2, result,
+      internal::PermutedProjectedBinaryPredicate(comp, proj1, proj2));
+}
+
+// Preconditions: The ranges `range1` and `range2` are sorted with respect to
+// `comp` and `proj1` or `proj2`, respectively. The resulting range does not
+// overlap with either of the original ranges.
+//
+// Effects: Constructs a sorted union of the elements from the two ranges; that
+// is, the set of elements that are present in one or both of the ranges.
+//
+// Returns: The end of the constructed range.
+//
+// Complexity: At most `2 * (size(range1) + size(range2)) - 1` comparisons and
+// applications of each projection.
+//
+// Remarks: Stable. If `range1` contains `m` elements that are equivalent to
+// each other and `range2` contains `n` elements that are equivalent to them,
+// then all `m` elements from the first range are copied to the output range, in
+// order, and then the final `max(n - m , 0)` elements from the second range are
+// copied to the output range, in order.
+//
+// Reference: https://wg21.link/set.union#:~:text=ranges::set_union(R1
+template <typename Range1,
+          typename Range2,
+          typename OutputIterator,
+          typename Comp = ranges::less,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename = internal::iterator_category_t<OutputIterator>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range2>, Proj2>,
+                                     std::projected<iterator_t<Range1>, Proj1>>>
+constexpr auto set_union(Range1&& range1,
+                         Range2&& range2,
+                         OutputIterator result,
+                         Comp comp = {},
+                         Proj1 proj1 = {},
+                         Proj2 proj2 = {}) {
+  return ranges::set_union(std::ranges::begin(range1), std::ranges::end(range1),
+                           std::ranges::begin(range2), std::ranges::end(range2),
+                           result, std::move(comp), std::move(proj1),
+                           std::move(proj2));
+}
+
+// [set.intersection] set_intersection
+// Reference: https://wg21.link/set.intersection
+
+// Preconditions: The ranges `[first1, last1)` and `[first2, last2)` are sorted
+// with respect to `comp` and `proj1` or `proj2`, respectively. The resulting
+// range does not overlap with either of the original ranges.
+//
+// Effects: Constructs a sorted intersection of the elements from the two
+// ranges; that is, the set of elements that are present in both of the ranges.
+//
+// Returns: The end of the constructed range.
+//
+// Complexity: At most `2 * ((last1 - first1) + (last2 - first2)) - 1`
+// comparisons and applications of each projection.
+//
+// Remarks: Stable. If `[first1, last1)` contains `m` elements that are
+// equivalent to each other and `[first2, last2)` contains `n` elements that are
+// equivalent to them, the first `min(m, n)` elements are copied from the first
+// range to the output range, in order.
+//
+// Reference:
+// https://wg21.link/set.intersection#:~:text=ranges::set_intersection(I1
+template <
+    typename InputIterator1,
+    typename InputIterator2,
+    typename OutputIterator,
+    typename Comp = ranges::less,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<InputIterator1>,
+    typename = internal::iterator_category_t<InputIterator2>,
+    typename = internal::iterator_category_t<OutputIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator1, Proj1>,
+                                      std::projected<InputIterator2, Proj2>>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator2, Proj2>,
+                                      std::projected<InputIterator1, Proj1>>>
+constexpr auto set_intersection(InputIterator1 first1,
+                                InputIterator1 last1,
+                                InputIterator2 first2,
+                                InputIterator2 last2,
+                                OutputIterator result,
+                                Comp comp = {},
+                                Proj1 proj1 = {},
+                                Proj2 proj2 = {}) {
+  // Needs to opt-in to all permutations, since std::set_intersection expects
+  // comp(proj1(lhs), proj2(rhs)) and comp(proj2(lhs), proj1(rhs)) to compile.
+  return std::set_intersection(
+      first1, last1, first2, last2, result,
+      internal::PermutedProjectedBinaryPredicate(comp, proj1, proj2));
+}
+
+// Preconditions: The ranges `range1` and `range2` are sorted with respect to
+// `comp` and `proj1` or `proj2`, respectively. The resulting range does not
+// overlap with either of the original ranges.
+//
+// Effects: Constructs a sorted intersection of the elements from the two
+// ranges; that is, the set of elements that are present in both of the ranges.
+//
+// Returns: The end of the constructed range.
+//
+// Complexity: At most `2 * (size(range1) + size(range2)) - 1` comparisons and
+// applications of each projection.
+//
+// Remarks: Stable. If `range1` contains `m` elements that are equivalent to
+// each other and `range2` contains `n` elements that are equivalent to them,
+// the first `min(m, n)` elements are copied from the first range to the output
+// range, in order.
+//
+// Reference:
+// https://wg21.link/set.intersection#:~:text=ranges::set_intersection(R1
+template <typename Range1,
+          typename Range2,
+          typename OutputIterator,
+          typename Comp = ranges::less,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename = internal::iterator_category_t<OutputIterator>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range2>, Proj2>,
+                                     std::projected<iterator_t<Range1>, Proj1>>>
+constexpr auto set_intersection(Range1&& range1,
+                                Range2&& range2,
+                                OutputIterator result,
+                                Comp comp = {},
+                                Proj1 proj1 = {},
+                                Proj2 proj2 = {}) {
+  return ranges::set_intersection(
+      std::ranges::begin(range1), std::ranges::end(range1),
+      std::ranges::begin(range2), std::ranges::end(range2), result,
+      std::move(comp), std::move(proj1), std::move(proj2));
+}
+
+// [set.difference] set_difference
+// Reference: https://wg21.link/set.difference
+
+// Preconditions: The ranges `[first1, last1)` and `[first2, last2)` are sorted
+// with respect to `comp` and `proj1` or `proj2`, respectively. The resulting
+// range does not overlap with either of the original ranges.
+//
+// Effects: Copies the elements of the range `[first1, last1)` which are not
+// present in the range `[first2, last2)` to the range beginning at `result`.
+// The elements in the constructed range are sorted.
+//
+// Returns: The end of the constructed range.
+//
+// Complexity: At most `2 * ((last1 - first1) + (last2 - first2)) - 1`
+// comparisons and applications of each projection.
+//
+// Remarks: If `[first1, last1)` contains `m` elements that are equivalent to
+// each other and `[first2, last2)` contains `n` elements that are equivalent to
+// them, the last `max(m - n, 0)` elements from `[first1, last1)` are copied to
+// the output range, in order.
+//
+// Reference:
+// https://wg21.link/set.difference#:~:text=ranges::set_difference(I1
+template <
+    typename InputIterator1,
+    typename InputIterator2,
+    typename OutputIterator,
+    typename Comp = ranges::less,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<InputIterator1>,
+    typename = internal::iterator_category_t<InputIterator2>,
+    typename = internal::iterator_category_t<OutputIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator1, Proj1>,
+                                      std::projected<InputIterator2, Proj2>>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator2, Proj2>,
+                                      std::projected<InputIterator1, Proj1>>>
+constexpr auto set_difference(InputIterator1 first1,
+                              InputIterator1 last1,
+                              InputIterator2 first2,
+                              InputIterator2 last2,
+                              OutputIterator result,
+                              Comp comp = {},
+                              Proj1 proj1 = {},
+                              Proj2 proj2 = {}) {
+  // Needs to opt-in to all permutations, since std::set_difference expects
+  // comp(proj1(lhs), proj2(rhs)) and comp(proj2(lhs), proj1(rhs)) to compile.
+  return std::set_difference(
+      first1, last1, first2, last2, result,
+      internal::PermutedProjectedBinaryPredicate(comp, proj1, proj2));
+}
+
+// Preconditions: The ranges `range1` and `range2` are sorted with respect to
+// `comp` and `proj1` or `proj2`, respectively. The resulting range does not
+// overlap with either of the original ranges.
+//
+// Effects: Copies the elements of `range1` which are not present in `range2`
+// to the range beginning at `result`. The elements in the constructed range are
+// sorted.
+//
+// Returns: The end of the constructed range.
+//
+// Complexity: At most `2 * (size(range1) + size(range2)) - 1` comparisons and
+// applications of each projection.
+//
+// Remarks: Stable. If `range1` contains `m` elements that are equivalent to
+// each other and `range2` contains `n` elements that are equivalent to them,
+// the last `max(m - n, 0)` elements from `range1` are copied to the output
+// range, in order.
+//
+// Reference:
+// https://wg21.link/set.difference#:~:text=ranges::set_difference(R1
+template <typename Range1,
+          typename Range2,
+          typename OutputIterator,
+          typename Comp = ranges::less,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename = internal::iterator_category_t<OutputIterator>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range2>, Proj2>,
+                                     std::projected<iterator_t<Range1>, Proj1>>>
+constexpr auto set_difference(Range1&& range1,
+                              Range2&& range2,
+                              OutputIterator result,
+                              Comp comp = {},
+                              Proj1 proj1 = {},
+                              Proj2 proj2 = {}) {
+  return ranges::set_difference(
+      std::ranges::begin(range1), std::ranges::end(range1),
+      std::ranges::begin(range2), std::ranges::end(range2), result,
+      std::move(comp), std::move(proj1), std::move(proj2));
+}
+
+// [set.symmetric.difference] set_symmetric_difference
+// Reference: https://wg21.link/set.symmetric.difference
+
+// Preconditions: The ranges `[first1, last1)` and `[first2, last2)` are sorted
+// with respect to `comp` and `proj1` or `proj2`, respectively. The resulting
+// range does not overlap with either of the original ranges.
+//
+// Effects: Copies the elements of the range `[first1, last1)` that are not
+// present in the range `[first2, last2)`, and the elements of the range
+// `[first2, last2)` that are not present in the range `[first1, last1)` to the
+// range beginning at `result`. The elements in the constructed range are
+// sorted.
+//
+// Returns: The end of the constructed range.
+//
+// Complexity: At most `2 * ((last1 - first1) + (last2 - first2)) - 1`
+// comparisons and applications of each projection.
+//
+// Remarks: Stable. If `[first1, last1)` contains `m` elements that are
+// equivalent to each other and `[first2, last2)` contains `n` elements that are
+// equivalent to them, then `|m - n|` of those elements shall be copied to the
+// output range: the last `m - n` of these elements from `[first1, last1)` if
+// `m > n`, and the last `n - m` of these elements from `[first2, last2)` if
+// `m < n`. In either case, the elements are copied in order.
+//
+// Reference:
+// https://wg21.link/set.symmetric.difference#:~:text=set_symmetric_difference(I1
+template <
+    typename InputIterator1,
+    typename InputIterator2,
+    typename OutputIterator,
+    typename Comp = ranges::less,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<InputIterator1>,
+    typename = internal::iterator_category_t<InputIterator2>,
+    typename = internal::iterator_category_t<OutputIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator1, Proj1>,
+                                      std::projected<InputIterator2, Proj2>>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<InputIterator2, Proj2>,
+                                      std::projected<InputIterator1, Proj1>>>
+constexpr auto set_symmetric_difference(InputIterator1 first1,
+                                        InputIterator1 last1,
+                                        InputIterator2 first2,
+                                        InputIterator2 last2,
+                                        OutputIterator result,
+                                        Comp comp = {},
+                                        Proj1 proj1 = {},
+                                        Proj2 proj2 = {}) {
+  // Needs to opt-in to all permutations, since std::set_symmetric_difference
+  // expects comp(proj1(lhs), proj2(rhs)) and comp(proj2(lhs), proj1(rhs)) to
+  // compile.
+  return std::set_symmetric_difference(
+      first1, last1, first2, last2, result,
+      internal::PermutedProjectedBinaryPredicate(comp, proj1, proj2));
+}
+
+// Preconditions: The ranges `range1` and `range2` are sorted with respect to
+// `comp` and `proj1` or `proj2`, respectively. The resulting range does not
+// overlap with either of the original ranges.
+//
+// Effects: Copies the elements of `range1` that are not present in `range2`,
+// and the elements of `range2` that are not present in `range1` to the range
+// beginning at `result`. The elements in the constructed range are sorted.
+//
+// Returns: The end of the constructed range.
+//
+// Complexity: At most `2 * (size(range1) + size(range2)) - 1` comparisons and
+// applications of each projection.
+//
+// Remarks: Stable. If `range1` contains `m` elements that are equivalent to
+// each other and `range2` contains `n` elements that are equivalent to them,
+// then `|m - n|` of those elements shall be copied to the output range: the
+// last `m - n` of these elements from `range1` if `m > n`, and the last `n - m`
+// of these elements from `range2` if `m < n`. In either case, the elements are
+// copied in order.
+//
+// Reference:
+// https://wg21.link/set.symmetric.difference#:~:text=set_symmetric_difference(R1
+template <typename Range1,
+          typename Range2,
+          typename OutputIterator,
+          typename Comp = ranges::less,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename = internal::iterator_category_t<OutputIterator>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range2>, Proj2>,
+                                     std::projected<iterator_t<Range1>, Proj1>>>
+constexpr auto set_symmetric_difference(Range1&& range1,
+                                        Range2&& range2,
+                                        OutputIterator result,
+                                        Comp comp = {},
+                                        Proj1 proj1 = {},
+                                        Proj2 proj2 = {}) {
+  return ranges::set_symmetric_difference(
+      std::ranges::begin(range1), std::ranges::end(range1),
+      std::ranges::begin(range2), std::ranges::end(range2), result,
+      std::move(comp), std::move(proj1), std::move(proj2));
+}
+
+// [alg.heap.operations] Heap operations
+// Reference: https://wg21.link/alg.heap.operations
+
+// [push.heap] push_heap
+// Reference: https://wg21.link/push.heap
+
+// Preconditions: The range `[first, last - 1)` is a valid heap with respect to
+// `comp` and `proj`.
+//
+// Effects: Places the value in the location `last - 1` into the resulting heap
+// `[first, last)`.
+//
+// Returns: `last`.
+//
+// Complexity: At most `log(last - first)` comparisons and twice as many
+// projections.
+//
+// Reference: https://wg21.link/push.heap#:~:text=ranges::push_heap(I
+template <typename RandomAccessIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<RandomAccessIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<RandomAccessIterator, Proj>,
+              std::projected<RandomAccessIterator, Proj>>>
+constexpr auto push_heap(RandomAccessIterator first,
+                         RandomAccessIterator last,
+                         Comp comp = {},
+                         Proj proj = {}) {
+  std::push_heap(first, last,
+                 internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return last;
+}
+
+// Preconditions: The range `[begin(range), end(range) - 1)` is a valid heap
+// with respect to `comp` and `proj`.
+//
+// Effects: Places the value in the location `end(range) - 1` into the resulting
+// heap `range`.
+//
+// Returns: `end(range)`.
+//
+// Complexity: At most `log(size(range))` comparisons and twice as many
+// projections.
+//
+// Reference: https://wg21.link/push.heap#:~:text=ranges::push_heap(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto push_heap(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::push_heap(std::ranges::begin(range), std::ranges::end(range),
+                           std::move(comp), std::move(proj));
+}
+
+// [pop.heap] pop_heap
+// Reference: https://wg21.link/pop.heap
+
+// Preconditions: The range `[first, last)` is a valid non-empty heap with
+// respect to `comp` and `proj`.
+//
+// Effects: Swaps the value in the location `first` with the value in the
+// location `last - 1` and makes `[first, last - 1)` into a heap with respect to
+// `comp` and `proj`.
+//
+// Returns: `last`.
+//
+// Complexity: At most `2 log(last - first)` comparisons and twice as many
+// projections.
+//
+// Reference: https://wg21.link/pop.heap#:~:text=ranges::pop_heap(I
+template <typename RandomAccessIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<RandomAccessIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<RandomAccessIterator, Proj>,
+              std::projected<RandomAccessIterator, Proj>>>
+constexpr auto pop_heap(RandomAccessIterator first,
+                        RandomAccessIterator last,
+                        Comp comp = {},
+                        Proj proj = {}) {
+  std::pop_heap(first, last,
+                internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return last;
+}
+
+// Preconditions: `range` is a valid non-empty heap with respect to `comp` and
+// `proj`.
+//
+// Effects: Swaps the value in the location `begin(range)` with the value in the
+// location `end(range) - 1` and makes `[begin(range), end(range) - 1)` into a
+// heap with respect to `comp` and `proj`.
+//
+// Returns: `end(range)`.
+//
+// Complexity: At most `2 log(size(range))` comparisons and twice as many
+// projections.
+//
+// Reference: https://wg21.link/pop.heap#:~:text=ranges::pop_heap(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto pop_heap(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::pop_heap(std::ranges::begin(range), std::ranges::end(range),
+                          std::move(comp), std::move(proj));
+}
+
+// [make.heap] make_heap
+// Reference: https://wg21.link/make.heap
+
+// Effects: Constructs a heap with respect to `comp` and `proj` out of the range
+// `[first, last)`.
+//
+// Returns: `last`.
+//
+// Complexity: At most `3 * (last - first)` comparisons and twice as many
+// projections.
+//
+// Reference: https://wg21.link/make.heap#:~:text=ranges::make_heap(I
+template <typename RandomAccessIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<RandomAccessIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<RandomAccessIterator, Proj>,
+              std::projected<RandomAccessIterator, Proj>>>
+constexpr auto make_heap(RandomAccessIterator first,
+                         RandomAccessIterator last,
+                         Comp comp = {},
+                         Proj proj = {}) {
+  std::make_heap(first, last,
+                 internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return last;
+}
+
+// Effects: Constructs a heap with respect to `comp` and `proj` out of `range`.
+//
+// Returns: `end(range)`.
+//
+// Complexity: At most `3 * size(range)` comparisons and twice as many
+// projections.
+//
+// Reference: https://wg21.link/make.heap#:~:text=ranges::make_heap(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto make_heap(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::make_heap(std::ranges::begin(range), std::ranges::end(range),
+                           std::move(comp), std::move(proj));
+}
+
+// [sort.heap] sort_heap
+// Reference: https://wg21.link/sort.heap
+
+// Preconditions: The range `[first, last)` is a valid heap with respect to
+// `comp` and `proj`.
+//
+// Effects: Sorts elements in the heap `[first, last)` with respect to `comp`
+// and `proj`.
+//
+// Returns: `last`.
+//
+// Complexity: At most `2 N log N` comparisons, where `N = last - first`, and
+// twice as many projections.
+//
+// Reference: https://wg21.link/sort.heap#:~:text=ranges::sort_heap(I
+template <typename RandomAccessIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<RandomAccessIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<RandomAccessIterator, Proj>,
+              std::projected<RandomAccessIterator, Proj>>>
+constexpr auto sort_heap(RandomAccessIterator first,
+                         RandomAccessIterator last,
+                         Comp comp = {},
+                         Proj proj = {}) {
+  std::sort_heap(first, last,
+                 internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return last;
+}
+
+// Preconditions: `range` is a valid heap with respect to `comp` and `proj`.
+//
+// Effects: Sorts elements in the heap `range` with respect to `comp` and
+// `proj`.
+//
+// Returns: `end(range)`.
+//
+// Complexity: At most `2 N log N` comparisons, where `N = size(range)`, and
+// twice as many projections.
+//
+// Reference: https://wg21.link/sort.heap#:~:text=ranges::sort_heap(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto sort_heap(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::sort_heap(std::ranges::begin(range), std::ranges::end(range),
+                           std::move(comp), std::move(proj));
+}
+
+// [is.heap] is_heap
+// Reference: https://wg21.link/is.heap
+
+// Returns: Whether the range `[first, last)` is a heap with respect to `comp`
+// and `proj`.
+//
+// Complexity: Linear.
+//
+// Reference: https://wg21.link/is.heap#:~:text=ranges::is_heap(I
+template <typename RandomAccessIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<RandomAccessIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<RandomAccessIterator, Proj>,
+              std::projected<RandomAccessIterator, Proj>>>
+constexpr auto is_heap(RandomAccessIterator first,
+                       RandomAccessIterator last,
+                       Comp comp = {},
+                       Proj proj = {}) {
+  return std::is_heap(first, last,
+                      internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Returns: Whether `range` is a heap with respect to `comp` and `proj`.
+//
+// Complexity: Linear.
+//
+// Reference: https://wg21.link/is.heap#:~:text=ranges::is_heap(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto is_heap(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::is_heap(std::ranges::begin(range), std::ranges::end(range),
+                         std::move(comp), std::move(proj));
+}
+
+// Returns: The last iterator `i` in `[first, last]` for which the range
+// `[first, i)` is a heap with respect to `comp` and `proj`.
+//
+// Complexity: Linear.
+//
+// Reference: https://wg21.link/is.heap#:~:text=ranges::is_heap_until(I
+template <typename RandomAccessIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<RandomAccessIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<RandomAccessIterator, Proj>,
+              std::projected<RandomAccessIterator, Proj>>>
+constexpr auto is_heap_until(RandomAccessIterator first,
+                             RandomAccessIterator last,
+                             Comp comp = {},
+                             Proj proj = {}) {
+  return std::is_heap_until(
+      first, last, internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Returns: The last iterator `i` in `[begin(range), end(range)]` for which the
+// range `[begin(range), i)` is a heap with respect to `comp` and `proj`.
+//
+// Complexity: Linear.
+//
+// Reference: https://wg21.link/is.heap#:~:text=ranges::is_heap_until(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto is_heap_until(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::is_heap_until(std::ranges::begin(range),
+                               std::ranges::end(range), std::move(comp),
+                               std::move(proj));
+}
+
+// [alg.min.max] Minimum and maximum
+// Reference: https://wg21.link/alg.min.max
+
+// Returns: The smaller value. Returns the first argument when the arguments are
+// equivalent.
+//
+// Complexity: Exactly one comparison and two applications of the projection, if
+// any.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::min
+template <typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity>
+constexpr const T& min(const T& a, const T& b, Comp comp = {}, Proj proj = {}) {
+  return std::invoke(comp, std::invoke(proj, b), std::invoke(proj, a)) ? b : a;
+}
+
+// Preconditions: `!empty(ilist)`.
+//
+// Returns: The smallest value in the input range. Returns a copy of the
+// leftmost element when several elements are equivalent to the smallest.
+//
+// Complexity: Exactly `size(ilist) - 1` comparisons and twice as many
+// applications of the projection, if any.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::min(initializer_list
+template <typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity>
+constexpr T min(std::initializer_list<T> ilist,
+                Comp comp = {},
+                Proj proj = {}) {
+  return *std::min_element(
+      ilist.begin(), ilist.end(),
+      internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Preconditions: `!empty(range)`.
+//
+// Returns: The smallest value in the input range. Returns a copy of the
+// leftmost element when several elements are equivalent to the smallest.
+//
+// Complexity: Exactly `size(range) - 1` comparisons and twice as many
+// applications of the projection, if any.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::min(R
+template <typename Range,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto min(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return *std::min_element(
+      std::ranges::begin(range), std::ranges::end(range),
+      internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Returns: The larger value. Returns the first argument when the arguments are
+// equivalent.
+//
+// Complexity: Exactly one comparison and two applications of the projection, if
+// any.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::max
+template <typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity>
+constexpr const T& max(const T& a, const T& b, Comp comp = {}, Proj proj = {}) {
+  return std::invoke(comp, std::invoke(proj, a), std::invoke(proj, b)) ? b : a;
+}
+
+// Preconditions: `!empty(ilist)`.
+//
+// Returns: The largest value in the input range. Returns a copy of the leftmost
+// element when several elements are equivalent to the largest.
+//
+// Complexity: Exactly `size(ilist) - 1` comparisons and twice as many
+// applications of the projection, if any.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::max(initializer_list
+template <typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity>
+constexpr T max(std::initializer_list<T> ilist,
+                Comp comp = {},
+                Proj proj = {}) {
+  return *std::max_element(
+      ilist.begin(), ilist.end(),
+      internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Preconditions: `!empty(range)`.
+//
+// Returns: The largest value in the input range. Returns a copy of the leftmost
+// element when several elements are equivalent to the smallest.
+//
+// Complexity: Exactly `size(range) - 1` comparisons and twice as many
+// applications of the projection, if any.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::max(R
+template <typename Range,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto max(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return *std::max_element(
+      std::ranges::begin(range), std::ranges::end(range),
+      internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Returns: `{b, a}` if `b` is smaller than `a`, and `{a, b}` otherwise.
+//
+// Complexity: Exactly one comparison and two applications of the projection, if
+// any.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::minmax
+template <typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity>
+constexpr auto minmax(const T& a, const T& b, Comp comp = {}, Proj proj = {}) {
+  return std::minmax(a, b,
+                     internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Preconditions: `!empty(ilist)`.
+//
+// Returns: Let `X` be the return type. Returns `X{x, y}`, where `x` is a copy
+// of the leftmost element with the smallest value and `y` a copy of the
+// rightmost element with the largest value in the input range.
+//
+// Complexity: At most `(3/2) size(ilist)` applications of the corresponding
+// predicate and twice as many applications of the projection, if any.
+//
+// Reference:
+// https://wg21.link/alg.min.max#:~:text=ranges::minmax(initializer_list
+template <typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity>
+constexpr auto minmax(std::initializer_list<T> ilist,
+                      Comp comp = {},
+                      Proj proj = {}) {
+  auto it =
+      std::minmax_element(std::ranges::begin(ilist), std::ranges::end(ilist),
+                          internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return std::pair<T, T>{*it.first, *it.second};
+}
+
+// Preconditions: `!empty(range)`.
+//
+// Returns: Let `X` be the return type. Returns `X{x, y}`, where `x` is a copy
+// of the leftmost element with the smallest value and `y` a copy of the
+// rightmost element with the largest value in the input range.
+//
+// Complexity: At most `(3/2) size(range)` applications of the corresponding
+// predicate and twice as many applications of the projection, if any.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::minmax(R
+template <typename Range,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::range_category_t<Range>>
+constexpr auto minmax(Range&& range, Comp comp = {}, Proj proj = {}) {
+  using T = range_value_t<Range>;
+  auto it =
+      std::minmax_element(std::ranges::begin(range), std::ranges::end(range),
+                          internal::ProjectedBinaryPredicate(comp, proj, proj));
+  return std::pair<T, T>{*it.first, *it.second};
+}
+
+// Returns: The first iterator i in the range `[first, last)` such that for
+// every iterator `j` in the range `[first, last)`,
+// `bool(invoke(comp, invoke(proj, *j), invoke(proj, *i)))` is `false`. Returns
+// `last` if `first == last`.
+//
+// Complexity: Exactly `max(last - first - 1, 0)` comparisons and twice as
+// many projections.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::min_element(I
+template <
+    typename ForwardIterator,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<ForwardIterator, Proj>,
+                                      std::projected<ForwardIterator, Proj>>>
+constexpr auto min_element(ForwardIterator first,
+                           ForwardIterator last,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  return std::min_element(first, last,
+                          internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Returns: The first iterator i in `range` such that for every iterator `j` in
+// `range`, `bool(invoke(comp, invoke(proj, *j), invoke(proj, *i)))` is `false`.
+// Returns `end(range)` if `empty(range)`.
+//
+// Complexity: Exactly `max(size(range) - 1, 0)` comparisons and twice as many
+// projections.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::min_element(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto min_element(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::min_element(std::ranges::begin(range), std::ranges::end(range),
+                             std::move(comp), std::move(proj));
+}
+
+// Returns: The first iterator i in the range `[first, last)` such that for
+// every iterator `j` in the range `[first, last)`,
+// `bool(invoke(comp, invoke(proj, *i), invoke(proj, *j)))` is `false`.
+// Returns `last` if `first == last`.
+//
+// Complexity: Exactly `max(last - first - 1, 0)` comparisons and twice as
+// many projections.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::max_element(I
+template <
+    typename ForwardIterator,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<ForwardIterator, Proj>,
+                                      std::projected<ForwardIterator, Proj>>>
+constexpr auto max_element(ForwardIterator first,
+                           ForwardIterator last,
+                           Comp comp = {},
+                           Proj proj = {}) {
+  return std::max_element(first, last,
+                          internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Returns: The first iterator i in `range` such that for every iterator `j`
+// in `range`, `bool(invoke(comp, invoke(proj, *j), invoke(proj, *j)))` is
+// `false`. Returns `end(range)` if `empty(range)`.
+//
+// Complexity: Exactly `max(size(range) - 1, 0)` comparisons and twice as many
+// projections.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::max_element(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto max_element(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::max_element(std::ranges::begin(range), std::ranges::end(range),
+                             std::move(comp), std::move(proj));
+}
+
+// Returns: `{first, first}` if `[first, last)` is empty, otherwise `{m, M}`,
+// where `m` is the first iterator in `[first, last)` such that no iterator in
+// the range refers to a smaller element, and where `M` is the last iterator
+// in
+// `[first, last)` such that no iterator in the range refers to a larger
+// element.
+//
+// Complexity: Let `N` be `last - first`. At most `max(3/2 (N  1), 0)`
+// comparisons and twice as many applications of the projection, if any.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::minmax_element(I
+template <
+    typename ForwardIterator,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<ForwardIterator, Proj>,
+                                      std::projected<ForwardIterator, Proj>>>
+constexpr auto minmax_element(ForwardIterator first,
+                              ForwardIterator last,
+                              Comp comp = {},
+                              Proj proj = {}) {
+  return std::minmax_element(
+      first, last, internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Returns: `{begin(range), begin(range)}` if `range` is empty, otherwise
+// `{m, M}`, where `m` is the first iterator in `range` such that no iterator
+// in the range refers to a smaller element, and where `M` is the last
+// iterator in `range` such that no iterator in the range refers to a larger
+// element.
+//
+// Complexity: Let `N` be `size(range)`. At most `max(3/2 (N  1), 0)`
+// comparisons and twice as many applications of the projection, if any.
+//
+// Reference: https://wg21.link/alg.min.max#:~:text=ranges::minmax_element(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto minmax_element(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::minmax_element(std::ranges::begin(range),
+                                std::ranges::end(range), std::move(comp),
+                                std::move(proj));
+}
+
+// [alg.clamp] Bounded value
+// Reference: https://wg21.link/alg.clamp
+
+// Preconditions: `bool(invoke(comp, invoke(proj, hi), invoke(proj, lo)))` is
+// `false`.
+//
+// Returns: `lo` if `bool(invoke(comp, invoke(proj, v), invoke(proj, lo)))` is
+// `true`, `hi` if `bool(invoke(comp, invoke(proj, hi), invoke(proj, v)))` is
+// `true`, otherwise `v`.
+//
+// Complexity: At most two comparisons and three applications of the
+// projection.
+//
+// Reference: https://wg21.link/alg.clamp#:~:text=ranges::clamp
+template <typename T,
+          typename Comp = ranges::less,
+          typename Proj = std::identity>
+constexpr const T& clamp(const T& v,
+                         const T& lo,
+                         const T& hi,
+                         Comp comp = {},
+                         Proj proj = {}) {
+  auto&& projected_v = std::invoke(proj, v);
+  if (std::invoke(comp, projected_v, std::invoke(proj, lo))) {
+    return lo;
+  }
+
+  return std::invoke(comp, std::invoke(proj, hi), projected_v) ? hi : v;
+}
+
+// [alg.lex.comparison] Lexicographical comparison
+// Reference: https://wg21.link/alg.lex.comparison
+
+// Returns: `true` if and only if the sequence of elements defined by the range
+// `[first1, last1)` is lexicographically less than the sequence of elements
+// defined by the range `[first2, last2)`.
+//
+// Complexity: At most `2 min(last1 - first1, last2 - first2)` applications of
+// the corresponding comparison and each projection, if any.
+//
+// Remarks: If two sequences have the same number of elements and their
+// corresponding elements (if any) are equivalent, then neither sequence is
+// lexicographically less than the other. If one sequence is a proper prefix of
+// the other, then the shorter sequence is lexicographically less than the
+// longer sequence. Otherwise, the lexicographical comparison of the sequences
+// yields the same result as the comparison of the first corresponding pair of
+// elements that are not equivalent.
+//
+// Reference:
+// https://wg21.link/alg.lex.comparison#:~:text=lexicographical_compare(I1
+template <
+    typename ForwardIterator1,
+    typename ForwardIterator2,
+    typename Comp = ranges::less,
+    typename Proj1 = std::identity,
+    typename Proj2 = std::identity,
+    typename = internal::iterator_category_t<ForwardIterator1>,
+    typename = internal::iterator_category_t<ForwardIterator2>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<ForwardIterator1, Proj1>,
+                                      std::projected<ForwardIterator2, Proj2>>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<ForwardIterator2, Proj2>,
+                                      std::projected<ForwardIterator1, Proj1>>>
+constexpr bool lexicographical_compare(ForwardIterator1 first1,
+                                       ForwardIterator1 last1,
+                                       ForwardIterator2 first2,
+                                       ForwardIterator2 last2,
+                                       Comp comp = {},
+                                       Proj1 proj1 = {},
+                                       Proj2 proj2 = {}) {
+  for (; first1 != last1 && first2 != last2; ++first1, ++first2) {
+    auto&& projected_first1 = std::invoke(proj1, *first1);
+    auto&& projected_first2 = std::invoke(proj2, *first2);
+    if (std::invoke(comp, projected_first1, projected_first2)) {
+      return true;
+    }
+    if (std::invoke(comp, projected_first2, projected_first1)) {
+      return false;
+    }
+  }
+
+  // `first2 != last2` is equivalent to `first1 == last1 && first2 != last2`
+  // here, since we broke out of the loop above.
+  return first2 != last2;
+}
+
+// Returns: `true` if and only if the sequence of elements defined by `range1`
+//  is lexicographically less than the sequence of elements defined by `range2`.
+//
+// Complexity: At most `2 min(size(range1), size(range2))` applications of the
+// corresponding comparison and each projection, if any.
+//
+// Remarks: If two sequences have the same number of elements and their
+// corresponding elements (if any) are equivalent, then neither sequence is
+// lexicographically less than the other. If one sequence is a proper prefix of
+// the other, then the shorter sequence is lexicographically less than the
+// longer sequence. Otherwise, the lexicographical comparison of the sequences
+// yields the same result as the comparison of the first corresponding pair of
+// elements that are not equivalent.
+//
+// Reference:
+// https://wg21.link/alg.lex.comparison#:~:text=lexicographical_compare(R1
+template <typename Range1,
+          typename Range2,
+          typename Comp = ranges::less,
+          typename Proj1 = std::identity,
+          typename Proj2 = std::identity,
+          typename = internal::range_category_t<Range1>,
+          typename = internal::range_category_t<Range2>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range1>, Proj1>,
+                                     std::projected<iterator_t<Range2>, Proj2>>,
+          typename =
+              std::indirect_result_t<Comp&,
+                                     std::projected<iterator_t<Range2>, Proj2>,
+                                     std::projected<iterator_t<Range1>, Proj1>>>
+constexpr bool lexicographical_compare(Range1&& range1,
+                                       Range2&& range2,
+                                       Comp comp = {},
+                                       Proj1 proj1 = {},
+                                       Proj2 proj2 = {}) {
+  return ranges::lexicographical_compare(
+      std::ranges::begin(range1), std::ranges::end(range1),
+      std::ranges::begin(range2), std::ranges::end(range2), std::move(comp),
+      std::move(proj1), std::move(proj2));
+}
+
+// [alg.permutation.generators] Permutation generators
+// Reference: https://wg21.link/alg.permutation.generators
+
+// Effects: Takes a sequence defined by the range `[first, last)` and transforms
+// it into the next permutation. The next permutation is found by assuming that
+// the set of all permutations is lexicographically sorted with respect to
+// `comp` and `proj`. If no such permutation exists, transforms the sequence
+// into the first permutation; that is, the ascendingly-sorted one.
+//
+// Returns: `true` if a next permutation was found and otherwise `false`.
+//
+// Complexity: At most `(last - first) / 2` swaps.
+//
+// Reference:
+// https://wg21.link/alg.permutation.generators#:~:text=next_permutation(I
+template <typename BidirectionalIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<BidirectionalIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<BidirectionalIterator, Proj>,
+              std::projected<BidirectionalIterator, Proj>>>
+constexpr auto next_permutation(BidirectionalIterator first,
+                                BidirectionalIterator last,
+                                Comp comp = {},
+                                Proj proj = {}) {
+  return std::next_permutation(
+      first, last, internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Effects: Takes a sequence defined by `range` and transforms it into the next
+// permutation. The next permutation is found by assuming that the set of all
+// permutations is lexicographically sorted with respect to `comp` and `proj`.
+// If no such permutation exists, transforms the sequence into the first
+// permutation; that is, the ascendingly-sorted one.
+//
+// Returns: `true` if a next permutation was found and otherwise `false`.
+//
+// Complexity: At most `size(range) / 2` swaps.
+//
+// Reference:
+// https://wg21.link/alg.permutation.generators#:~:text=next_permutation(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto next_permutation(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::next_permutation(std::ranges::begin(range),
+                                  std::ranges::end(range), std::move(comp),
+                                  std::move(proj));
+}
+
+// Effects: Takes a sequence defined by the range `[first, last)` and transforms
+// it into the previous permutation. The previous permutation is found by
+// assuming that the set of all permutations is lexicographically sorted with
+// respect to `comp` and `proj`. If no such permutation exists, transforms the
+// sequence into the last permutation; that is, the decreasingly-sorted one.
+//
+// Returns: `true` if a next permutation was found and otherwise `false`.
+//
+// Complexity: At most `(last - first) / 2` swaps.
+//
+// Reference:
+// https://wg21.link/alg.permutation.generators#:~:text=prev_permutation(I
+template <typename BidirectionalIterator,
+          typename Comp = ranges::less,
+          typename Proj = std::identity,
+          typename = internal::iterator_category_t<BidirectionalIterator>,
+          typename = std::indirect_result_t<
+              Comp&,
+              std::projected<BidirectionalIterator, Proj>,
+              std::projected<BidirectionalIterator, Proj>>>
+constexpr auto prev_permutation(BidirectionalIterator first,
+                                BidirectionalIterator last,
+                                Comp comp = {},
+                                Proj proj = {}) {
+  return std::prev_permutation(
+      first, last, internal::ProjectedBinaryPredicate(comp, proj, proj));
+}
+
+// Effects: Takes a sequence defined by `range` and transforms it into the
+// previous permutation. The previous permutation is found by assuming that the
+// set of all permutations is lexicographically sorted with respect to `comp`
+// and `proj`. If no such permutation exists, transforms the sequence into the
+// last permutation; that is, the decreasingly-sorted one.
+//
+// Returns: `true` if a previous permutation was found and otherwise `false`.
+//
+// Complexity: At most `size(range) / 2` swaps.
+//
+// Reference:
+// https://wg21.link/alg.permutation.generators#:~:text=prev_permutation(R
+template <
+    typename Range,
+    typename Comp = ranges::less,
+    typename Proj = std::identity,
+    typename = internal::range_category_t<Range>,
+    typename = std::indirect_result_t<Comp&,
+                                      std::projected<iterator_t<Range>, Proj>,
+                                      std::projected<iterator_t<Range>, Proj>>>
+constexpr auto prev_permutation(Range&& range, Comp comp = {}, Proj proj = {}) {
+  return ranges::prev_permutation(std::ranges::begin(range),
+                                  std::ranges::end(range), std::move(comp),
+                                  std::move(proj));
+}
+
+}  // namespace ranges
 
-// TODO(crbug.com/40240443): Remove this and use std::ranges:: directly.
-
-namespace base::ranges {
-
-using std::ranges::adjacent_find;
-using std::ranges::all_of;
-using std::ranges::any_of;
-using std::ranges::binary_search;
-using std::ranges::clamp;
-using std::ranges::copy;
-using std::ranges::copy_backward;
-using std::ranges::copy_if;
-using std::ranges::copy_n;
-using std::ranges::count;
-using std::ranges::count_if;
-using std::ranges::equal;
-using std::ranges::equal_range;
-using std::ranges::fill;
-using std::ranges::fill_n;
-using std::ranges::find;
-using std::ranges::find_end;
-using std::ranges::find_first_of;
-using std::ranges::find_if;
-using std::ranges::find_if_not;
-using std::ranges::for_each;
-using std::ranges::for_each_n;
-using std::ranges::generate;
-using std::ranges::generate_n;
-using std::ranges::includes;
-using std::ranges::inplace_merge;
-using std::ranges::is_heap;
-using std::ranges::is_heap_until;
-using std::ranges::is_partitioned;
-using std::ranges::is_permutation;
-using std::ranges::is_sorted;
-using std::ranges::is_sorted_until;
-using std::ranges::lexicographical_compare;
-using std::ranges::lower_bound;
-using std::ranges::make_heap;
-using std::ranges::max;
-using std::ranges::max_element;
-using std::ranges::merge;
-using std::ranges::min;
-using std::ranges::min_element;
-using std::ranges::minmax;
-using std::ranges::minmax_element;
-using std::ranges::mismatch;
-using std::ranges::move;
-using std::ranges::move_backward;
-using std::ranges::next_permutation;
-using std::ranges::none_of;
-using std::ranges::nth_element;
-using std::ranges::partial_sort;
-using std::ranges::partial_sort_copy;
-using std::ranges::partition;
-using std::ranges::partition_copy;
-using std::ranges::partition_point;
-using std::ranges::pop_heap;
-using std::ranges::prev_permutation;
-using std::ranges::push_heap;
-using std::ranges::remove;
-using std::ranges::remove_copy;
-using std::ranges::remove_copy_if;
-using std::ranges::remove_if;
-using std::ranges::replace;
-using std::ranges::replace_copy;
-using std::ranges::replace_copy_if;
-using std::ranges::replace_if;
-using std::ranges::reverse;
-using std::ranges::reverse_copy;
-using std::ranges::rotate;
-using std::ranges::rotate_copy;
-using std::ranges::search;
-using std::ranges::search_n;
-using std::ranges::set_difference;
-using std::ranges::set_intersection;
-using std::ranges::set_symmetric_difference;
-using std::ranges::set_union;
-using std::ranges::shuffle;
-using std::ranges::sort;
-using std::ranges::sort_heap;
-using std::ranges::stable_partition;
-using std::ranges::stable_sort;
-using std::ranges::swap_ranges;
-using std::ranges::transform;
-using std::ranges::unique;
-using std::ranges::unique_copy;
-using std::ranges::upper_bound;
-
-}  // namespace base::ranges
+}  // namespace base
 
 #endif  // BASE_RANGES_ALGORITHM_H_
diff --git a/base/ranges/algorithm_unittest.cc b/base/ranges/algorithm_unittest.cc
new file mode 100644
index 0000000000000..9f78dbff0d2b7
--- /dev/null
+++ b/base/ranges/algorithm_unittest.cc
@@ -0,0 +1,1718 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/40284755): Remove this and spanify to fix the errors.
+#pragma allow_unsafe_buffers
+#endif
+
+#include "base/ranges/algorithm.h"
+
+#include <algorithm>
+#include <functional>
+#include <initializer_list>
+#include <iterator>
+#include <random>
+#include <ranges>
+#include <utility>
+
+#include "base/ranges/functional.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+using ::testing::ElementsAre;
+using ::testing::Field;
+using ::testing::Ge;
+using ::testing::Gt;
+using ::testing::Le;
+using ::testing::Lt;
+using ::testing::Pair;
+
+namespace base {
+
+namespace {
+
+// A macro to work around the fact that lambdas are not constexpr in C++14.
+// This will define an unnamed struct with a constexpr call operator, similarly
+// to how lambdas behave in C++17+.
+// Note that this does not support capture groups, so all lambdas defined like
+// this must be stateless.
+// Example Usage: `CONSTEXPR_LAMBDA((int i, int j) { return i + j; }) lambda;`
+// TODO(crbug.com/40533712): Remove once we have constexpr lambdas for real.
+#define CONSTEXPR_LAMBDA(fun)     \
+  constexpr struct {              \
+    constexpr bool operator() fun \
+  }
+
+struct Int {
+  constexpr Int() = default;
+  constexpr Int(int value)  // NOLINT(google-explicit-constructor)
+      : value(value) {}
+
+  int value = 0;
+};
+
+constexpr bool operator==(Int lhs, Int rhs) {
+  return lhs.value == rhs.value;
+}
+
+constexpr auto operator<=>(Int lhs, Int rhs) {
+  return lhs.value <=> rhs.value;
+}
+
+// Move-only int that clears `value` when moving out.
+struct MoveOnlyInt {
+  MoveOnlyInt(int value)  // NOLINT(google-explicit-constructor)
+      : value(value) {}
+  MoveOnlyInt(MoveOnlyInt&& other) : value(std::exchange(other.value, 0)) {}
+
+  MoveOnlyInt& operator=(MoveOnlyInt&& other) {
+    value = std::exchange(other.value, 0);
+    return *this;
+  }
+
+  int value = 0;
+};
+
+constexpr bool is_even(int i) {
+  return i % 2 == 0;
+}
+
+bool is_odd(int i) {
+  return i % 2 == 1;
+}
+
+template <typename Iter>
+auto make_vector(Iter begin, Iter end) {
+  using T = typename std::iterator_traits<Iter>::value_type;
+  return std::vector<T>(begin, end);
+}
+
+}  // namespace
+
+TEST(RangesTest, AllOf) {
+  // Note: Lambdas don't have a constexpr call operator prior to C++17, thus we
+  // are providing our own anonyomous struct here.
+  constexpr struct {
+    constexpr bool operator()(int i) { return i != 0; }
+  } is_non_zero;
+
+  constexpr int array[] = {0, 1, 2, 3, 4, 5};
+
+  static_assert(ranges::all_of(array + 1, array + 6, is_non_zero), "");
+  static_assert(!ranges::all_of(array, is_non_zero), "");
+
+  constexpr Int values[] = {0, 2, 4, 5};
+  static_assert(ranges::all_of(values + 1, std::ranges::end(values),
+                               is_non_zero, &Int::value),
+                "");
+  static_assert(!ranges::all_of(values, is_non_zero, &Int::value), "");
+}
+
+TEST(RangesTest, AnyOf) {
+  constexpr int array[] = {0, 1, 2, 3, 4, 5};
+
+  static_assert(!ranges::any_of(array + 5, array + 6, is_even), "");
+  static_assert(ranges::any_of(array, is_even), "");
+
+  constexpr Int values[] = {{0}, {2}, {4}, {5}};
+  static_assert(!ranges::any_of(values + 3, std::ranges::end(values), is_even,
+                                &Int::value),
+                "");
+  static_assert(ranges::any_of(values, is_even, &Int::value), "");
+}
+
+TEST(RangesTest, NoneOf) {
+  // Note: Lambdas don't have a constexpr call operator prior to C++17, thus we
+  // are providing our own anonyomous struct here.
+  constexpr struct {
+    constexpr bool operator()(int i) { return i == 0; }
+  } is_zero;
+  constexpr int array[] = {0, 1, 2, 3, 4, 5};
+
+  static_assert(ranges::none_of(array + 1, array + 6, is_zero), "");
+  static_assert(!ranges::none_of(array, is_zero), "");
+
+  constexpr Int values[] = {{0}, {2}, {4}, {5}};
+  static_assert(ranges::none_of(values + 1, std::ranges::end(values), is_zero,
+                                &Int::value),
+                "");
+  static_assert(!ranges::none_of(values, is_zero, &Int::value), "");
+}
+
+TEST(RangesTest, ForEach) {
+  auto times_two = [](int& i) { i *= 2; };
+  int array[] = {0, 1, 2, 3, 4, 5};
+
+  auto result = ranges::for_each(array, array + 3, times_two);
+  EXPECT_EQ(result.in, array + 3);
+  // TODO(crbug.com/40174470): Fix googletest and switch this back to
+  // EXPECT_EQ.
+  EXPECT_TRUE(result.fun == times_two);
+  EXPECT_THAT(array, ElementsAre(0, 2, 4, 3, 4, 5));
+
+  ranges::for_each(array + 3, array + 6, times_two);
+  EXPECT_EQ(result.in, array + 3);
+  // TODO(crbug.com/40174470): Fix googletest and switch this back to
+  // EXPECT_EQ.
+  EXPECT_TRUE(result.fun == times_two);
+  EXPECT_THAT(array, ElementsAre(0, 2, 4, 6, 8, 10));
+
+  // TODO(crbug.com/40174470): Fix googletest and switch this back to
+  // EXPECT_EQ.
+  EXPECT_TRUE(times_two == ranges::for_each(array, times_two).fun);
+  EXPECT_THAT(array, ElementsAre(0, 4, 8, 12, 16, 20));
+
+  Int values[] = {0, 2, 4, 5};
+  // TODO(crbug.com/40174470): Fix googletest and switch this back to
+  // EXPECT_EQ.
+  EXPECT_TRUE(times_two ==
+              ranges::for_each(values, times_two, &Int::value).fun);
+  EXPECT_THAT(values,
+              ElementsAre(Field(&Int::value, 0), Field(&Int::value, 4),
+                          Field(&Int::value, 8), Field(&Int::value, 10)));
+}
+
+TEST(RangesTest, ForEachN) {
+  auto times_two = [](int& i) { i *= 2; };
+  int array[] = {0, 1, 2, 3, 4, 5};
+
+  auto result = ranges::for_each_n(array, 3, times_two);
+  EXPECT_EQ(result.in, array + 3);
+  // TODO(crbug.com/40174470): Fix googletest and switch this back to
+  // EXPECT_EQ.
+  EXPECT_TRUE(result.fun == times_two);
+  EXPECT_THAT(array, ElementsAre(0, 2, 4, 3, 4, 5));
+
+  Int values[] = {0, 2, 4, 5};
+  // TODO(crbug.com/40174470): Fix googletest and switch this back to
+  // EXPECT_EQ.
+  EXPECT_TRUE(times_two ==
+              ranges::for_each_n(values, 4, times_two, &Int::value).fun);
+  EXPECT_THAT(values,
+              ElementsAre(Field(&Int::value, 0), Field(&Int::value, 4),
+                          Field(&Int::value, 8), Field(&Int::value, 10)));
+}
+
+TEST(RangesTest, Find) {
+  constexpr int array[] = {0, 1, 2, 3, 4, 5};
+
+  static_assert(array + 6 == ranges::find(array + 1, array + 6, 0), "");
+  static_assert(array == ranges::find(array, 0), "");
+
+  constexpr Int values[] = {{0}, {2}, {4}, {5}};
+  static_assert(values == ranges::find(values, values, 0, &Int::value), "");
+  static_assert(
+      std::ranges::end(values) == ranges::find(values, 3, &Int::value), "");
+}
+
+TEST(RangesTest, FindIf) {
+  auto is_at_least_5 = [](int i) { return i >= 5; };
+  int array[] = {0, 1, 2, 3, 4, 5};
+
+  EXPECT_EQ(array + 5, ranges::find_if(array, array + 5, is_at_least_5));
+  EXPECT_EQ(array + 5, ranges::find_if(array, is_at_least_5));
+
+  Int values[] = {{0}, {2}, {4}, {5}};
+  EXPECT_EQ(values + 3,
+            ranges::find_if(values, values + 3, is_odd, &Int::value));
+  EXPECT_EQ(values + 3, ranges::find_if(values, is_odd, &Int::value));
+}
+
+TEST(RangesTest, FindIfNot) {
+  auto is_less_than_5 = [](int i) { return i < 5; };
+  int array[] = {0, 1, 2, 3, 4, 5};
+
+  EXPECT_EQ(array + 5, ranges::find_if_not(array, array + 5, is_less_than_5));
+  EXPECT_EQ(array + 5, ranges::find_if_not(array, is_less_than_5));
+
+  Int values[] = {{0}, {2}, {4}, {5}};
+  EXPECT_EQ(values + 3,
+            ranges::find_if_not(values, values + 3, is_even, &Int::value));
+  EXPECT_EQ(values + 3, ranges::find_if_not(values, is_even, &Int::value));
+}
+
+TEST(RangesTest, FindEnd) {
+  int array1[] = {0, 1, 2};
+  int array2[] = {4, 5, 6};
+  int array3[] = {0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4,
+                  0, 1, 2, 3, 0, 1, 2, 0, 1, 0};
+
+  EXPECT_EQ(array3 + 15, ranges::find_end(array3, std::ranges::end(array3),
+                                          array1, std::ranges::end(array1)));
+  EXPECT_EQ(std::ranges::end(array3),
+            ranges::find_end(array3, std::ranges::end(array3), array2,
+                             std::ranges::end(array2)));
+  EXPECT_EQ(array3 + 4, ranges::find_end(array3, std::ranges::end(array3),
+                                         array2, array2 + 2));
+
+  Int ints1[] = {{0}, {1}, {2}};
+  Int ints2[] = {{4}, {5}, {6}};
+
+  EXPECT_EQ(array3 + 15, ranges::find_end(array3, ints1, ranges::equal_to{},
+                                          std::identity{}, &Int::value));
+  EXPECT_EQ(std::ranges::end(array3),
+            ranges::find_end(array3, ints2, ranges::equal_to{}, std::identity{},
+                             &Int::value));
+}
+
+TEST(RangesTest, FindFirstOf) {
+  int array1[] = {1, 2, 3};
+  int array2[] = {7, 8, 9};
+  int array3[] = {0, 1, 2, 3, 4, 5, 0, 1, 2, 3};
+
+  EXPECT_EQ(array3 + 1,
+            ranges::find_first_of(array3, std::ranges::end(array3), array1,
+                                  std::ranges::end(array1)));
+  EXPECT_EQ(std::ranges::end(array3),
+            ranges::find_first_of(array3, std::ranges::end(array3), array2,
+                                  std::ranges::end(array2)));
+  Int ints1[] = {{1}, {2}, {3}};
+  Int ints2[] = {{7}, {8}, {9}};
+
+  EXPECT_EQ(array3 + 1, ranges::find_first_of(array3, ints1, ranges::equal_to{},
+                                              std::identity{}, &Int::value));
+  EXPECT_EQ(std::ranges::end(array3),
+            ranges::find_first_of(array3, ints2, ranges::equal_to{},
+                                  std::identity{}, &Int::value));
+}
+
+TEST(RangesTest, AdjacentFind) {
+  constexpr int array[] = {1, 2, 3, 3};
+  static_assert(
+      array + 2 == ranges::adjacent_find(array, std::ranges::end(array)), "");
+  static_assert(array == ranges::adjacent_find(array, std::ranges::end(array),
+                                               ranges::less{}),
+                "");
+
+  constexpr Int ints[] = {{6}, {6}, {5}, {4}};
+  static_assert(
+      ints == ranges::adjacent_find(ints, ranges::equal_to{}, &Int::value), "");
+  static_assert(std::ranges::end(ints) ==
+                    ranges::adjacent_find(ints, ranges::less{}, &Int::value),
+                "");
+}
+
+TEST(RangesTest, Count) {
+  int array[] = {1, 2, 3, 3};
+  EXPECT_EQ(1, ranges::count(array, array + 4, 1));
+  EXPECT_EQ(1, ranges::count(array, array + 4, 2));
+  EXPECT_EQ(1, ranges::count(array, array + 3, 3));
+  EXPECT_EQ(2, ranges::count(array, array + 4, 3));
+
+  Int ints[] = {{1}, {2}, {3}, {3}};
+  EXPECT_EQ(1, ranges::count(ints, 1, &Int::value));
+  EXPECT_EQ(1, ranges::count(ints, 2, &Int::value));
+  EXPECT_EQ(2, ranges::count(ints, 3, &Int::value));
+}
+
+TEST(RangesTest, CountIf) {
+  int array[] = {1, 2, 3, 3};
+  EXPECT_EQ(0, ranges::count_if(array, array + 1, is_even));
+  EXPECT_EQ(1, ranges::count_if(array, array + 2, is_even));
+  EXPECT_EQ(1, ranges::count_if(array, array + 3, is_even));
+  EXPECT_EQ(1, ranges::count_if(array, array + 4, is_even));
+
+  Int ints[] = {{1}, {2}, {3}, {3}};
+  EXPECT_EQ(1, ranges::count_if(ints, is_even, &Int::value));
+  EXPECT_EQ(3, ranges::count_if(ints, is_odd, &Int::value));
+}
+
+TEST(RangesTest, Mismatch) {
+  int array1[] = {1, 3, 6, 7};
+  int array2[] = {1, 3};
+  int array3[] = {1, 3, 5, 7};
+  EXPECT_EQ(std::make_pair(array1 + 2, array2 + 2),
+            ranges::mismatch(array1, array1 + 4, array2, array2 + 2));
+  EXPECT_EQ(std::make_pair(array1 + 2, array3 + 2),
+            ranges::mismatch(array1, array1 + 4, array3, array3 + 4));
+
+  EXPECT_EQ(std::make_pair(array1 + 2, array2 + 2),
+            ranges::mismatch(array1, array2));
+  EXPECT_EQ(std::make_pair(array1 + 2, array3 + 2),
+            ranges::mismatch(array1, array3));
+}
+
+TEST(RangesTest, Equal) {
+  static constexpr int array1[] = {1, 3, 6, 7};
+  static constexpr int array2[] = {1, 3, 5, 7};
+
+  static_assert(ranges::equal(array1, array1 + 2, array2, array2 + 2), "");
+  EXPECT_TRUE(ranges::equal(array1, array1 + 2, array2, array2 + 2));
+
+  static_assert(!ranges::equal(array1, array1 + 4, array2, array2 + 4), "");
+  EXPECT_FALSE(ranges::equal(array1, array1 + 4, array2, array2 + 4));
+
+  static_assert(!ranges::equal(array1, array1 + 2, array2, array2 + 3), "");
+  EXPECT_FALSE(ranges::equal(array1, array1 + 2, array2, array2 + 3));
+
+  static constexpr Int ints[] = {{1}, {3}, {5}, {7}};
+
+  CONSTEXPR_LAMBDA((Int lhs, int rhs) { return lhs.value == rhs; }) lambda;
+  static_assert(ranges::equal(ints, array2, lambda), "");
+  EXPECT_TRUE(ranges::equal(ints, array2, lambda));
+
+  static_assert(ranges::equal(array2, ints, ranges::equal_to{}, std::identity{},
+                              &Int::value),
+                "");
+  EXPECT_TRUE(ranges::equal(array2, ints, ranges::equal_to{}, std::identity{},
+                            &Int::value));
+}
+
+TEST(RangesTest, IsPermutation) {
+  int array1[] = {1, 3, 6, 7};
+  int array2[] = {7, 3, 1, 6};
+  int array3[] = {1, 3, 5, 7};
+
+  EXPECT_TRUE(ranges::is_permutation(array1, array1 + 4, array2, array2 + 4));
+  EXPECT_FALSE(ranges::is_permutation(array1, array1 + 4, array3, array3 + 4));
+
+  EXPECT_TRUE(ranges::is_permutation(array1, array2));
+  EXPECT_FALSE(ranges::is_permutation(array1, array3));
+
+  Int ints1[] = {{1}, {3}, {5}, {7}};
+  Int ints2[] = {{1}, {5}, {3}, {7}};
+  EXPECT_TRUE(ranges::is_permutation(
+      ints1, ints2, [](Int lhs, Int rhs) { return lhs.value == rhs.value; }));
+
+  EXPECT_TRUE(ranges::is_permutation(ints1, ints2, ranges::equal_to{},
+                                     &Int::value, &Int::value));
+
+  EXPECT_FALSE(ranges::is_permutation(array1, ints2, ranges::equal_to{}, {},
+                                      &Int::value));
+  EXPECT_TRUE(ranges::is_permutation(array3, ints2, ranges::equal_to{}, {},
+                                     &Int::value));
+}
+
+TEST(RangesTest, Search) {
+  int array1[] = {0, 1, 2, 3};
+  int array2[] = {0, 1, 5, 3};
+  int array3[] = {0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4};
+
+  EXPECT_EQ(array3 + 3,
+            ranges::search(array3, array3 + 12, array1, array1 + 4));
+  EXPECT_EQ(array3 + 12,
+            ranges::search(array3, array3 + 12, array2, array2 + 4));
+
+  EXPECT_EQ(array3 + 3, ranges::search(array3, array1));
+  EXPECT_EQ(array3 + 12, ranges::search(array3, array2));
+
+  Int ints1[] = {{0}, {1}, {2}, {3}};
+  Int ints2[] = {{0}, {1}, {5}, {3}};
+
+  EXPECT_EQ(ints1 + 4, ranges::search(ints1, ints2, ranges::equal_to{},
+                                      &Int::value, &Int::value));
+
+  EXPECT_EQ(array3 + 3, ranges::search(array3, ints1, {}, {}, &Int::value));
+  EXPECT_EQ(array3 + 12, ranges::search(array3, ints2, {}, {}, &Int::value));
+}
+
+TEST(RangesTest, SearchN) {
+  int array[] = {0, 0, 1, 1, 2, 2};
+
+  EXPECT_EQ(array, ranges::search_n(array, array + 6, 1, 0));
+  EXPECT_EQ(array + 2, ranges::search_n(array, array + 6, 1, 1));
+  EXPECT_EQ(array + 4, ranges::search_n(array, array + 6, 1, 2));
+  EXPECT_EQ(array + 6, ranges::search_n(array, array + 6, 1, 3));
+
+  EXPECT_EQ(array, ranges::search_n(array, array + 6, 2, 0));
+  EXPECT_EQ(array + 2, ranges::search_n(array, array + 6, 2, 1));
+  EXPECT_EQ(array + 4, ranges::search_n(array, array + 6, 2, 2));
+  EXPECT_EQ(array + 6, ranges::search_n(array, array + 6, 2, 3));
+
+  EXPECT_EQ(array + 6, ranges::search_n(array, array + 6, 3, 0));
+  EXPECT_EQ(array + 6, ranges::search_n(array, array + 6, 3, 1));
+  EXPECT_EQ(array + 6, ranges::search_n(array, array + 6, 3, 2));
+  EXPECT_EQ(array + 6, ranges::search_n(array, array + 6, 3, 3));
+
+  Int ints[] = {{0}, {0}, {1}, {1}, {2}, {2}};
+  EXPECT_EQ(ints, ranges::search_n(ints, 1, 0, {}, &Int::value));
+  EXPECT_EQ(ints + 2, ranges::search_n(ints, 1, 1, {}, &Int::value));
+  EXPECT_EQ(ints + 4, ranges::search_n(ints, 1, 2, {}, &Int::value));
+  EXPECT_EQ(ints + 6, ranges::search_n(ints, 1, 3, {}, &Int::value));
+
+  EXPECT_EQ(ints, ranges::search_n(ints, 2, 0, {}, &Int::value));
+  EXPECT_EQ(ints + 2, ranges::search_n(ints, 2, 1, {}, &Int::value));
+  EXPECT_EQ(ints + 4, ranges::search_n(ints, 2, 2, {}, &Int::value));
+  EXPECT_EQ(ints + 6, ranges::search_n(ints, 2, 3, {}, &Int::value));
+
+  EXPECT_EQ(ints + 6, ranges::search_n(ints, 3, 0, {}, &Int::value));
+  EXPECT_EQ(ints + 6, ranges::search_n(ints, 3, 1, {}, &Int::value));
+  EXPECT_EQ(ints + 6, ranges::search_n(ints, 3, 2, {}, &Int::value));
+  EXPECT_EQ(ints + 6, ranges::search_n(ints, 3, 3, {}, &Int::value));
+}
+
+TEST(RangesTest, Copy) {
+  int input[] = {1, 2, 3, 4, 5};
+  int output[] = {6, 6, 6, 6, 6, 6, 6};
+  auto equals_six = [](int i) { return i == 6; };
+
+  EXPECT_EQ(output + 3, ranges::copy(input, input + 3, output));
+  EXPECT_TRUE(std::equal(input, input + 3, output, output + 3));
+  EXPECT_TRUE(std::all_of(output + 3, output + 7, equals_six));
+
+  EXPECT_EQ(output + 5, ranges::copy(input, output));
+  EXPECT_TRUE(std::equal(input, input + 5, output, output + 5));
+  EXPECT_TRUE(std::all_of(output + 5, output + 7, equals_six));
+}
+
+TEST(RangesTest, CopyN) {
+  int input[] = {1, 2, 3, 4, 5};
+  int output[] = {6, 6, 6, 6, 6, 6, 6};
+  auto equals_six = [](int i) { return i == 6; };
+
+  EXPECT_EQ(output + 4, ranges::copy_n(input, 4, output));
+  EXPECT_TRUE(std::equal(input, input + 4, output, output + 4));
+  EXPECT_TRUE(std::all_of(output + 4, output + 7, equals_six));
+}
+
+TEST(RangesTest, CopyIf) {
+  int input[] = {2, 4, 6, 8, 6};
+  int output[] = {0, 0, 0, 0, 0, 0};
+  auto equals_six = [](int i) { return i == 6; };
+  auto equals_zero = [](int i) { return i == 0; };
+
+  EXPECT_EQ(output + 1, ranges::copy_if(input, input + 4, output, equals_six));
+  EXPECT_TRUE(std::all_of(output, output + 1, equals_six));
+  EXPECT_TRUE(std::all_of(output + 1, output + 6, equals_zero));
+
+  Int ints_in[] = {{2}, {4}, {6}, {8}, {6}};
+  Int ints_out[] = {{0}, {0}, {0}, {0}, {0}, {0}};
+  EXPECT_EQ(ints_out + 2,
+            ranges::copy_if(ints_in, ints_out, equals_six, &Int::value));
+
+  EXPECT_TRUE(ranges::all_of(ints_out, ints_out + 2, equals_six, &Int::value));
+  EXPECT_TRUE(
+      ranges::all_of(ints_out + 2, ints_out + 6, equals_zero, &Int::value));
+}
+
+TEST(RangesTest, CopyBackward) {
+  int input[] = {2, 4, 6, 8, 6};
+  int output[] = {0, 0, 0, 0, 0, 0};
+
+  EXPECT_EQ(output + 1, ranges::copy_backward(input, input + 5, output + 6));
+  EXPECT_THAT(output, ElementsAre(0, 2, 4, 6, 8, 6));
+
+  Int ints_in[] = {{2}, {4}, {6}, {8}, {6}};
+  Int ints_out[] = {{0}, {0}, {0}, {0}, {0}, {0}};
+
+  EXPECT_EQ(ints_out, ranges::copy_backward(ints_in, ints_out + 5));
+  EXPECT_TRUE(std::equal(ints_in, ints_in + 5, ints_out, ints_out + 5,
+                         [](Int i, Int j) { return i.value == j.value; }));
+}
+
+TEST(RangesTest, Move) {
+  MoveOnlyInt input[] = {6, 6, 6, 6, 6};
+  MoveOnlyInt output[] = {0, 0, 0, 0, 0};
+  auto equals_zero = [](const auto& i) { return i.value == 0; };
+  auto equals_six = [](const auto& i) { return i.value == 6; };
+
+  EXPECT_EQ(output + 3, ranges::move(input, input + 3, output));
+  EXPECT_TRUE(std::all_of(input, input + 3, equals_zero));
+  EXPECT_TRUE(std::all_of(input + 3, input + 5, equals_six));
+  EXPECT_TRUE(std::all_of(output, output + 3, equals_six));
+  EXPECT_TRUE(std::all_of(output + 3, output + 5, equals_zero));
+
+  for (auto& in : input) {
+    in = 6;
+  }
+
+  EXPECT_EQ(output + 5, ranges::move(input, output));
+  EXPECT_TRUE(ranges::all_of(input, equals_zero));
+  EXPECT_TRUE(ranges::all_of(output, equals_six));
+}
+
+TEST(RangesTest, MoveBackward) {
+  MoveOnlyInt input[] = {6, 6, 6, 6, 6};
+  MoveOnlyInt output[] = {0, 0, 0, 0, 0};
+  auto equals_zero = [](const auto& i) { return i.value == 0; };
+  auto equals_six = [](const auto& i) { return i.value == 6; };
+
+  EXPECT_EQ(output + 2, ranges::move_backward(input, input + 3, output + 5));
+  EXPECT_TRUE(std::all_of(input, input + 3, equals_zero));
+  EXPECT_TRUE(std::all_of(input + 3, input + 5, equals_six));
+  EXPECT_TRUE(std::all_of(output, output + 2, equals_zero));
+  EXPECT_TRUE(std::all_of(output + 2, output + 5, equals_six));
+
+  for (auto& in : input) {
+    in = 6;
+  }
+
+  EXPECT_EQ(output, ranges::move_backward(input, output + 5));
+  EXPECT_TRUE(ranges::all_of(input, equals_zero));
+  EXPECT_TRUE(ranges::all_of(output, equals_six));
+}
+
+TEST(RangesTest, SwapRanges) {
+  int ints1[] = {0, 0, 0, 0, 0};
+  int ints2[] = {6, 6, 6, 6, 6};
+
+  // Test that swap_ranges does not exceed `last2`.
+  EXPECT_EQ(ints2 + 3, ranges::swap_ranges(ints1, ints1 + 5, ints2, ints2 + 3));
+  EXPECT_THAT(ints1, ElementsAre(6, 6, 6, 0, 0));
+  EXPECT_THAT(ints2, ElementsAre(0, 0, 0, 6, 6));
+
+  // Test that swap_ranges does not exceed `last1`.
+  EXPECT_EQ(ints2 + 3, ranges::swap_ranges(ints1, ints1 + 3, ints2, ints2 + 5));
+  EXPECT_THAT(ints1, ElementsAre(0, 0, 0, 0, 0));
+  EXPECT_THAT(ints2, ElementsAre(6, 6, 6, 6, 6));
+
+  EXPECT_EQ(ints2 + 5,
+            ranges::swap_ranges(ints1 + 3, ints1 + 5, ints2 + 3, ints2 + 5));
+  EXPECT_THAT(ints1, ElementsAre(0, 0, 0, 6, 6));
+  EXPECT_THAT(ints2, ElementsAre(6, 6, 6, 0, 0));
+
+  EXPECT_EQ(ints2 + 5, ranges::swap_ranges(ints1, ints2));
+  EXPECT_THAT(ints1, ElementsAre(6, 6, 6, 0, 0));
+  EXPECT_THAT(ints2, ElementsAre(0, 0, 0, 6, 6));
+}
+
+TEST(RangesTest, UnaryTransform) {
+  int input[] = {1, 2, 3, 4, 5};
+  auto plus_1 = [](int i) { return i + 1; };
+  auto times_2 = [](int i) { return i * 2; };
+
+  EXPECT_EQ(input + 4,
+            ranges::transform(input + 1, input + 4, input + 1, plus_1));
+  EXPECT_THAT(input, ElementsAre(1, 3, 4, 5, 5));
+
+  int output[] = {0, 0, 0, 0, 0};
+  EXPECT_EQ(output + 3,
+            ranges::transform(input + 1, input + 4, output, times_2));
+  EXPECT_THAT(output, ElementsAre(6, 8, 10, 0, 0));
+
+  Int values[] = {{0}, {2}, {4}, {5}};
+  EXPECT_EQ(values + 4,
+            ranges::transform(values, values, times_2, &Int::value));
+  EXPECT_THAT(values, ElementsAre(Int{0}, Int{4}, Int{8}, Int{10}));
+}
+
+TEST(RangesTest, BinaryTransform) {
+  int input[] = {1, 2, 3, 4, 5};
+  int output[] = {0, 0, 0, 0, 0};
+
+  EXPECT_EQ(output + 2, ranges::transform(input, input + 2, input + 3,
+                                          input + 5, output, std::plus<>{}));
+  EXPECT_THAT(output, ElementsAre(5, 7, 0, 0, 0));
+
+  EXPECT_EQ(output + 5,
+            ranges::transform(input, input, output, std::multiplies<>{}));
+  EXPECT_THAT(output, ElementsAre(1, 4, 9, 16, 25));
+
+  Int values[] = {{0}, {2}, {4}, {5}};
+  EXPECT_EQ(values + 4,
+            ranges::transform(values, values, values, std::minus<>{},
+                              &Int::value, &Int::value));
+  EXPECT_THAT(values, ElementsAre(Int{0}, Int{0}, Int{0}, Int{0}));
+}
+
+TEST(RangesTest, Replace) {
+  int input[] = {0, 0, 0, 0, 0};
+
+  EXPECT_EQ(input + 2, ranges::replace(input, input + 2, 0, 2));
+  EXPECT_THAT(input, ElementsAre(2, 2, 0, 0, 0));
+
+  EXPECT_EQ(input + 5, ranges::replace(input, 0, 3));
+  EXPECT_THAT(input, ElementsAre(2, 2, 3, 3, 3));
+}
+
+TEST(RangesTest, ReplaceIf) {
+  int input[] = {0, 1, 2, 3, 4};
+
+  EXPECT_EQ(input + 3, ranges::replace_if(input, input + 3, is_even, 9));
+  EXPECT_THAT(input, ElementsAre(9, 1, 9, 3, 4));
+
+  EXPECT_EQ(input + 5, ranges::replace_if(input, is_odd, 0));
+  EXPECT_THAT(input, ElementsAre(0, 0, 0, 0, 4));
+
+  Int ints[] = {0, 0, 1, 1, 0};
+  EXPECT_EQ(ints + 5, ranges::replace_if(ints, is_odd, 3, &Int::value));
+  EXPECT_THAT(ints, ElementsAre(0, 0, 3, 3, 0));
+}
+
+TEST(RangesTest, ReplaceCopy) {
+  int input[] = {0, 0, 0, 0, 0};
+  int output[] = {1, 1, 1, 1, 1};
+
+  EXPECT_EQ(input + 2, ranges::replace_copy(input, input + 2, output, 0, 2));
+  EXPECT_THAT(input, ElementsAre(0, 0, 0, 0, 0));
+  EXPECT_THAT(output, ElementsAre(2, 2, 1, 1, 1));
+
+  EXPECT_EQ(input + 5, ranges::replace_copy(input, output, 0, 3));
+  EXPECT_THAT(input, ElementsAre(0, 0, 0, 0, 0));
+  EXPECT_THAT(output, ElementsAre(3, 3, 3, 3, 3));
+}
+
+TEST(RangesTest, ReplaceCopyIf) {
+  Int input[] = {0, 1, 2, 3, 4};
+  Int output[] = {0, 0, 0, 0, 0};
+
+  EXPECT_EQ(output + 3, ranges::replace_copy_if(input, input + 3, output,
+                                                is_even, 9, &Int::value));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4));
+  EXPECT_THAT(output, ElementsAre(9, 1, 9, 0, 0));
+
+  EXPECT_EQ(output + 5,
+            ranges::replace_copy_if(input, output, is_odd, 0, &Int::value));
+  EXPECT_THAT(output, ElementsAre(0, 0, 2, 0, 4));
+}
+
+TEST(RangesTest, Fill) {
+  int input[] = {1, 2, 3, 4, 5};
+
+  EXPECT_EQ(input + 3, ranges::fill(input, input + 3, 0));
+  EXPECT_THAT(input, ElementsAre(0, 0, 0, 4, 5));
+
+  EXPECT_EQ(input + 5, ranges::fill(input, 1));
+  EXPECT_THAT(input, ElementsAre(1, 1, 1, 1, 1));
+}
+
+TEST(RangesTest, FillN) {
+  int input[] = {0, 0, 0, 0, 0};
+
+  EXPECT_EQ(input + 5, ranges::fill_n(input, 5, 5));
+  EXPECT_THAT(input, ElementsAre(5, 5, 5, 5, 5));
+
+  EXPECT_EQ(input + 3, ranges::fill_n(input, 3, 3));
+  EXPECT_THAT(input, ElementsAre(3, 3, 3, 5, 5));
+}
+
+TEST(RangesTest, Generate) {
+  int input[] = {0, 0, 0, 0, 0};
+
+  auto gen = [count = 0]() mutable { return ++count; };
+  EXPECT_EQ(input + 3, ranges::generate(input, input + 3, gen));
+  EXPECT_THAT(input, ElementsAre(1, 2, 3, 0, 0));
+
+  EXPECT_EQ(input + 5, ranges::generate(input, gen));
+  EXPECT_THAT(input, ElementsAre(1, 2, 3, 4, 5));
+}
+
+TEST(RangesTest, GenerateN) {
+  int input[] = {0, 0, 0, 0, 0};
+
+  auto gen = [count = 0]() mutable { return ++count; };
+  EXPECT_EQ(input + 4, ranges::generate_n(input, 4, gen));
+  EXPECT_THAT(input, ElementsAre(1, 2, 3, 4, 0));
+}
+
+TEST(RangesTest, Remove) {
+  int input[] = {1, 0, 1, 1, 0};
+
+  EXPECT_EQ(input + 3, ranges::remove(input + 1, input + 5, 1));
+  EXPECT_EQ(input[0], 1);
+  EXPECT_EQ(input[1], 0);
+  EXPECT_EQ(input[2], 0);
+
+  Int ints[] = {2, 2, 1, 1, 2, 2};
+  EXPECT_EQ(ints + 2, ranges::remove(ints, 2, &Int::value));
+  EXPECT_EQ(ints[0], 1);
+  EXPECT_EQ(ints[1], 1);
+}
+
+TEST(RangesTest, RemoveIf) {
+  int input[] = {0, 1, 2, 3, 4};
+
+  EXPECT_EQ(input + 2, ranges::remove_if(input, input + 4, is_even));
+  EXPECT_EQ(input[0], 1);
+  EXPECT_EQ(input[1], 3);
+  EXPECT_EQ(input[4], 4);
+
+  Int ints[] = {2, 2, 1, 1, 2, 2};
+  EXPECT_EQ(ints + 2, ranges::remove_if(ints, is_even, &Int::value));
+  EXPECT_EQ(ints[0], 1);
+  EXPECT_EQ(ints[1], 1);
+}
+
+TEST(RangesTest, RemoveCopy) {
+  int input[] = {0, 1, 2, 3, 4};
+  int output[] = {0, 0, 0, 0, 0};
+
+  EXPECT_EQ(output + 1, ranges::remove_copy(input, input + 2, output, 0));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4));
+  EXPECT_THAT(output, ElementsAre(1, 0, 0, 0, 0));
+
+  EXPECT_EQ(output + 4, ranges::remove_copy(input, output, 4));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4));
+  EXPECT_THAT(output, ElementsAre(0, 1, 2, 3, 0));
+}
+
+TEST(RangesTest, RemovCopyIf) {
+  Int input[] = {0, 1, 2, 3, 4};
+  Int output[] = {0, 0, 0, 0, 0};
+
+  EXPECT_EQ(output + 2, ranges::remove_copy_if(input, input + 4, output,
+                                               is_even, &Int::value));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4));
+  EXPECT_THAT(output, ElementsAre(1, 3, 0, 0, 0));
+
+  EXPECT_EQ(output + 3,
+            ranges::remove_copy_if(input, output, is_odd, &Int::value));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4));
+  EXPECT_THAT(output, ElementsAre(0, 2, 4, 0, 0));
+}
+
+TEST(RangesTest, Unique) {
+  int input[] = {0, 0, 1, 1, 2};
+
+  EXPECT_EQ(input + 2, ranges::unique(input, input + 3));
+  EXPECT_EQ(input[0], 0);
+  EXPECT_EQ(input[1], 1);
+  EXPECT_EQ(input[3], 1);
+  EXPECT_EQ(input[4], 2);
+
+  Int ints[] = {2, 2, 1, 1, 2, 2};
+  EXPECT_EQ(ints + 3, ranges::unique(ints, {}, &Int::value));
+  EXPECT_EQ(ints[0], 2);
+  EXPECT_EQ(ints[1], 1);
+  EXPECT_EQ(ints[2], 2);
+}
+
+TEST(RangesTest, UniqueCopy) {
+  Int input[] = {0, 0, 1, 2, 2};
+  Int output[] = {0, 0, 0, 0, 0};
+
+  EXPECT_EQ(output + 3,
+            ranges::unique_copy(input, input + 4, output, {}, &Int::value));
+  EXPECT_THAT(input, ElementsAre(0, 0, 1, 2, 2));
+  EXPECT_THAT(output, ElementsAre(0, 1, 2, 0, 0));
+
+  EXPECT_EQ(output + 3, ranges::unique_copy(input, output, {}, &Int::value));
+  EXPECT_THAT(input, ElementsAre(0, 0, 1, 2, 2));
+  EXPECT_THAT(output, ElementsAre(0, 1, 2, 0, 0));
+}
+
+TEST(RangesTest, Reverse) {
+  int input[] = {0, 1, 2, 3, 4};
+
+  EXPECT_EQ(input + 4, ranges::reverse(input + 2, input + 4));
+  EXPECT_THAT(input, ElementsAre(0, 1, 3, 2, 4));
+
+  EXPECT_EQ(input + 5, ranges::reverse(input));
+  EXPECT_THAT(input, ElementsAre(4, 2, 3, 1, 0));
+}
+
+TEST(RangesTest, ReverseCopy) {
+  int input[] = {0, 1, 2, 3, 4};
+  int output[] = {0, 0, 0, 0, 0};
+
+  EXPECT_EQ(output + 2, ranges::reverse_copy(input + 2, input + 4, output));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4));
+  EXPECT_THAT(output, ElementsAre(3, 2, 0, 0, 0));
+
+  EXPECT_EQ(output + 5, ranges::reverse_copy(input, output));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4));
+  EXPECT_THAT(output, ElementsAre(4, 3, 2, 1, 0));
+}
+
+TEST(RangesTest, Rotate) {
+  int input[] = {0, 1, 2, 3, 4};
+
+  EXPECT_EQ(input + 3, ranges::rotate(input + 2, input + 3, input + 4));
+  EXPECT_THAT(input, ElementsAre(0, 1, 3, 2, 4));
+
+  EXPECT_EQ(input + 3, ranges::rotate(input, input + 2));
+  EXPECT_THAT(input, ElementsAre(3, 2, 4, 0, 1));
+}
+
+TEST(RangesTest, RotateCopy) {
+  int input[] = {0, 1, 2, 3, 4};
+  int output[] = {0, 0, 0, 0, 0};
+
+  EXPECT_EQ(output + 2,
+            ranges::rotate_copy(input + 2, input + 3, input + 4, output));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4));
+  EXPECT_THAT(output, ElementsAre(3, 2, 0, 0, 0));
+
+  EXPECT_EQ(output + 5, ranges::rotate_copy(input, input + 3, output));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4));
+  EXPECT_THAT(output, ElementsAre(3, 4, 0, 1, 2));
+}
+
+TEST(RangesTest, Shuffle) {
+  int input[] = {0, 1, 2, 3, 4};
+
+  // Shuffles input[2] and input[3], thus we can't be certain about their
+  // positions.
+  EXPECT_EQ(input + 4, ranges::shuffle(input + 2, input + 4,
+                                       std::default_random_engine()));
+  EXPECT_EQ(input[0], 0);
+  EXPECT_EQ(input[1], 1);
+  EXPECT_EQ(input[4], 4);
+  EXPECT_THAT(input, ::testing::UnorderedElementsAre(0, 1, 2, 3, 4));
+
+  EXPECT_EQ(input + 5, ranges::shuffle(input, std::default_random_engine()));
+  EXPECT_THAT(input, ::testing::UnorderedElementsAre(0, 1, 2, 3, 4));
+}
+
+TEST(RangesTest, Sort) {
+  int input[] = {3, 1, 2, 0, 4};
+  EXPECT_EQ(input + 4, ranges::sort(input, input + 4));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4));
+
+  EXPECT_EQ(input + 5, ranges::sort(input, input + 5, ranges::greater()));
+  EXPECT_THAT(input, ElementsAre(4, 3, 2, 1, 0));
+
+  Int ints[] = {6, 7, 9, 8, 5};
+  EXPECT_EQ(ints + 5, ranges::sort(ints, {}, &Int::value));
+  EXPECT_THAT(ints, ElementsAre(5, 6, 7, 8, 9));
+
+  EXPECT_EQ(ints + 5, ranges::sort(ints, ranges::greater(), &Int::value));
+  EXPECT_THAT(ints, ElementsAre(9, 8, 7, 6, 5));
+}
+
+TEST(RangesTest, StableSort) {
+  // Integer divide each element by 2 to check stability of elements that
+  // compare equal.
+  auto idiv2 = [](int i) { return i / 2; };
+
+  int input[] = {3, 1, 2, 0, 4};
+  EXPECT_EQ(input + 4, ranges::stable_sort(input, input + 4, {}, idiv2));
+  EXPECT_THAT(input, ElementsAre(1, 0, 3, 2, 4));
+
+  EXPECT_EQ(input + 5,
+            ranges::stable_sort(input, input + 5, ranges::greater()));
+  EXPECT_THAT(input, ElementsAre(4, 3, 2, 1, 0));
+
+  auto Idiv2 = [](Int i) { return i.value / 2; };
+  Int ints[] = {6, 7, 9, 8, 5};
+  EXPECT_EQ(ints + 5, ranges::stable_sort(ints, {}, Idiv2));
+  EXPECT_THAT(ints, ElementsAre(5, 6, 7, 9, 8));
+
+  EXPECT_EQ(ints + 5, ranges::stable_sort(ints, ranges::greater(), Idiv2));
+  EXPECT_THAT(ints, ElementsAre(9, 8, 6, 7, 5));
+}
+
+TEST(RangesTest, PartialSort) {
+  int input[] = {3, 1, 2, 0, 4};
+  EXPECT_EQ(input + 4, ranges::partial_sort(input, input + 2, input + 4));
+  EXPECT_EQ(input[0], 0);
+  EXPECT_EQ(input[1], 1);
+
+  EXPECT_EQ(input + 5, ranges::partial_sort(input, input + 3, input + 5,
+                                            ranges::greater()));
+  EXPECT_EQ(input[0], 4);
+  EXPECT_EQ(input[1], 3);
+  EXPECT_EQ(input[2], 2);
+
+  Int ints[] = {6, 7, 9, 8, 5};
+  EXPECT_EQ(ints + 5, ranges::partial_sort(ints, ints + 4, {}, &Int::value));
+  EXPECT_EQ(ints[0], 5);
+  EXPECT_EQ(ints[1], 6);
+  EXPECT_EQ(ints[2], 7);
+  EXPECT_EQ(ints[3], 8);
+
+  EXPECT_EQ(ints + 5, ranges::partial_sort(ints, ints + 3, ranges::greater(),
+                                           &Int::value));
+  EXPECT_EQ(ints[0], 9);
+  EXPECT_EQ(ints[1], 8);
+  EXPECT_EQ(ints[2], 7);
+}
+
+TEST(RangesTest, PartialSortCopy) {
+  int input[] = {3, 1, 2, 0, 4};
+  int output[] = {0, 0, 0, 0, 0};
+  EXPECT_EQ(output + 2,
+            ranges::partial_sort_copy(input, input + 2, output, output + 4));
+  EXPECT_THAT(input, ElementsAre(3, 1, 2, 0, 4));
+  EXPECT_THAT(output, ElementsAre(1, 3, 0, 0, 0));
+
+  EXPECT_EQ(output + 5,
+            ranges::partial_sort_copy(input, input + 3, output + 3, output + 5,
+                                      ranges::greater()));
+  EXPECT_THAT(input, ElementsAre(3, 1, 2, 0, 4));
+  EXPECT_THAT(output, ElementsAre(1, 3, 0, 3, 2));
+
+  Int ints[] = {3, 1, 2, 0, 4};
+  Int outs[] = {0, 0, 0};
+  EXPECT_EQ(outs + 3, ranges::partial_sort_copy(ints, outs, {}, &Int::value,
+                                                &Int::value));
+  EXPECT_THAT(ints, ElementsAre(3, 1, 2, 0, 4));
+  EXPECT_THAT(outs, ElementsAre(0, 1, 2));
+
+  EXPECT_EQ(outs + 3, ranges::partial_sort_copy(ints, outs, ranges::greater(),
+                                                &Int::value, &Int::value));
+  EXPECT_THAT(ints, ElementsAre(3, 1, 2, 0, 4));
+  EXPECT_THAT(outs, ElementsAre(4, 3, 2));
+
+  EXPECT_EQ(outs + 3,
+            ranges::partial_sort_copy(input, outs, {}, {}, &Int::value));
+}
+
+TEST(RangesTest, IsSorted) {
+  constexpr int input[] = {3, 1, 2, 0, 4};
+  static_assert(ranges::is_sorted(input + 1, input + 3), "");
+  static_assert(!ranges::is_sorted(input + 1, input + 4), "");
+  static_assert(ranges::is_sorted(input, input + 2, ranges::greater()), "");
+
+  constexpr Int ints[] = {0, 1, 2, 3, 4};
+  static_assert(ranges::is_sorted(ints, {}, &Int::value), "");
+  static_assert(!ranges::is_sorted(ints, ranges::greater(), &Int::value), "");
+}
+
+TEST(RangesTest, IsSortedUntil) {
+  constexpr int input[] = {3, 1, 2, 0, 4};
+  static_assert(input + 3 == ranges::is_sorted_until(input + 1, input + 3), "");
+  static_assert(input + 3 == ranges::is_sorted_until(input + 1, input + 4), "");
+  static_assert(
+      input + 2 == ranges::is_sorted_until(input, input + 2, ranges::greater()),
+      "");
+
+  constexpr Int ints[] = {0, 1, 2, 3, 4};
+  static_assert(ints + 5 == ranges::is_sorted_until(ints, {}, &Int::value), "");
+  static_assert(
+      ints + 1 == ranges::is_sorted_until(ints, ranges::greater(), &Int::value),
+      "");
+}
+
+TEST(RangesTest, NthElement) {
+  int input[] = {3, 1, 2, 0, 4};
+  EXPECT_EQ(input + 5, ranges::nth_element(input, input + 2, input + 5));
+  EXPECT_THAT(input, ElementsAre(Lt(2), Lt(2), 2, Gt(2), Gt(2)));
+
+  Int ints[] = {0, 1, 2, 3, 4};
+  EXPECT_EQ(ints + 5, ranges::nth_element(ints, ints + 2, ranges::greater(),
+                                          &Int::value));
+  EXPECT_THAT(ints, ElementsAre(Gt(2), Gt(2), 2, Lt(2), Lt(2)));
+}
+
+TEST(RangesTest, LowerBound) {
+  int array[] = {0, 0, 1, 1, 2, 2};
+
+  EXPECT_EQ(array, ranges::lower_bound(array, array + 6, -1));
+  EXPECT_EQ(array, ranges::lower_bound(array, array + 6, 0));
+  EXPECT_EQ(array + 2, ranges::lower_bound(array, array + 6, 1));
+  EXPECT_EQ(array + 4, ranges::lower_bound(array, array + 6, 2));
+  EXPECT_EQ(array + 6, ranges::lower_bound(array, array + 6, 3));
+
+  Int ints[] = {0, 0, 1, 1, 2, 2};
+
+  EXPECT_EQ(ints, ranges::lower_bound(ints, -1, {}, &Int::value));
+  EXPECT_EQ(ints, ranges::lower_bound(ints, 0, {}, &Int::value));
+  EXPECT_EQ(ints + 2, ranges::lower_bound(ints, 1, {}, &Int::value));
+  EXPECT_EQ(ints + 4, ranges::lower_bound(ints, 2, {}, &Int::value));
+  EXPECT_EQ(ints + 6, ranges::lower_bound(ints, 3, {}, &Int::value));
+
+  const auto proj = [](const Int& i) { return 2 - i.value; };
+  EXPECT_EQ(ints, ranges::lower_bound(ints, 3, ranges::greater{}, proj));
+  EXPECT_EQ(ints, ranges::lower_bound(ints, 2, ranges::greater{}, proj));
+  EXPECT_EQ(ints + 2, ranges::lower_bound(ints, 1, ranges::greater{}, proj));
+  EXPECT_EQ(ints + 4, ranges::lower_bound(ints, 0, ranges::greater{}, proj));
+  EXPECT_EQ(ints + 6, ranges::lower_bound(ints, -1, ranges::greater{}, proj));
+}
+
+TEST(RangesTest, UpperBound) {
+  int array[] = {0, 0, 1, 1, 2, 2};
+
+  EXPECT_EQ(array, ranges::upper_bound(array, array + 6, -1));
+  EXPECT_EQ(array + 2, ranges::upper_bound(array, array + 6, 0));
+  EXPECT_EQ(array + 4, ranges::upper_bound(array, array + 6, 1));
+  EXPECT_EQ(array + 6, ranges::upper_bound(array, array + 6, 2));
+  EXPECT_EQ(array + 6, ranges::upper_bound(array, array + 6, 3));
+
+  Int ints[] = {0, 0, 1, 1, 2, 2};
+
+  EXPECT_EQ(ints, ranges::upper_bound(ints, -1, {}, &Int::value));
+  EXPECT_EQ(ints + 2, ranges::upper_bound(ints, 0, {}, &Int::value));
+  EXPECT_EQ(ints + 4, ranges::upper_bound(ints, 1, {}, &Int::value));
+  EXPECT_EQ(ints + 6, ranges::upper_bound(ints, 2, {}, &Int::value));
+  EXPECT_EQ(ints + 6, ranges::upper_bound(ints, 3, {}, &Int::value));
+
+  const auto proj = [](const Int& i) { return 2 - i.value; };
+  EXPECT_EQ(ints, ranges::upper_bound(ints, 3, ranges::greater{}, proj));
+  EXPECT_EQ(ints + 2, ranges::upper_bound(ints, 2, ranges::greater{}, proj));
+  EXPECT_EQ(ints + 4, ranges::upper_bound(ints, 1, ranges::greater{}, proj));
+  EXPECT_EQ(ints + 6, ranges::upper_bound(ints, 0, ranges::greater{}, proj));
+  EXPECT_EQ(ints + 6, ranges::upper_bound(ints, -1, ranges::greater{}, proj));
+}
+
+TEST(RangesTest, EqualRange) {
+  int array[] = {0, 0, 1, 1, 2, 2};
+
+  EXPECT_THAT(ranges::equal_range(array, array + 6, -1), Pair(array, array));
+  EXPECT_THAT(ranges::equal_range(array, array + 6, 0), Pair(array, array + 2));
+  EXPECT_THAT(ranges::equal_range(array, array + 6, 1),
+              Pair(array + 2, array + 4));
+  EXPECT_THAT(ranges::equal_range(array, array + 6, 2),
+              Pair(array + 4, array + 6));
+  EXPECT_THAT(ranges::equal_range(array, array + 6, 3),
+              Pair(array + 6, array + 6));
+
+  Int ints[] = {0, 0, 1, 1, 2, 2};
+
+  EXPECT_THAT(ranges::equal_range(ints, -1, {}, &Int::value), Pair(ints, ints));
+  EXPECT_THAT(ranges::equal_range(ints, 0, {}, &Int::value),
+              Pair(ints, ints + 2));
+  EXPECT_THAT(ranges::equal_range(ints, 1, {}, &Int::value),
+              Pair(ints + 2, ints + 4));
+  EXPECT_THAT(ranges::equal_range(ints, 2, {}, &Int::value),
+              Pair(ints + 4, ints + 6));
+  EXPECT_THAT(ranges::equal_range(ints, 3, {}, &Int::value),
+              Pair(ints + 6, ints + 6));
+
+  const auto proj = [](const Int& i) { return 2 - i.value; };
+  EXPECT_THAT(ranges::equal_range(ints, 3, ranges::greater{}, proj),
+              Pair(ints, ints));
+  EXPECT_THAT(ranges::equal_range(ints, 2, ranges::greater{}, proj),
+              Pair(ints, ints + 2));
+  EXPECT_THAT(ranges::equal_range(ints, 1, ranges::greater{}, proj),
+              Pair(ints + 2, ints + 4));
+  EXPECT_THAT(ranges::equal_range(ints, 0, ranges::greater{}, proj),
+              Pair(ints + 4, ints + 6));
+  EXPECT_THAT(ranges::equal_range(ints, -1, ranges::greater{}, proj),
+              Pair(ints + 6, ints + 6));
+}
+
+TEST(RangesTest, BinarySearch) {
+  int array[] = {0, 0, 1, 1, 2, 2};
+
+  EXPECT_FALSE(ranges::binary_search(array, array + 6, -1));
+  EXPECT_TRUE(ranges::binary_search(array, array + 6, 0));
+  EXPECT_TRUE(ranges::binary_search(array, array + 6, 1));
+  EXPECT_TRUE(ranges::binary_search(array, array + 6, 2));
+  EXPECT_FALSE(ranges::binary_search(array, array + 6, 3));
+
+  Int ints[] = {0, 0, 1, 1, 2, 2};
+
+  EXPECT_FALSE(ranges::binary_search(ints, -1, {}, &Int::value));
+  EXPECT_TRUE(ranges::binary_search(ints, 0, {}, &Int::value));
+  EXPECT_TRUE(ranges::binary_search(ints, 1, {}, &Int::value));
+  EXPECT_TRUE(ranges::binary_search(ints, 2, {}, &Int::value));
+  EXPECT_FALSE(ranges::binary_search(ints, 3, {}, &Int::value));
+
+  const auto proj = [](const Int& i) { return 2 - i.value; };
+  EXPECT_FALSE(ranges::binary_search(ints, 3, ranges::greater{}, proj));
+  EXPECT_TRUE(ranges::binary_search(ints, 2, ranges::greater{}, proj));
+  EXPECT_TRUE(ranges::binary_search(ints, 1, ranges::greater{}, proj));
+  EXPECT_TRUE(ranges::binary_search(ints, 0, ranges::greater{}, proj));
+  EXPECT_FALSE(ranges::binary_search(ints, -1, ranges::greater{}, proj));
+}
+
+TEST(RangesTest, IsPartitioned) {
+  int input[] = {1, 3, 5, 0, 4, 2};
+  EXPECT_TRUE(ranges::is_partitioned(input, input, is_odd));
+  EXPECT_TRUE(ranges::is_partitioned(input, input + 6, is_odd));
+  EXPECT_TRUE(ranges::is_partitioned(input, input, is_even));
+  EXPECT_FALSE(ranges::is_partitioned(input, input + 6, is_even));
+
+  Int ints[] = {1, 0, 4, 3, 2};
+  auto lt_2 = [](const Int& i) { return i.value < 2; };
+  EXPECT_TRUE(ranges::is_partitioned(ints, lt_2, &Int::value));
+}
+
+TEST(RangesTest, Partition) {
+  int input[] = {3, 1, 2, 0, 4};
+  EXPECT_EQ(input + 3, ranges::partition(input, input + 5, is_even));
+  EXPECT_TRUE(is_even(input[0]));
+  EXPECT_TRUE(is_even(input[1]));
+  EXPECT_TRUE(is_even(input[2]));
+  EXPECT_TRUE(is_odd(input[3]));
+  EXPECT_TRUE(is_odd(input[4]));
+
+  Int ints[] = {6, 7, 9, 8, 5};
+  EXPECT_EQ(ints + 3, ranges::partition(ints, is_odd, &Int::value));
+  EXPECT_TRUE(is_odd(ints[0].value));
+  EXPECT_TRUE(is_odd(ints[1].value));
+  EXPECT_TRUE(is_odd(ints[2].value));
+  EXPECT_TRUE(is_even(ints[3].value));
+  EXPECT_TRUE(is_even(ints[4].value));
+}
+
+TEST(RangesTest, StablePartition) {
+  int input[] = {3, 1, 2, 0, 4};
+  EXPECT_EQ(input + 3, ranges::stable_partition(input, input + 5, is_even));
+  EXPECT_THAT(input, ElementsAre(2, 0, 4, 3, 1));
+
+  Int ints[] = {6, 7, 9, 8, 5};
+  EXPECT_EQ(ints + 3, ranges::stable_partition(ints, is_odd, &Int::value));
+  EXPECT_THAT(ints, ElementsAre(7, 9, 5, 6, 8));
+}
+
+TEST(RangesTest, PartitionCopy) {
+  int input[] = {3, 1, 2, 0, 4};
+  int evens[5] = {};
+  int odds[5] = {};
+  EXPECT_THAT(ranges::partition_copy(input, input + 5, evens, odds, is_even),
+              Pair(evens + 3, odds + 2));
+  EXPECT_THAT(input, ElementsAre(3, 1, 2, 0, 4));
+  EXPECT_THAT(evens, ElementsAre(2, 0, 4, 0, 0));
+  EXPECT_THAT(odds, ElementsAre(3, 1, 0, 0, 0));
+
+  Int ints[] = {6, 7, 9, 8, 5};
+  Int odd_ints[5] = {};
+  Int even_ints[5] = {};
+  EXPECT_THAT(
+      ranges::partition_copy(ints, odd_ints, even_ints, is_odd, &Int::value),
+      Pair(odd_ints + 3, even_ints + 2));
+  EXPECT_THAT(ints, ElementsAre(6, 7, 9, 8, 5));
+  EXPECT_THAT(odd_ints, ElementsAre(7, 9, 5, 0, 0));
+  EXPECT_THAT(even_ints, ElementsAre(6, 8, 0, 0, 0));
+}
+
+TEST(RangesTest, PartitionPoint) {
+  int input[] = {1, 3, 5, 0, 4, 2};
+  EXPECT_EQ(input, ranges::partition_point(input, input, is_odd));
+  EXPECT_EQ(input + 3, ranges::partition_point(input, input + 6, is_odd));
+  EXPECT_EQ(input, ranges::partition_point(input, input, is_even));
+
+  Int ints[] = {1, 0, 4, 3, 2};
+  auto lt_2 = [](const Int& i) { return i.value < 2; };
+  EXPECT_EQ(ints + 2, ranges::partition_point(ints, lt_2, &Int::value));
+}
+
+TEST(RangesTest, Merge) {
+  int input1[] = {0, 2, 4, 6, 8};
+  int input2[] = {1, 3, 5, 7, 9};
+  int output[10];
+  EXPECT_EQ(output + 10,
+            ranges::merge(input1, input1 + 5, input2, input2 + 5, output));
+  EXPECT_THAT(output, ElementsAre(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));
+
+  Int ints1[] = {0, 2, 4, 6, 8};
+  Int ints2[] = {1, 3, 5, 7, 9};
+  Int outs[10];
+  EXPECT_EQ(outs + 10,
+            ranges::merge(ints1, ints2, outs, {}, &Int::value, &Int::value));
+  EXPECT_THAT(outs, ElementsAre(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));
+
+  EXPECT_EQ(outs + 10, ranges::merge(input1, ints1, outs, {}, {}, &Int::value));
+  EXPECT_THAT(outs, ElementsAre(0, 0, 2, 2, 4, 4, 6, 6, 8, 8));
+
+  EXPECT_EQ(outs + 10, ranges::merge(ints2, input2, outs, {}, &Int::value, {}));
+  EXPECT_THAT(outs, ElementsAre(1, 1, 3, 3, 5, 5, 7, 7, 9, 9));
+}
+
+TEST(RangesTest, InplaceMerge) {
+  int input[] = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
+  EXPECT_EQ(input + 10, ranges::inplace_merge(input, input + 5, input + 10));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));
+
+  Int ints[] = {8, 6, 4, 2, 0, 9, 7, 5, 3, 1};
+  EXPECT_EQ(ints + 10, ranges::inplace_merge(ints, ints + 5, ranges::greater(),
+                                             &Int::value));
+  EXPECT_THAT(ints, ElementsAre(9, 8, 7, 6, 5, 4, 3, 2, 1, 0));
+}
+
+TEST(RangesTest, Includes) {
+  int evens[] = {0, 2, 4, 6, 8};
+  int odds[] = {1, 3, 5, 7, 9};
+  int fours[] = {0, 4, 8};
+
+  EXPECT_TRUE(ranges::includes(evens, evens + 5, fours, fours + 3));
+  EXPECT_FALSE(ranges::includes(fours, fours + 3, evens, evens + 5));
+  EXPECT_FALSE(ranges::includes(evens, evens + 5, odds, odds + 5));
+  EXPECT_FALSE(ranges::includes(odds, odds + 5, evens, evens + 5));
+
+  Int even_ints[] = {0, 2, 4, 6, 8};
+  Int odd_ints[] = {1, 3, 5, 7, 9};
+
+  EXPECT_TRUE(ranges::includes(even_ints, fours, {}, &Int::value));
+  EXPECT_FALSE(ranges::includes(fours, even_ints, {}, {}, &Int::value));
+  EXPECT_FALSE(
+      ranges::includes(even_ints, odd_ints, {}, &Int::value, &Int::value));
+  EXPECT_FALSE(
+      ranges::includes(odd_ints, even_ints, {}, &Int::value, &Int::value));
+}
+
+TEST(RangesTest, SetUnion) {
+  int evens[] = {0, 2, 4, 6, 8};
+  int odds[] = {1, 3, 5, 7, 9};
+  int fours[] = {0, 4, 8};
+  int result[10];
+
+  EXPECT_EQ(result + 10,
+            ranges::set_union(evens, evens + 5, odds, odds + 5, result));
+  EXPECT_THAT(result, ElementsAre(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));
+
+  EXPECT_EQ(result + 5,
+            ranges::set_union(evens, evens + 5, fours, fours + 3, result));
+  EXPECT_THAT(make_vector(result, result + 5), ElementsAre(0, 2, 4, 6, 8));
+
+  Int even_ints[] = {0, 2, 4, 6, 8};
+  Int odd_ints[] = {1, 3, 5, 7, 9};
+  Int result_ints[10];
+
+  EXPECT_EQ(result_ints + 10,
+            ranges::set_union(even_ints, odd_ints, result_ints, {}, &Int::value,
+                              &Int::value));
+  EXPECT_THAT(result_ints, ElementsAre(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));
+
+  EXPECT_EQ(result_ints + 5,
+            ranges::set_union(even_ints, fours, result_ints, {}, &Int::value));
+  EXPECT_THAT(make_vector(result_ints, result_ints + 5),
+              ElementsAre(0, 2, 4, 6, 8));
+
+  EXPECT_EQ(result_ints + 8, ranges::set_union(fours, odd_ints, result_ints, {},
+                                               {}, &Int::value));
+  EXPECT_THAT(make_vector(result_ints, result_ints + 8),
+              ElementsAre(0, 1, 3, 4, 5, 7, 8, 9));
+}
+
+TEST(RangesTest, SetIntersection) {
+  int evens[] = {0, 2, 4, 6, 8};
+  int odds[] = {1, 3, 5, 7, 9};
+  int fours[] = {0, 4, 8};
+  int result[10];
+
+  EXPECT_EQ(result,
+            ranges::set_intersection(evens, evens + 5, odds, odds + 5, result));
+
+  EXPECT_EQ(result + 3, ranges::set_intersection(evens, evens + 5, fours,
+                                                 fours + 3, result));
+  EXPECT_THAT(make_vector(result, result + 3), ElementsAre(0, 4, 8));
+
+  Int even_ints[] = {0, 2, 4, 6, 8};
+  Int odd_ints[] = {1, 3, 5, 7, 9};
+  Int result_ints[10];
+
+  EXPECT_EQ(result_ints,
+            ranges::set_intersection(even_ints, odd_ints, result_ints, {},
+                                     &Int::value, &Int::value));
+
+  EXPECT_EQ(
+      result_ints + 3,
+      ranges::set_intersection(even_ints, fours, result_ints, {}, &Int::value));
+  EXPECT_THAT(make_vector(result_ints, result_ints + 3), ElementsAre(0, 4, 8));
+
+  EXPECT_EQ(result_ints, ranges::set_intersection(fours, odd_ints, result_ints,
+                                                  {}, {}, &Int::value));
+}
+
+TEST(RangesTest, SetDifference) {
+  int evens[] = {0, 2, 4, 6, 8};
+  int odds[] = {1, 3, 5, 7, 9};
+  int fours[] = {0, 4, 8};
+  int result[5];
+
+  EXPECT_EQ(result + 5,
+            ranges::set_difference(evens, evens + 5, odds, odds + 5, result));
+  EXPECT_THAT(result, ElementsAre(0, 2, 4, 6, 8));
+
+  EXPECT_EQ(result + 2,
+            ranges::set_difference(evens, evens + 5, fours, fours + 3, result));
+  EXPECT_THAT(make_vector(result, result + 2), ElementsAre(2, 6));
+
+  Int even_ints[] = {0, 2, 4, 6, 8};
+  Int odd_ints[] = {1, 3, 5, 7, 9};
+  Int result_ints[5];
+
+  EXPECT_EQ(result_ints + 5,
+            ranges::set_difference(even_ints, odd_ints, result_ints, {},
+                                   &Int::value, &Int::value));
+  EXPECT_THAT(result_ints, ElementsAre(0, 2, 4, 6, 8));
+
+  EXPECT_EQ(
+      result_ints + 2,
+      ranges::set_difference(even_ints, fours, result_ints, {}, &Int::value));
+  EXPECT_THAT(make_vector(result_ints, result_ints + 2), ElementsAre(2, 6));
+
+  EXPECT_EQ(result_ints + 3,
+            ranges::set_difference(fours, odd_ints, result_ints, {}, {},
+                                   &Int::value));
+  EXPECT_THAT(make_vector(result_ints, result_ints + 3), ElementsAre(0, 4, 8));
+}
+
+TEST(RangesTest, SetSymmetricDifference) {
+  int evens[] = {0, 2, 4, 6, 8};
+  int odds[] = {1, 3, 5, 7, 9};
+  int fours[] = {0, 4, 8};
+  int result[10];
+
+  EXPECT_EQ(result + 10, ranges::set_symmetric_difference(
+                             evens, evens + 5, odds, odds + 5, result));
+  EXPECT_THAT(result, ElementsAre(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));
+
+  EXPECT_EQ(result + 2, ranges::set_symmetric_difference(
+                            evens, evens + 5, fours, fours + 3, result));
+  EXPECT_THAT(make_vector(result, result + 2), ElementsAre(2, 6));
+
+  Int even_ints[] = {0, 2, 4, 6, 8};
+  Int odd_ints[] = {1, 3, 5, 7, 9};
+  Int result_ints[10];
+
+  EXPECT_EQ(result_ints + 10,
+            ranges::set_symmetric_difference(even_ints, odd_ints, result_ints,
+                                             {}, &Int::value, &Int::value));
+  EXPECT_THAT(result_ints, ElementsAre(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));
+
+  EXPECT_EQ(result_ints + 2,
+            ranges::set_symmetric_difference(even_ints, fours, result_ints, {},
+                                             &Int::value));
+  EXPECT_THAT(make_vector(result_ints, result_ints + 2), ElementsAre(2, 6));
+
+  EXPECT_EQ(result_ints + 8,
+            ranges::set_symmetric_difference(fours, odd_ints, result_ints, {},
+                                             {}, &Int::value));
+  EXPECT_THAT(make_vector(result_ints, result_ints + 8),
+              ElementsAre(0, 1, 3, 4, 5, 7, 8, 9));
+}
+
+TEST(RangesTest, PushHeap) {
+  int heap[] = {6, 4, 3, 2, 1, 0, 5};
+  EXPECT_EQ(heap + 7, ranges::push_heap(heap, heap + 7));
+  EXPECT_THAT(heap, ElementsAre(6, Ge(4), Ge(4), Le(3), Le(3), Le(3), Le(3)));
+
+  Int heap_int[] = {1, 2, 3, 4, 5, 6, 0};
+  EXPECT_EQ(heap_int + 7,
+            ranges::push_heap(heap_int, ranges::greater(), &Int::value));
+  EXPECT_THAT(heap_int, ElementsAre(0, 2, 1, 4, 5, 6, 3));
+  EXPECT_THAT(heap_int,
+              ElementsAre(0, Le(2), Le(2), Ge(3), Ge(3), Ge(3), Ge(3)));
+}
+
+TEST(RangesTest, PopHeap) {
+  int heap[] = {6, 5, 4, 3, 2, 1, 0};
+  EXPECT_EQ(heap + 7, ranges::pop_heap(heap, heap + 7));
+  EXPECT_THAT(heap, ElementsAre(5, Ge(3), Ge(3), Le(2), Le(2), Le(2), 6));
+
+  Int heap_int[] = {0, 1, 2, 3, 4, 5, 6};
+  EXPECT_EQ(heap_int + 7,
+            ranges::pop_heap(heap_int, ranges::greater(), &Int::value));
+  EXPECT_THAT(heap_int, ElementsAre(1, Le(3), Le(3), Ge(4), Ge(4), Ge(4), 0));
+}
+
+TEST(RangesTest, MakeHeap) {
+  int heap[] = {0, 1, 2, 3, 4, 5, 6};
+  EXPECT_EQ(heap + 7, ranges::make_heap(heap, heap + 7));
+  EXPECT_THAT(heap, ElementsAre(6, Ge(4), Ge(4), Le(3), Le(3), Le(3), Le(3)));
+
+  Int heap_int[] = {6, 5, 4, 3, 2, 1, 0};
+  EXPECT_EQ(heap_int + 7,
+            ranges::make_heap(heap_int, ranges::greater(), &Int::value));
+  EXPECT_THAT(heap_int,
+              ElementsAre(0, Le(2), Le(2), Ge(3), Ge(3), Ge(3), Ge(3)));
+}
+
+TEST(RangesTest, SortHeap) {
+  int heap[] = {6, 4, 5, 0, 1, 2, 3};
+  EXPECT_EQ(heap + 7, ranges::sort_heap(heap, heap + 7));
+  EXPECT_THAT(heap, ElementsAre(0, 1, 2, 3, 4, 5, 6));
+
+  Int heap_int[] = {0, 2, 1, 4, 3, 6, 5};
+  EXPECT_EQ(heap_int + 7,
+            ranges::sort_heap(heap_int, ranges::greater(), &Int::value));
+  EXPECT_THAT(heap_int, ElementsAre(6, 5, 4, 3, 2, 1, 0));
+}
+
+TEST(RangesTest, IsHeap) {
+  int heap[] = {6, 4, 5, 0, 1, 2, 3};
+  EXPECT_TRUE(ranges::is_heap(heap, heap + 7));
+  EXPECT_FALSE(ranges::is_heap(heap, heap + 7, ranges::greater()));
+
+  Int heap_int[] = {0, 2, 1, 4, 3, 6, 5};
+  EXPECT_TRUE(ranges::is_heap(heap_int, ranges::greater(), &Int::value));
+  EXPECT_FALSE(ranges::is_heap(heap_int, {}, &Int::value));
+}
+
+TEST(RangesTest, IsHeapUntil) {
+  int heap[] = {6, 4, 5, 0, 1, 2, 3};
+  EXPECT_EQ(heap + 7, ranges::is_heap_until(heap, heap + 7));
+  EXPECT_EQ(heap + 1, ranges::is_heap_until(heap, heap + 7, ranges::greater()));
+
+  Int heap_int[] = {0, 2, 1, 4, 3, 6, 5};
+  EXPECT_EQ(heap_int + 7,
+            ranges::is_heap_until(heap_int, ranges::greater(), &Int::value));
+  EXPECT_EQ(heap_int + 1, ranges::is_heap_until(heap_int, {}, &Int::value));
+}
+
+TEST(RangesTest, Min) {
+  constexpr int k1 = 1;
+  constexpr int k2 = 2;
+  static_assert(&ranges::min(k1, k1) == &k1, "");
+  static_assert(&ranges::min(k1, k2) == &k1, "");
+  static_assert(&ranges::min(k2, k1) == &k1, "");
+  static_assert(&ranges::min(k2, k2) == &k2, "");
+
+  constexpr Int k3 = 3;
+  constexpr Int k4 = 4;
+  static_assert(&ranges::min(k3, k3, ranges::greater(), &Int::value) == &k3,
+                "");
+  static_assert(&ranges::min(k3, k4, ranges::greater(), &Int::value) == &k4,
+                "");
+  static_assert(&ranges::min(k4, k3, ranges::greater(), &Int::value) == &k4,
+                "");
+  static_assert(&ranges::min(k4, k4, ranges::greater(), &Int::value) == &k4,
+                "");
+
+  constexpr Int array[] = {2, 6, 4, 3, 5, 1};
+  static_assert(ranges::min({5, 3, 4, 2, 1, 6}) == 1, "");
+  static_assert(ranges::min(array, ranges::greater(), &Int::value) == 6, "");
+}
+
+TEST(RangesTest, Max) {
+  constexpr int k1 = 1;
+  constexpr int k2 = 2;
+  static_assert(&ranges::max(k1, k2) == &k2, "");
+  static_assert(&ranges::max(k1, k2) == &k2, "");
+  static_assert(&ranges::max(k2, k1) == &k2, "");
+  static_assert(&ranges::max(k2, k1) == &k2, "");
+
+  constexpr Int k3 = 3;
+  constexpr Int k4 = 4;
+  static_assert(&ranges::max(k3, k3, ranges::greater(), &Int::value) == &k3,
+                "");
+  static_assert(&ranges::max(k3, k4, ranges::greater(), &Int::value) == &k3,
+                "");
+  static_assert(&ranges::max(k4, k3, ranges::greater(), &Int::value) == &k3,
+                "");
+  static_assert(&ranges::max(k4, k4, ranges::greater(), &Int::value) == &k4,
+                "");
+
+  constexpr Int array[] = {2, 6, 4, 3, 5, 1};
+  static_assert(ranges::max({5, 3, 4, 2, 1, 6}) == 6, "");
+  static_assert(ranges::max(array, ranges::greater(), &Int::value) == 1, "");
+}
+
+TEST(RangesTest, Minmax) {
+  constexpr int k1 = 1;
+  constexpr int k2 = 2;
+  static_assert(&ranges::minmax(k1, k1).first == &k1, "");
+  static_assert(&ranges::minmax(k1, k1).second == &k1, "");
+  static_assert(&ranges::minmax(k1, k2).first == &k1, "");
+  static_assert(&ranges::minmax(k1, k2).second == &k2, "");
+  static_assert(&ranges::minmax(k2, k1).first == &k1, "");
+  static_assert(&ranges::minmax(k2, k1).second == &k2, "");
+  static_assert(&ranges::minmax(k2, k2).first == &k2, "");
+  static_assert(&ranges::minmax(k2, k2).second == &k2, "");
+
+  static constexpr Int k3 = 3;
+  static constexpr Int k4 = 4;
+  {
+    constexpr auto kResult =
+        ranges::minmax(k3, k3, ranges::greater(), &Int::value);
+    static_assert(&kResult.first == &k3, "");
+    static_assert(&kResult.second == &k3, "");
+  }
+  {
+    constexpr auto kResult =
+        ranges::minmax(k3, k4, ranges::greater(), &Int::value);
+    static_assert(&kResult.first == &k4, "");
+    static_assert(&kResult.second == &k3, "");
+  }
+  {
+    constexpr auto kResult =
+        ranges::minmax(k4, k3, ranges::greater(), &Int::value);
+    static_assert(&kResult.first == &k4, "");
+    static_assert(&kResult.second == &k3, "");
+  }
+  {
+    constexpr auto kResult =
+        ranges::minmax(k4, k4, ranges::greater(), &Int::value);
+    static_assert(&kResult.first == &k4, "");
+    static_assert(&kResult.second == &k4, "");
+  }
+
+  static_assert(ranges::minmax({5, 3, 4, 2, 1, 6}).first == 1, "");
+  static_assert(ranges::minmax({5, 3, 4, 2, 1, 6}).second == 6, "");
+
+  constexpr Int array[] = {2, 6, 4, 3, 5, 1};
+  static_assert(
+      ranges::minmax(array, ranges::greater(), &Int::value).first == 6, "");
+  static_assert(
+      ranges::minmax(array, ranges::greater(), &Int::value).second == 1, "");
+}
+
+TEST(RangesTest, MinElement) {
+  constexpr int array[] = {2, 6, 4, 3, 5, 1};
+  constexpr Int ints[] = {2, 6, 4, 3, 5, 1};
+  static_assert(*ranges::min_element(array, array + 6) == 1, "");
+  static_assert(*ranges::min_element(ints, ranges::greater(), &Int::value) == 6,
+                "");
+}
+
+TEST(RangesTest, MaxElement) {
+  constexpr int array[] = {2, 6, 4, 3, 5, 1};
+  constexpr Int ints[] = {2, 6, 4, 3, 5, 1};
+  static_assert(*ranges::max_element(array, array + 6) == 6, "");
+  static_assert(*ranges::max_element(ints, ranges::greater(), &Int::value) == 1,
+                "");
+}
+
+TEST(RangesTest, MinmaxElement) {
+  constexpr int array[] = {2, 6, 4, 3, 5, 1};
+  static_assert(*ranges::minmax_element(array, array + 6).first == 1, "");
+  static_assert(*ranges::minmax_element(array, array + 6).second == 6, "");
+
+  constexpr Int ints[] = {2, 6, 4, 3, 5, 1};
+  static_assert(
+      *ranges::minmax_element(ints, ranges::greater(), &Int::value).first == 6,
+      "");
+  static_assert(
+      *ranges::minmax_element(ints, ranges::greater(), &Int::value).second == 1,
+      "");
+}
+
+TEST(RangesTest, Clamp) {
+  constexpr int k1 = 1;
+  constexpr int k2 = 2;
+  constexpr int k3 = 3;
+
+  static_assert(&ranges::clamp(k1, k1, k1) == &k1, "");
+  static_assert(&ranges::clamp(k1, k1, k2) == &k1, "");
+  static_assert(&ranges::clamp(k1, k1, k3) == &k1, "");
+  static_assert(&ranges::clamp(k1, k2, k2) == &k2, "");
+  static_assert(&ranges::clamp(k1, k2, k3) == &k2, "");
+  static_assert(&ranges::clamp(k1, k3, k3) == &k3, "");
+
+  static_assert(&ranges::clamp(k2, k1, k1) == &k1, "");
+  static_assert(&ranges::clamp(k2, k1, k2) == &k2, "");
+  static_assert(&ranges::clamp(k2, k1, k3) == &k2, "");
+  static_assert(&ranges::clamp(k2, k2, k2) == &k2, "");
+  static_assert(&ranges::clamp(k2, k2, k3) == &k2, "");
+  static_assert(&ranges::clamp(k2, k3, k3) == &k3, "");
+
+  static_assert(&ranges::clamp(k3, k1, k1) == &k1, "");
+  static_assert(&ranges::clamp(k3, k1, k2) == &k2, "");
+  static_assert(&ranges::clamp(k3, k1, k3) == &k3, "");
+  static_assert(&ranges::clamp(k3, k2, k2) == &k2, "");
+  static_assert(&ranges::clamp(k3, k2, k3) == &k3, "");
+  static_assert(&ranges::clamp(k3, k3, k3) == &k3, "");
+
+  constexpr Int k4 = 4;
+  constexpr Int k5 = 5;
+  constexpr Int k6 = 6;
+
+  static_assert(
+      &ranges::clamp(k6, k6, k6, ranges::greater(), &Int::value) == &k6, "");
+  static_assert(
+      &ranges::clamp(k6, k6, k5, ranges::greater(), &Int::value) == &k6, "");
+  static_assert(
+      &ranges::clamp(k6, k6, k4, ranges::greater(), &Int::value) == &k6, "");
+  static_assert(
+      &ranges::clamp(k6, k5, k5, ranges::greater(), &Int::value) == &k5, "");
+  static_assert(
+      &ranges::clamp(k6, k5, k4, ranges::greater(), &Int::value) == &k5, "");
+  static_assert(
+      &ranges::clamp(k6, k4, k4, ranges::greater(), &Int::value) == &k4, "");
+
+  static_assert(
+      &ranges::clamp(k5, k6, k6, ranges::greater(), &Int::value) == &k6, "");
+  static_assert(
+      &ranges::clamp(k5, k6, k5, ranges::greater(), &Int::value) == &k5, "");
+  static_assert(
+      &ranges::clamp(k5, k6, k4, ranges::greater(), &Int::value) == &k5, "");
+  static_assert(
+      &ranges::clamp(k5, k5, k5, ranges::greater(), &Int::value) == &k5, "");
+  static_assert(
+      &ranges::clamp(k5, k5, k4, ranges::greater(), &Int::value) == &k5, "");
+  static_assert(
+      &ranges::clamp(k5, k4, k4, ranges::greater(), &Int::value) == &k4, "");
+
+  static_assert(
+      &ranges::clamp(k4, k6, k6, ranges::greater(), &Int::value) == &k6, "");
+  static_assert(
+      &ranges::clamp(k4, k6, k5, ranges::greater(), &Int::value) == &k5, "");
+  static_assert(
+      &ranges::clamp(k4, k6, k4, ranges::greater(), &Int::value) == &k4, "");
+  static_assert(
+      &ranges::clamp(k4, k5, k5, ranges::greater(), &Int::value) == &k5, "");
+  static_assert(
+      &ranges::clamp(k4, k5, k4, ranges::greater(), &Int::value) == &k4, "");
+  static_assert(
+      &ranges::clamp(k4, k4, k4, ranges::greater(), &Int::value) == &k4, "");
+}
+
+TEST(RangesTest, LexicographicalCompare) {
+  constexpr int inputs1[] = {0, 1, 2, 3, 4, 5};
+  constexpr int inputs2[] = {0, 1, 2, 3, 5, 4};
+  static_assert(!ranges::lexicographical_compare(inputs1, inputs1 + 6, inputs1,
+                                                 inputs1 + 6),
+                "");
+  static_assert(ranges::lexicographical_compare(inputs1, inputs1 + 6, inputs2,
+                                                inputs2 + 6),
+                "");
+  static_assert(!ranges::lexicographical_compare(inputs2, inputs2 + 6, inputs1,
+                                                 inputs1 + 6),
+                "");
+  static_assert(!ranges::lexicographical_compare(inputs2, inputs2 + 6, inputs2,
+                                                 inputs2 + 6),
+                "");
+
+  constexpr Int ints1[] = {0, 1, 2, 3, 4, 5};
+  constexpr Int ints2[] = {5, 4, 3, 2, 1, 0};
+  static_assert(
+      !ranges::lexicographical_compare(inputs1, ints1, {}, {}, &Int::value),
+      "");
+  static_assert(
+      !ranges::lexicographical_compare(ints1, inputs1, {}, &Int::value), "");
+
+  static_assert(
+      !ranges::lexicographical_compare(inputs2, ints1, {}, {}, &Int::value),
+      "");
+  static_assert(
+      ranges::lexicographical_compare(ints1, inputs2, {}, &Int::value), "");
+
+  static_assert(ranges::lexicographical_compare(ints1, ints2, {}, &Int::value,
+                                                &Int::value),
+                "");
+  static_assert(!ranges::lexicographical_compare(ints2, ints1, {}, &Int::value,
+                                                 &Int::value),
+                "");
+
+  static_assert(!ranges::lexicographical_compare(
+                    ints1, ints2, ranges::greater(), &Int::value, &Int::value),
+                "");
+  static_assert(ranges::lexicographical_compare(ints2, ints1, ranges::greater(),
+                                                &Int::value, &Int::value),
+                "");
+
+  using List = std::initializer_list<int>;
+  static_assert(
+      ranges::lexicographical_compare(List{0, 1, 2}, List{0, 1, 2, 3}), "");
+  static_assert(
+      !ranges::lexicographical_compare(List{0, 1, 2, 3}, List{0, 1, 2}), "");
+  static_assert(
+      ranges::lexicographical_compare(List{0, 1, 2, 3}, List{0, 1, 2, 4}), "");
+  static_assert(
+      !ranges::lexicographical_compare(List{0, 1, 2, 4}, List{0, 1, 2, 3}), "");
+}
+
+TEST(RangesTest, NextPermutation) {
+  int input[] = {5, 4, 3, 2, 0, 1};
+  EXPECT_TRUE(ranges::next_permutation(input, input + 6));
+  EXPECT_THAT(input, ElementsAre(5, 4, 3, 2, 1, 0));
+
+  EXPECT_FALSE(ranges::next_permutation(input, input + 6));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4, 5));
+
+  Int ints[] = {0, 1, 2, 3, 5, 4};
+  EXPECT_TRUE(ranges::next_permutation(ints, ranges::greater(), &Int::value));
+  EXPECT_THAT(ints, ElementsAre(0, 1, 2, 3, 4, 5));
+
+  EXPECT_FALSE(ranges::next_permutation(ints, ranges::greater(), &Int::value));
+  EXPECT_THAT(ints, ElementsAre(5, 4, 3, 2, 1, 0));
+
+  int bits[] = {0, 0, 1, 0, 0};
+  EXPECT_TRUE(ranges::next_permutation(bits));
+  EXPECT_THAT(bits, ElementsAre(0, 1, 0, 0, 0));
+}
+
+TEST(RangesTest, PrevPermutation) {
+  int input[] = {0, 1, 2, 3, 5, 4};
+  EXPECT_TRUE(ranges::prev_permutation(input, input + 6));
+  EXPECT_THAT(input, ElementsAre(0, 1, 2, 3, 4, 5));
+
+  EXPECT_FALSE(ranges::prev_permutation(input, input + 6));
+  EXPECT_THAT(input, ElementsAre(5, 4, 3, 2, 1, 0));
+
+  Int ints[] = {5, 4, 3, 2, 0, 1};
+  EXPECT_TRUE(ranges::prev_permutation(ints, ranges::greater(), &Int::value));
+  EXPECT_THAT(ints, ElementsAre(5, 4, 3, 2, 1, 0));
+
+  EXPECT_FALSE(ranges::prev_permutation(ints, ranges::greater(), &Int::value));
+  EXPECT_THAT(ints, ElementsAre(0, 1, 2, 3, 4, 5));
+
+  int bits[] = {0, 0, 1, 0, 0};
+  EXPECT_TRUE(ranges::prev_permutation(bits));
+  EXPECT_THAT(bits, ElementsAre(0, 0, 0, 1, 0));
+}
+
+namespace internal {
+struct TestPair {
+  int a;
+  int b;
+};
+}  // namespace internal
+
+}  // namespace base
diff --git a/base/ranges/functional.h b/base/ranges/functional.h
index 29ac1237b50c3..dc3a812443064 100644
--- a/base/ranges/functional.h
+++ b/base/ranges/functional.h
@@ -6,9 +6,18 @@
 #define BASE_RANGES_FUNCTIONAL_H_
 
 #include <functional>
+#include <type_traits>
+#include <utility>
 
-namespace base::ranges {
+namespace base {
 
+namespace ranges {
+
+// Simplified implementations of C++20's std::ranges comparison function
+// objects. As opposed to the std::ranges implementation, these versions do not
+// constrain the passed-in types.
+//
+// Reference: https://wg21.link/range.cmp
 using equal_to = std::equal_to<>;
 using not_equal_to = std::not_equal_to<>;
 using greater = std::greater<>;
@@ -16,6 +25,8 @@ using less = std::less<>;
 using greater_equal = std::greater_equal<>;
 using less_equal = std::less_equal<>;
 
-}  // namespace base::ranges
+}  // namespace ranges
+
+}  // namespace base
 
 #endif  // BASE_RANGES_FUNCTIONAL_H_
diff --git a/base/ranges/ranges.h b/base/ranges/ranges.h
index dfe754837aed0..b8ba4e6b74c4e 100644
--- a/base/ranges/ranges.h
+++ b/base/ranges/ranges.h
@@ -2,17 +2,32 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/40284755): Remove this and spanify to fix the errors.
+#pragma allow_unsafe_buffers
+#endif
+
 #ifndef BASE_RANGES_RANGES_H_
 #define BASE_RANGES_RANGES_H_
 
-#include <ranges>
+#include <array>
+#include <iterator>
+#include <type_traits>
+#include <utility>
 
 namespace base::ranges {
 
+// Implementation of C++20's std::ranges::iterator_t.
+//
+// Reference: https://wg21.link/ranges.syn#:~:text=iterator_t
 template <typename Range>
-using iterator_t = std::ranges::iterator_t<Range>;
+using iterator_t = decltype(std::begin(std::declval<Range&>()));
+
+// Implementation of C++20's std::ranges::range_value_t.
+//
+// Reference: https://wg21.link/ranges.syn#:~:text=range_value_t
 template <typename Range>
-using range_value_t = std::ranges::range_value_t<Range>;
+using range_value_t = std::iter_value_t<iterator_t<Range>>;
 
 }  // namespace base::ranges
 
