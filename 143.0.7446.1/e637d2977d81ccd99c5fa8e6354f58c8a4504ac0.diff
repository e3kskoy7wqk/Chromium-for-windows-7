diff --git a/ash/BUILD.gn b/ash/BUILD.gn
index 80eb4341d6624..9e288de68ca10 100644
--- a/ash/BUILD.gn
+++ b/ash/BUILD.gn
@@ -5484,7 +5484,6 @@ static_library("test_support") {
     "//ui/message_center",
     "//ui/message_center/public/cpp",
     "//ui/native_theme",
-    "//ui/native_theme:test_support",
     "//ui/ozone",
     "//ui/platform_window/common",
     "//ui/shell_dialogs",
diff --git a/ash/style/color_palette_controller.cc b/ash/style/color_palette_controller.cc
index ad1ea5548a364..85f4505cb7485 100644
--- a/ash/style/color_palette_controller.cc
+++ b/ash/style/color_palette_controller.cc
@@ -44,8 +44,6 @@
 #include "ui/color/dynamic_color/palette.h"
 #include "ui/color/dynamic_color/palette_factory.h"
 #include "ui/gfx/color_palette.h"
-#include "ui/native_theme/native_theme.h"
-#include "ui/native_theme/os_settings_provider_ash.h"
 
 namespace ash {
 
@@ -132,6 +130,32 @@ void SortSampleColorSchemes(
   std::move(callback).Run(sorted_sample_color_schemes);
 }
 
+// Refresh colors of the system on the current color mode. Not only the SysUI,
+// but also all the other components like WebUI. This will trigger
+// View::OnThemeChanged to live update the colors. The colors live update can
+// happen when color mode changes or wallpaper changes. It is needed when
+// wallpaper changes as the background color is calculated from current
+// wallpaper.
+void RefreshNativeTheme(const ColorPaletteSeed& seed) {
+  const SkColor themed_color = seed.seed_color;
+  auto color_scheme = (seed.color_mode == ColorMode::kDark)
+                          ? ui::NativeTheme::PreferredColorScheme::kDark
+                          : ui::NativeTheme::PreferredColorScheme::kLight;
+  auto* native_theme = ui::NativeTheme::GetInstanceForNativeUi();
+  native_theme->set_preferred_color_scheme(color_scheme);
+  native_theme->set_user_color(themed_color);
+  native_theme->set_scheme_variant(ToVariant(seed.scheme));
+  native_theme->NotifyOnNativeThemeUpdated();
+
+  auto* native_theme_web = ui::NativeTheme::GetInstanceForWeb();
+  if (!native_theme_web->IsForcedDarkMode()) {
+    native_theme_web->set_preferred_color_scheme(color_scheme);
+  }
+  native_theme_web->set_scheme_variant(ToVariant(seed.scheme));
+  native_theme_web->set_user_color(themed_color);
+  native_theme_web->NotifyOnNativeThemeUpdated();
+}
+
 class ColorPaletteControllerImpl : public ColorPaletteController,
                                    public WallpaperControllerObserver,
                                    public ColorModeObserver {
@@ -603,14 +627,7 @@ class ColorPaletteControllerImpl : public ColorPaletteController,
       observer.OnColorPaletteChanging(*seed);
     }
 
-    if (auto* const os_settings_provider =
-            ui::OsSettingsProviderAsh::GetInstance()) {
-      os_settings_provider->SetColorPaletteData(
-          (seed->color_mode == ui::ColorProviderKey::ColorMode::kDark)
-              ? ui::NativeTheme::PreferredColorScheme::kDark
-              : ui::NativeTheme::PreferredColorScheme::kLight,
-          seed->seed_color, ToVariant(seed->scheme));
-    }
+    RefreshNativeTheme(*seed);
   }
 
   void OnColorSchemePrefChanged() {
diff --git a/ash/style/color_palette_controller_unittest.cc b/ash/style/color_palette_controller_unittest.cc
index 4d9de73c348fe..79bf45ae95285 100644
--- a/ash/style/color_palette_controller_unittest.cc
+++ b/ash/style/color_palette_controller_unittest.cc
@@ -618,13 +618,6 @@ class ColorPaletteControllerNotificationTest
 
 TEST_F(ColorPaletteControllerNotificationTest,
        OneNotificationOnActiveUserChange) {
-  // When the active user changes below, the `ColorPaletteController` will
-  // attempt to set the `ui::NativeTheme` to light mode. Ensure the
-  // `ui::NativeTheme` is not currently in light mode, or it will not think
-  // anything has actually changed, and elide the call to its observers.
-  ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
-      ui::NativeTheme::PreferredColorScheme::kDark);
-
   // A login should trigger a `ColorPaletteController` update, which in turn
   // should trigger a `ui::NativeTheme` notification.
   TestObserver observer;
@@ -632,9 +625,8 @@ TEST_F(ColorPaletteControllerNotificationTest,
       &observer);
   observation.Observe(ui::NativeTheme::GetInstanceForNativeUi());
   SimulateUserLogin(kAccountId);
-  // Called at least twice. Once for wallpaper update, then for active user pref
-  // change.
-  EXPECT_GE(observer.call_count(), 2);
+  // Called twice. Once for wallpaper update, then for active user pref change.
+  EXPECT_EQ(2, observer.call_count());
 }
 
 class ColorPaletteControllerLocalPrefTest
diff --git a/ash/system/network/network_icon_unittest.cc b/ash/system/network/network_icon_unittest.cc
index f522cc80e71bb..40f1b76e6f921 100644
--- a/ash/system/network/network_icon_unittest.cc
+++ b/ash/system/network/network_icon_unittest.cc
@@ -24,7 +24,6 @@
 #include "third_party/cros_system_api/dbus/shill/dbus-constants.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/gfx/image/image_unittest_util.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
 #include "ui/views/controls/image_view.h"
 
@@ -677,8 +676,6 @@ TEST_F(NetworkIconTest, DefaultNetworkImageVpnAndCellular) {
 // Tests the case of getting the WiFi Enabled state icon when there is
 // no color provider, in which case the window background color is used.
 TEST_F(NetworkIconTest, GetImageModelForWiFiEnabledState) {
-  ui::MockOsSettingsProvider os_settings_provider;
-
   views::ImageView* image_view =
       new views::ImageView(GetImageModelForWiFiEnabledState(true));
   std::unique_ptr<views::Widget> widget = CreateFramelessTestWidget();
@@ -686,12 +683,18 @@ TEST_F(NetworkIconTest, GetImageModelForWiFiEnabledState) {
   widget->SetFullscreen(true);
   widget->SetContentsView(image_view);
 
-  os_settings_provider.SetPreferredColorScheme(
+  auto* const native_theme = ui::NativeTheme::GetInstanceForNativeUi();
+  native_theme->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
+  native_theme->NotifyOnNativeThemeUpdated();
+
   gfx::Image dark_mode_image = gfx::Image(image_view->GetImage());
 
-  os_settings_provider.SetPreferredColorScheme(
+  // Change the color scheme.
+  native_theme->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kLight);
+  native_theme->NotifyOnNativeThemeUpdated();
+
   gfx::Image light_mode_image = gfx::Image(image_view->GetImage());
   EXPECT_FALSE(gfx::test::AreImagesEqual(dark_mode_image, light_mode_image));
 }
diff --git a/ash/test/ash_test_base.cc b/ash/test/ash_test_base.cc
index 37cf737dafacc..366950cdc6255 100644
--- a/ash/test/ash_test_base.cc
+++ b/ash/test/ash_test_base.cc
@@ -81,7 +81,6 @@
 #include "ui/gfx/geometry/point.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/native_theme/native_theme.h"
-#include "ui/native_theme/os_settings_provider_ash.h"
 #include "ui/views/test/test_widget_builder.h"
 #include "ui/views/view.h"
 #include "ui/views/widget/widget.h"
@@ -730,13 +729,10 @@ void AshTestBase::PrepareForPixelDiffTest() {
       switches::kStabilizeTimeDependentViewForTests);
 
   // Use dark mode by default, which is what many gold images expect.
-  ui::OsSettingsProvider::Get();  // Ensure Ash instance is constructed
-  auto* const os_settings_provider = ui::OsSettingsProviderAsh::GetInstance();
-  CHECK(os_settings_provider);
-  os_settings_provider->SetColorPaletteData(
-      ui::NativeTheme::PreferredColorScheme::kDark,
-      os_settings_provider->AccentColor(),
-      os_settings_provider->SchemeVariant());
+  auto* const native_theme = ui::NativeTheme::GetInstanceForNativeUi();
+  native_theme->set_preferred_color_scheme(
+      ui::NativeTheme::PreferredColorScheme::kDark);
+  native_theme->NotifyOnNativeThemeUpdated();
 
   DCHECK(!pixel_differ_);
   pixel_differ_ =
diff --git a/chrome/browser/accessibility/page_colors_controller.cc b/chrome/browser/accessibility/page_colors_controller.cc
index 65e0fe04a9866..4cc406377425c 100644
--- a/chrome/browser/accessibility/page_colors_controller.cc
+++ b/chrome/browser/accessibility/page_colors_controller.cc
@@ -6,24 +6,41 @@
 
 #include "base/containers/fixed_flat_map.h"
 #include "base/types/cxx23_to_underlying.h"
+#include "build/build_config.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/common/pref_names.h"
 #include "components/prefs/pref_registry_simple.h"
 #include "components/prefs/pref_service.h"
-#include "ui/color/color_provider_key.h"
 #include "ui/native_theme/native_theme.h"
 
+#if BUILDFLAG(IS_LINUX)
+#include "ui/linux/linux_ui.h"
+#include "ui/linux/linux_ui_factory.h"
+#endif
+
 namespace {
 
 static constexpr char kPageColors[] = "settings.a11y.page_colors";
 static constexpr char kIsDefaultPageColorsOnHighContrast[] =
     "settings.a11y.is_default_page_colors_on_high_contrast";
 
+ui::NativeTheme* GetNativeTheme() {
+#if BUILDFLAG(IS_LINUX)
+  // Allow the Linux native theme to update its state for page colors.
+  if (auto* linux_ui_theme = ui::GetDefaultLinuxUiTheme()) {
+    if (auto* linux_native_theme = linux_ui_theme->GetNativeTheme()) {
+      return linux_native_theme;
+    }
+  }
+#endif
+  return ui::NativeTheme::GetInstanceForNativeUi();
+}
+
 }  // namespace
 
 PageColorsController::PageColorsController(PrefService* profile_prefs)
     : profile_prefs_(profile_prefs) {
-  theme_observation_.Observe(ui::NativeTheme::GetInstanceForNativeUi());
+  theme_observation_.Observe(GetNativeTheme());
 
   pref_change_registrar_.Init(profile_prefs_);
   pref_change_registrar_.Add(
@@ -80,7 +97,7 @@ void PageColorsController::MigrateObsoleteProfilePrefs(
   profile_prefs->ClearPref(kIsDefaultPageColorsOnHighContrast);
 }
 
-void PageColorsController::OnNativeThemeUpdated(
+void PageColorsController::OnPreferredContrastChanged(
     ui::NativeTheme* observed_theme) {
   RecomputePageColors();
 }
@@ -92,16 +109,23 @@ void PageColorsController::SetRequestedPageColors(PageColors page_colors) {
 }
 
 void PageColorsController::RecomputePageColors() {
-  // Get the current color/contrast values from the native UI theme.
-  const auto* const native_theme = ui::NativeTheme::GetInstanceForNativeUi();
-  ui::ColorProviderKey::ForcedColors forced_colors =
-      native_theme->forced_colors();
-  ui::NativeTheme::PreferredColorScheme preferred_color_scheme =
-      native_theme->preferred_color_scheme();
-  ui::NativeTheme::PreferredContrast preferred_contrast =
-      native_theme->preferred_contrast();
-
-  // Get the requested page colors.
+  auto* native_theme = GetNativeTheme();
+
+  ui::NativeTheme::PageColors previous_page_colors =
+      native_theme->page_colors();
+  ui::NativeTheme::PageColors current_page_colors =
+      CalculatePageColors(*native_theme);
+
+  if (previous_page_colors == current_page_colors) {
+    return;
+  }
+
+  native_theme->set_page_colors(current_page_colors);
+  native_theme->NotifyOnNativeThemeUpdated();
+}
+
+ui::NativeTheme::PageColors PageColorsController::CalculatePageColors(
+    const ui::NativeTheme& native_theme) {
   const int pref_value =
       profile_prefs_->GetInteger(prefs::kRequestedPageColors);
   PageColors page_colors =
@@ -109,58 +133,32 @@ void PageColorsController::RecomputePageColors() {
        pref_value > base::to_underlying(PageColors::kMaxValue))
           ? PageColors::kNoPreference
           : static_cast<PageColors>(pref_value);
-  if (preferred_contrast != ui::NativeTheme::PreferredContrast::kMore &&
-      profile_prefs_->GetBoolean(
-          prefs::kApplyPageColorsOnlyOnIncreasedContrast)) {
+
+  bool only_on_increased_contrast = profile_prefs_->GetBoolean(
+      prefs::kApplyPageColorsOnlyOnIncreasedContrast);
+
+  // The used value of Page Colors should be `kNoPreference` if
+  // kApplyPageColorsOnlyOnIncreasedContrast is true and the OS is not in an
+  // increased contrast mode.
+  if (only_on_increased_contrast &&
+      native_theme.preferred_contrast() !=
+          ui::NativeTheme::PreferredContrast::kMore) {
     page_colors = PageColors::kNoPreference;
   }
 
-  // If there are explicit page colors, change the desired color/contrast values
-  // accordingly.
+  auto used_page_colors = ui::NativeTheme::PageColors::kOff;
   if (page_colors != PageColors::kNoPreference) {
     static constexpr auto kColorMap =
-        base::MakeFixedFlatMap<PageColors, ui::ColorProviderKey::ForcedColors>(
-            {{PageColors::kOff, ui::ColorProviderKey::ForcedColors::kNone},
-             {PageColors::kDusk, ui::ColorProviderKey::ForcedColors::kDusk},
-             {PageColors::kDesert, ui::ColorProviderKey::ForcedColors::kDesert},
-             {PageColors::kNightSky,
-              ui::ColorProviderKey::ForcedColors::kNightSky},
-             {PageColors::kAquatic,
-              ui::ColorProviderKey::ForcedColors::kAquatic},
-             {PageColors::kWhite, ui::ColorProviderKey::ForcedColors::kWhite}});
-    forced_colors = kColorMap.at(page_colors);
-    if (page_colors == PageColors::kOff) {
-      preferred_contrast = ui::NativeTheme::PreferredContrast::kNoPreference;
-    } else {
-      const bool is_dark_theme = page_colors == PageColors::kDusk ||
-                                 page_colors == PageColors::kNightSky ||
-                                 page_colors == PageColors::kAquatic;
-      preferred_color_scheme =
-          is_dark_theme ? ui::NativeTheme::PreferredColorScheme::kDark
-                        : ui::NativeTheme::PreferredColorScheme::kLight;
-      preferred_contrast = ui::NativeTheme::PreferredContrast::kMore;
-    }
-  }
-
-  // Update the web theme with the newly-calculated values and see if anything
-  // changed.
-  auto* const web_theme = ui::NativeTheme::GetInstanceForWeb();
-  bool updated = false;
-  if (web_theme->forced_colors() != forced_colors) {
-    web_theme->set_forced_colors(forced_colors);
-    updated = true;
-  }
-  if (web_theme->preferred_color_scheme() != preferred_color_scheme) {
-    web_theme->set_preferred_color_scheme(preferred_color_scheme);
-    updated = true;
-  }
-  if (web_theme->preferred_contrast() != preferred_contrast) {
-    web_theme->set_preferred_contrast(preferred_contrast);
-    updated = true;
-  }
-
-  // If something changed, notify web theme observers.
-  if (updated) {
-    web_theme->NotifyOnNativeThemeUpdated();
+        base::MakeFixedFlatMap<PageColors, ui::NativeTheme::PageColors>(
+            {{PageColors::kOff, ui::NativeTheme::PageColors::kOff},
+             {PageColors::kDusk, ui::NativeTheme::PageColors::kDusk},
+             {PageColors::kDesert, ui::NativeTheme::PageColors::kDesert},
+             {PageColors::kNightSky, ui::NativeTheme::PageColors::kNightSky},
+             {PageColors::kAquatic, ui::NativeTheme::PageColors::kAquatic},
+             {PageColors::kWhite, ui::NativeTheme::PageColors::kWhite}});
+    used_page_colors = kColorMap.at(page_colors);
+  } else if (native_theme.forced_colors()) {
+    used_page_colors = ui::NativeTheme::PageColors::kHighContrast;
   }
+  return used_page_colors;
 }
diff --git a/chrome/browser/accessibility/page_colors_controller.h b/chrome/browser/accessibility/page_colors_controller.h
index f16191622142a..e59648adbefef 100644
--- a/chrome/browser/accessibility/page_colors_controller.h
+++ b/chrome/browser/accessibility/page_colors_controller.h
@@ -51,7 +51,7 @@ class PageColorsController : public KeyedService,
   static void MigrateObsoleteProfilePrefs(PrefService* profile_prefs);
 
   // ui::NativeThemeObserver:
-  void OnNativeThemeUpdated(ui::NativeTheme* observed_theme) override;
+  void OnPreferredContrastChanged(ui::NativeTheme* observed_theme) override;
 
   // Requests that the web theme base its forced colors on `page_colors`,
   // subject to relevant prefs and native theme state.
@@ -62,6 +62,12 @@ class PageColorsController : public KeyedService,
   // prefs. If anything changed, notifies the web theme's observers.
   void RecomputePageColors();
 
+  // This function makes use of different states such as the
+  // kRequestedPageColors, kApplyPageColorsOnlyOnIncreasedContrast and OS
+  // increased contrast state to calculate the used page colors.
+  ui::NativeTheme::PageColors CalculatePageColors(
+      const ui::NativeTheme& native_theme);
+
   base::ScopedObservation<ui::NativeTheme, ui::NativeThemeObserver>
       theme_observation_{this};
   PrefChangeRegistrar pref_change_registrar_;
diff --git a/chrome/browser/accessibility/page_colors_controller_browsertest.cc b/chrome/browser/accessibility/page_colors_controller_browsertest.cc
index 0bdcf0462e398..b63024306f662 100644
--- a/chrome/browser/accessibility/page_colors_controller_browsertest.cc
+++ b/chrome/browser/accessibility/page_colors_controller_browsertest.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/accessibility/page_colors_controller.h"
 
+#include "build/build_config.h"
 #include "chrome/browser/accessibility/page_colors_controller_factory.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/ui/browser.h"
@@ -11,27 +12,40 @@
 #include "chrome/test/base/in_process_browser_test.h"
 #include "components/prefs/pref_service.h"
 #include "content/public/test/browser_test.h"
-#include "ui/color/color_provider_key.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
 
+#if BUILDFLAG(IS_LINUX)
+#include "ui/linux/linux_ui.h"
+#include "ui/linux/linux_ui_factory.h"
+#endif
+
 class PageColorsControllerBrowserTest : public InProcessBrowserTest {
  public:
-  ui::MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
+  void SetUpOnMainThread() override {
+    ui_native_theme().set_preferred_color_scheme(
+        ui::NativeTheme::PreferredColorScheme::kLight);
+    ui_native_theme().NotifyOnNativeThemeUpdated();
   }
 
- private:
-  ui::MockOsSettingsProvider os_settings_provider_;
+  ui::NativeTheme& ui_native_theme() {
+#if BUILDFLAG(IS_LINUX)
+    // Match PageColorsController::OnPageColorsChanged().
+    if (auto* const linux_ui_theme = ui::GetDefaultLinuxUiTheme()) {
+      if (auto* const linux_native_theme = linux_ui_theme->GetNativeTheme()) {
+        return *linux_native_theme;
+      }
+    }
+#endif
+    return *ui::NativeTheme::GetInstanceForNativeUi();
+  }
 };
 
-// Changing the requested page colors should affect the web theme's forced
-// colors.
+// Changing the requested page colors should affect the web theme.
 IN_PROC_BROWSER_TEST_F(PageColorsControllerBrowserTest, PageColorsChange) {
   PageColorsControllerFactory::GetForProfile(browser()->profile())
       ->SetRequestedPageColors(PageColors::kDusk);
-  EXPECT_EQ(ui::NativeTheme::GetInstanceForWeb()->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kDusk);
+  EXPECT_EQ(ui::NativeTheme::GetInstanceForWeb()->page_colors(),
+            ui::NativeTheme::PageColors::kDusk);
 }
 
 IN_PROC_BROWSER_TEST_F(PageColorsControllerBrowserTest,
@@ -44,29 +58,25 @@ IN_PROC_BROWSER_TEST_F(PageColorsControllerBrowserTest,
       prefs::kApplyPageColorsOnlyOnIncreasedContrast, true);
   PageColorsControllerFactory::GetForProfile(browser()->profile())
       ->SetRequestedPageColors(PageColors::kDusk);
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kNone);
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kOff);
 
   // Once the OS is in increased contrast mode, the requested page colors should
   // be honored.
-  os_settings_provider().SetPreferredContrast(
+  ui_native_theme().SetPreferredContrast(
       ui::NativeTheme::PreferredContrast::kMore);
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kDusk);
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kDusk);
 
   // Switching increased contrast back off should turn forced colors back off
   // since `kApplyPageColorsOnlyOnIncreasedContrast` is still true.
-  os_settings_provider().SetPreferredContrast(
+  ui_native_theme().SetPreferredContrast(
       ui::NativeTheme::PreferredContrast::kNoPreference);
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kNone);
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kOff);
 
   // Setting `kApplyPageColorsOnlyOnIncreasedContrast` to false should lead to
   // honoring the requested page colors.
   browser()->profile()->GetPrefs()->SetBoolean(
       prefs::kApplyPageColorsOnlyOnIncreasedContrast, false);
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kDusk);
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kDusk);
 }
 
 // When page colors change, not only the web theme's forced colors, but also its
@@ -78,8 +88,7 @@ IN_PROC_BROWSER_TEST_F(PageColorsControllerBrowserTest,
       PageColorsControllerFactory::GetForProfile(browser()->profile());
 
   // The web theme should be in a default state.
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kNone);
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kOff);
   EXPECT_EQ(native_theme->preferred_color_scheme(),
             ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_EQ(native_theme->preferred_contrast(),
@@ -88,8 +97,7 @@ IN_PROC_BROWSER_TEST_F(PageColorsControllerBrowserTest,
   // Changing page colors to White should be reflected in the web theme's
   // contrast and color scheme.
   page_colors->SetRequestedPageColors(PageColors::kWhite);
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kWhite);
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kWhite);
   EXPECT_EQ(native_theme->preferred_color_scheme(),
             ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_EQ(native_theme->preferred_contrast(),
@@ -97,8 +105,7 @@ IN_PROC_BROWSER_TEST_F(PageColorsControllerBrowserTest,
 
   // Changing page colors to Dusk should similarly be reflected.
   page_colors->SetRequestedPageColors(PageColors::kDusk);
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kDusk);
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kDusk);
   EXPECT_EQ(native_theme->preferred_color_scheme(),
             ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_EQ(native_theme->preferred_contrast(),
@@ -106,10 +113,17 @@ IN_PROC_BROWSER_TEST_F(PageColorsControllerBrowserTest,
 
   // Changing the UI theme to high contrast should not overwrite the web theme
   // page colors.
-  os_settings_provider().SetPreferredContrast(
+  ui_native_theme().SetPreferredContrast(
       ui::NativeTheme::PreferredContrast::kMore);
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kDusk);
+  // TODO(pkasting): Unconditionally calling `set_forced_colors(true)` here
+  // masks a bug that, without forced colors on, explicitly changing the page
+  // colors to `kOff` below won't properly reduce contrast. This should be fixed
+  // by moving contrast adjustment to the PageColorsController, which can
+  // distinguish between "off" and "no preference". Once this is fixed, the
+  // unsetting of this lower down can also be removed.
+  ui_native_theme().set_forced_colors(true);
+  ui_native_theme().NotifyOnNativeThemeUpdated();
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kDusk);
   EXPECT_EQ(native_theme->preferred_color_scheme(),
             ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_EQ(native_theme->preferred_contrast(),
@@ -118,8 +132,7 @@ IN_PROC_BROWSER_TEST_F(PageColorsControllerBrowserTest,
   // Changing the page colors to Off should reduce the web theme's preferred
   // contrast.
   page_colors->SetRequestedPageColors(PageColors::kOff);
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kNone);
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kOff);
   EXPECT_EQ(native_theme->preferred_color_scheme(),
             ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_EQ(native_theme->preferred_contrast(),
@@ -127,10 +140,10 @@ IN_PROC_BROWSER_TEST_F(PageColorsControllerBrowserTest,
 
   // Changing the UI color scheme should be reflected in the web theme while
   // page colors are Off.
-  os_settings_provider().SetPreferredColorScheme(
+  ui_native_theme().set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kNone);
+  ui_native_theme().NotifyOnNativeThemeUpdated();
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kOff);
   EXPECT_EQ(native_theme->preferred_color_scheme(),
             ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_EQ(native_theme->preferred_contrast(),
@@ -138,9 +151,10 @@ IN_PROC_BROWSER_TEST_F(PageColorsControllerBrowserTest,
 
   // Unsetting the preferred page colors should cause the web theme to reflect
   // the high contrast state of the native theme.
+  ui_native_theme().set_forced_colors(false);
+  ui_native_theme().NotifyOnNativeThemeUpdated();
   page_colors->SetRequestedPageColors(PageColors::kNoPreference);
-  EXPECT_EQ(native_theme->forced_colors(),
-            ui::ColorProviderKey::ForcedColors::kNone);
+  EXPECT_EQ(native_theme->page_colors(), ui::NativeTheme::PageColors::kOff);
   EXPECT_EQ(native_theme->preferred_color_scheme(),
             ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_EQ(native_theme->preferred_contrast(),
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 4227b47a2b691..4c0eb09a4f3c9 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -4101,7 +4101,8 @@ bool ShouldDisableForcedColorsForWebContent(content::WebContents* contents,
   return false;
 }
 
-blink::mojom::PreferredContrast GetPreferredContrast() {
+blink::mojom::PreferredContrast preferred_contrast(
+    const ui::NativeTheme* native_theme) {
   using NC = ui::NativeTheme::PreferredContrast;
   using BC = blink::mojom::PreferredContrast;
   static constexpr auto kContrastMap =
@@ -4109,14 +4110,13 @@ blink::mojom::PreferredContrast GetPreferredContrast() {
                                       {NC::kMore, BC::kMore},
                                       {NC::kLess, BC::kLess},
                                       {NC::kCustom, BC::kCustom}});
-  return kContrastMap.at(
-      ui::NativeTheme::GetInstanceForWeb()->preferred_contrast());
+  return kContrastMap.at(native_theme->preferred_contrast());
 }
 
-std::tuple<bool, bool> GetForcedColorsForWebContent(WebContents* web_contents) {
-  const bool in_forced_colors =
-      ui::NativeTheme::GetInstanceForWeb()->forced_colors() !=
-      ui::ColorProviderKey::ForcedColors::kNone;
+std::tuple<bool, bool> GetForcedColorsForWebContent(
+    WebContents* web_contents,
+    const ui::NativeTheme* native_theme) {
+  const bool in_forced_colors = native_theme->forced_colors();
   const bool is_forced_colors_disabled =
       ShouldDisableForcedColorsForWebContent(web_contents, in_forced_colors);
   return {in_forced_colors && !is_forced_colors_disabled,
@@ -4137,7 +4137,8 @@ std::tuple<blink::mojom::PreferredColorScheme,
            blink::mojom::PreferredColorScheme>
 GetPreferredColorScheme(const WebPreferences& web_prefs,
                         const GURL& url,
-                        WebContents* web_contents) {
+                        WebContents* web_contents,
+                        const ui::NativeTheme* native_theme) {
 #if BUILDFLAG(IS_ANDROID)
   if (TabAndroid::FromWebContents(web_contents)) {
     if (auto* delegate = static_cast<android::TabWebContentsDelegateAndroid*>(
@@ -4157,8 +4158,8 @@ GetPreferredColorScheme(const WebPreferences& web_prefs,
           ->IsIncognitoProfile() &&
       !content::HasWebUIScheme(url)) {
     // Incognito contents follow the device color mode.
-    preferred_color_scheme = ToBlinkPreferredColorScheme(
-        ui::NativeTheme::GetInstanceForWeb()->preferred_color_scheme());
+    preferred_color_scheme =
+        ToBlinkPreferredColorScheme(native_theme->preferred_color_scheme());
   } else {
     // WebUI and regular pages follow the browser theme color mode, provided by
     // the color provider.
@@ -4809,15 +4810,15 @@ void ChromeContentBrowserClient::OverrideWebPreferences(
       SubAppsAPIsRequireUserGestureAndAuthorization(web_contents);
 #endif  // BUILDFLAG(IS_CHROMEOS)
 
-  web_prefs->preferred_contrast = GetPreferredContrast();
+  web_prefs->preferred_contrast = preferred_contrast(GetWebTheme());
 
   std::tie(web_prefs->in_forced_colors, web_prefs->is_forced_colors_disabled) =
-      GetForcedColorsForWebContent(web_contents);
+      GetForcedColorsForWebContent(web_contents, GetWebTheme());
 
   std::tie(web_prefs->preferred_color_scheme,
            web_prefs->preferred_root_scrollbar_color_scheme) =
       GetPreferredColorScheme(*web_prefs, main_frame_site.GetSiteURL(),
-                              web_contents);
+                              web_contents, GetWebTheme());
 
   web_prefs->root_scrollbar_theme_color =
       GetRootScrollbarThemeColor(web_contents);
@@ -4927,7 +4928,7 @@ bool ChromeContentBrowserClient::OverrideWebPreferencesAfterNavigation(
   const auto old_is_forced_colors_disabled =
       web_prefs->is_forced_colors_disabled;
   std::tie(web_prefs->in_forced_colors, web_prefs->is_forced_colors_disabled) =
-      GetForcedColorsForWebContent(web_contents);
+      GetForcedColorsForWebContent(web_contents, GetWebTheme());
   prefs_changed |=
       web_prefs->in_forced_colors != old_in_forced_colors ||
       web_prefs->is_forced_colors_disabled != old_is_forced_colors_disabled;
@@ -4938,7 +4939,7 @@ bool ChromeContentBrowserClient::OverrideWebPreferencesAfterNavigation(
   std::tie(web_prefs->preferred_color_scheme,
            web_prefs->preferred_root_scrollbar_color_scheme) =
       GetPreferredColorScheme(*web_prefs, main_frame_site.GetSiteURL(),
-                              web_contents);
+                              web_contents, GetWebTheme());
   prefs_changed |=
       web_prefs->preferred_color_scheme != old_preferred_color_scheme ||
       web_prefs->preferred_root_scrollbar_color_scheme !=
@@ -4973,12 +4974,12 @@ bool ChromeContentBrowserClient::
         WebContents& web_contents,
         const SiteInstance& main_frame_site) const {
   const WebPreferences& prefs = web_contents.GetOrCreateWebPreferences();
-  return GetPreferredContrast() != prefs.preferred_contrast ||
-         GetForcedColorsForWebContent(&web_contents) !=
+  return preferred_contrast(GetWebTheme()) != prefs.preferred_contrast ||
+         GetForcedColorsForWebContent(&web_contents, GetWebTheme()) !=
              std::tie(prefs.in_forced_colors,
                       prefs.is_forced_colors_disabled) ||
          GetPreferredColorScheme(prefs, main_frame_site.GetSiteURL(),
-                                 &web_contents) !=
+                                 &web_contents, GetWebTheme()) !=
              std::tie(prefs.preferred_color_scheme,
                       prefs.preferred_root_scrollbar_color_scheme) ||
          GetRootScrollbarThemeColor(&web_contents) !=
@@ -7142,6 +7143,10 @@ bool ChromeContentBrowserClient::HandleWebUIReverse(
          url->GetHost() == chrome::kChromeUISettingsHost;
 }
 
+const ui::NativeTheme* ChromeContentBrowserClient::GetWebTheme() const {
+  return ui::NativeTheme::GetInstanceForWeb();
+}
+
 void ChromeContentBrowserClient::AddExtraPart(
     std::unique_ptr<ChromeContentBrowserClientParts> part) {
   extra_parts_.push_back(std::move(part));
diff --git a/chrome/browser/chrome_content_browser_client.h b/chrome/browser/chrome_content_browser_client.h
index 6d08c913b20f1..7c4f7a6892b9b 100644
--- a/chrome/browser/chrome_content_browser_client.h
+++ b/chrome/browser/chrome_content_browser_client.h
@@ -111,6 +111,10 @@ enum class HashRealTimeSelection;
 }
 }  // namespace safe_browsing
 
+namespace ui {
+class NativeTheme;
+}  // namespace ui
+
 namespace url {
 class Origin;
 }  // namespace url
@@ -1213,6 +1217,7 @@ class ChromeContentBrowserClient : public content::ContentBrowserClient {
   static bool HandleWebUI(GURL* url, content::BrowserContext* browser_context);
   static bool HandleWebUIReverse(GURL* url,
                                  content::BrowserContext* browser_context);
+  virtual const ui::NativeTheme* GetWebTheme() const;  // For testing.
 
   // Used by subclasses (e.g. implemented by downstream embedders) to add
   // their own extra part objects.
diff --git a/chrome/browser/chrome_content_browser_client_browsertest.cc b/chrome/browser/chrome_content_browser_client_browsertest.cc
index 5fd9e59b9b02f..01a55bb2d719d 100644
--- a/chrome/browser/chrome_content_browser_client_browsertest.cc
+++ b/chrome/browser/chrome_content_browser_client_browsertest.cc
@@ -98,8 +98,8 @@
 #include "ui/color/color_provider_manager.h"
 #include "ui/color/color_provider_source.h"
 #include "ui/color/color_provider_utils.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
+#include "ui/native_theme/test_native_theme.h"
 #include "url/gurl.h"
 #include "url/origin.h"
 
@@ -314,6 +314,12 @@ IN_PROC_BROWSER_TEST_F(OpenWindowFromNTPBrowserTest,
 class ForcedColorsTest : public testing::WithParamInterface<bool>,
                          public InProcessBrowserTest {
  protected:
+  ForcedColorsTest() : theme_client_(&test_theme_) {}
+
+  ~ForcedColorsTest() override {
+    CHECK_EQ(&theme_client_, SetBrowserClientForTesting(original_client_));
+  }
+
   static bool ForcedColorsActive() { return GetParam(); }
 
   void SetUpCommandLine(base::CommandLine* command_line) override {
@@ -321,16 +327,36 @@ class ForcedColorsTest : public testing::WithParamInterface<bool>,
                                     "ForcedColors");
   }
 
-  ui::MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
+  void SetUpOnMainThread() override {
+    InProcessBrowserTest::SetUpOnMainThread();
+    original_client_ = SetBrowserClientForTesting(&theme_client_);
   }
 
+ protected:
+  ui::TestNativeTheme test_theme_;
+
  private:
-  ui::MockOsSettingsProvider os_settings_provider_;
+  raw_ptr<content::ContentBrowserClient> original_client_ = nullptr;
+
+  class ChromeContentBrowserClientWithWebTheme
+      : public ChromeContentBrowserClient {
+   public:
+    explicit ChromeContentBrowserClientWithWebTheme(
+        const ui::NativeTheme* theme)
+        : theme_(theme) {}
+
+   protected:
+    const ui::NativeTheme* GetWebTheme() const override { return theme_; }
+
+   private:
+    const raw_ptr<const ui::NativeTheme> theme_;
+  };
+
+  ChromeContentBrowserClientWithWebTheme theme_client_;
 };
 
 IN_PROC_BROWSER_TEST_P(ForcedColorsTest, ForcedColors) {
-  os_settings_provider().SetForcedColorsActive(ForcedColorsActive());
+  test_theme_.set_forced_colors(ForcedColorsActive());
   browser()
       ->tab_strip_model()
       ->GetActiveWebContents()
@@ -346,7 +372,7 @@ IN_PROC_BROWSER_TEST_P(ForcedColorsTest, ForcedColors) {
 }
 
 IN_PROC_BROWSER_TEST_P(ForcedColorsTest, ForcedColorsWithBlockList) {
-  os_settings_provider().SetForcedColorsActive(ForcedColorsActive());
+  test_theme_.set_forced_colors(ForcedColorsActive());
 
   const char* url = "https://foo.com";
   ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GURL(url)));
@@ -441,10 +467,15 @@ class PrefersColorSchemeTest
     : public testing::WithParamInterface<std::tuple<bool, bool>>,
       public InProcessBrowserTest {
  public:
+  ~PrefersColorSchemeTest() override {
+    CHECK_EQ(&theme_client_, SetBrowserClientForTesting(original_client_));
+  }
+
   void SetUpOnMainThread() override {
     InProcessBrowserTest::SetUpOnMainThread();
 
-    os_settings_provider_.SetPreferredColorScheme(
+    original_client_ = SetBrowserClientForTesting(&theme_client_);
+    test_theme_.SetPreferredColorScheme(
         DarkOs() ? ui::NativeTheme::PreferredColorScheme::kDark
                  : ui::NativeTheme::PreferredColorScheme::kLight);
 
@@ -492,7 +523,23 @@ class PrefersColorSchemeTest
     return guest_view_manager_;
   }
 
+  ui::TestNativeTheme test_theme_;
+
  private:
+  class ChromeContentBrowserClientWithWebTheme
+      : public ChromeContentBrowserClient {
+   public:
+    explicit ChromeContentBrowserClientWithWebTheme(
+        const ui::NativeTheme* theme)
+        : theme_(theme) {}
+
+   protected:
+    const ui::NativeTheme* GetWebTheme() const override { return theme_; }
+
+   private:
+    const raw_ptr<const ui::NativeTheme> theme_;
+  };
+
   class MockColorProviderSource : public ui::ColorProviderSource {
    public:
     explicit MockColorProviderSource(bool is_dark) {
@@ -528,7 +575,8 @@ class PrefersColorSchemeTest
   static bool DarkOs() { return std::get<0>(GetParam()); }
   static bool DarkColorProvider() { return std::get<1>(GetParam()); }
 
-  ui::MockOsSettingsProvider os_settings_provider_;
+  raw_ptr<content::ContentBrowserClient> original_client_ = nullptr;
+  ChromeContentBrowserClientWithWebTheme theme_client_{&test_theme_};
   MockColorProviderSource color_provider_source_{DarkColorProvider()};
 #if BUILDFLAG(ENABLE_GLIC)
   glic::GlicTestEnvironment glic_test_environment_;
@@ -622,9 +670,13 @@ class PreferredRootScrollbarColorSchemeChromeClientTest
 
   void SetUpOnMainThread() override {
     InProcessBrowserTest::SetUpOnMainThread();
-    os_settings_provider_.SetPreferredColorScheme(
+    original_client_ = SetBrowserClientForTesting(&theme_client_);
+    const auto color_scheme =
         DarkMode() ? ui::NativeTheme::PreferredColorScheme::kDark
-                   : ui::NativeTheme::PreferredColorScheme::kLight);
+                   : ui::NativeTheme::PreferredColorScheme::kLight;
+    test_theme_.SetPreferredColorScheme(color_scheme);
+    ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
+        color_scheme);
     ThemeService* const theme_service =
         ThemeServiceFactory::GetForProfile(browser()->profile());
     if (UsesCustomTheme()) {
@@ -638,6 +690,10 @@ class PreferredRootScrollbarColorSchemeChromeClientTest
     }
   }
 
+  ~PreferredRootScrollbarColorSchemeChromeClientTest() override {
+    CHECK_EQ(&theme_client_, SetBrowserClientForTesting(original_client_));
+  }
+
  protected:
   blink::mojom::PreferredColorScheme ExpectedColorScheme() const {
     return DarkMode() ? blink::mojom::PreferredColorScheme::kDark
@@ -677,10 +733,26 @@ class PreferredRootScrollbarColorSchemeChromeClientTest
   }
 
  private:
+  class ChromeContentBrowserClientWithWebTheme
+      : public ChromeContentBrowserClient {
+   public:
+    explicit ChromeContentBrowserClientWithWebTheme(
+        const ui::NativeTheme* theme)
+        : theme_(theme) {}
+
+   protected:
+    const ui::NativeTheme* GetWebTheme() const override { return theme_; }
+
+   private:
+    const raw_ptr<const ui::NativeTheme> theme_;
+  };
+
   static bool DarkMode() { return std::get<0>(GetParam()); }
   static bool UsesCustomTheme() { return std::get<1>(GetParam()); }
 
-  ui::MockOsSettingsProvider os_settings_provider_;
+  raw_ptr<content::ContentBrowserClient> original_client_ = nullptr;
+  ui::TestNativeTheme test_theme_;
+  ChromeContentBrowserClientWithWebTheme theme_client_{&test_theme_};
   const SkColor theme_color_;
   base::test::ScopedFeatureList feature_list_;
 };
@@ -721,6 +793,10 @@ class PrefersContrastTest
     : public testing::WithParamInterface<ui::NativeTheme::PreferredContrast>,
       public InProcessBrowserTest {
  public:
+  ~PrefersContrastTest() override {
+    CHECK_EQ(&theme_client_, SetBrowserClientForTesting(original_client_));
+  }
+
   void SetUpCommandLine(base::CommandLine* command_line) override {
     command_line->AppendSwitchASCII(switches::kEnableBlinkFeatures,
                                     "PrefersContrast");
@@ -730,7 +806,12 @@ class PrefersContrastTest
 
   void SetUpOnMainThread() override {
     InProcessBrowserTest::SetUpOnMainThread();
-    os_settings_provider_.SetPreferredContrast(PreferredContrast());
+    original_client_ = SetBrowserClientForTesting(&theme_client_);
+    test_theme_.SetPreferredContrast(PreferredContrast());
+    browser()
+        ->tab_strip_model()
+        ->GetActiveWebContents()
+        ->OnWebPreferencesChanged();
   }
 
  protected:
@@ -747,12 +828,29 @@ class PrefersContrastTest
     }
   }
 
+  ui::TestNativeTheme test_theme_;
+
  private:
+  class ChromeContentBrowserClientWithWebTheme
+      : public ChromeContentBrowserClient {
+   public:
+    explicit ChromeContentBrowserClientWithWebTheme(
+        const ui::NativeTheme* theme)
+        : theme_(theme) {}
+
+   protected:
+    const ui::NativeTheme* GetWebTheme() const override { return theme_; }
+
+   private:
+    const raw_ptr<const ui::NativeTheme> theme_;
+  };
+
   static ui::NativeTheme::PreferredContrast PreferredContrast() {
     return GetParam();
   }
 
-  ui::MockOsSettingsProvider os_settings_provider_;
+  raw_ptr<content::ContentBrowserClient> original_client_ = nullptr;
+  ChromeContentBrowserClientWithWebTheme theme_client_{&test_theme_};
 };
 
 IN_PROC_BROWSER_TEST_P(PrefersContrastTest, PrefersContrast) {
diff --git a/chrome/browser/metrics/desktop_platform_features_metrics_provider.cc b/chrome/browser/metrics/desktop_platform_features_metrics_provider.cc
index d4e2d7a9771d7..1fc8822d37246 100644
--- a/chrome/browser/metrics/desktop_platform_features_metrics_provider.cc
+++ b/chrome/browser/metrics/desktop_platform_features_metrics_provider.cc
@@ -16,7 +16,6 @@
 #include "chrome/browser/ui/browser_list.h"
 #include "components/reading_list/core/reading_list_model.h"
 #include "ui/native_theme/native_theme.h"
-#include "ui/native_theme/os_settings_provider.h"
 
 namespace {
 
@@ -39,7 +38,7 @@ DesktopPlatformFeaturesMetricsProvider::
 void DesktopPlatformFeaturesMetricsProvider::ProvideCurrentSessionData(
     metrics::ChromeUserMetricsExtension* uma_proto) {
   DarkModeStatus status = DarkModeStatus::kUnavailable;
-  if (ui::OsSettingsProvider::Get().DarkColorSchemeAvailable()) {
+  if (ui::NativeTheme::SystemDarkModeSupported()) {
     status =
         (ui::NativeTheme::GetInstanceForNativeUi()->preferred_color_scheme() ==
          ui::NativeTheme::PreferredColorScheme::kDark)
diff --git a/chrome/browser/profiles/profile_attributes_storage_unittest.cc b/chrome/browser/profiles/profile_attributes_storage_unittest.cc
index db006fec4fd5f..7b9b42d22130b 100644
--- a/chrome/browser/profiles/profile_attributes_storage_unittest.cc
+++ b/chrome/browser/profiles/profile_attributes_storage_unittest.cc
@@ -53,7 +53,6 @@
 
 #if !BUILDFLAG(IS_ANDROID)
 #include "chrome/browser/ui/profiles/profile_colors_util.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
 #endif
 
@@ -1691,7 +1690,9 @@ TEST_F(ProfileAttributesStorageTest, ProfilesState_SingleProfile) {
 // Themes aren't used on Android
 #if !BUILDFLAG(IS_ANDROID)
 TEST_F(ProfileAttributesStorageTest, ProfileThemeColors) {
-  ui::MockOsSettingsProvider os_settings_provider;
+  auto* native_theme = ui::NativeTheme::GetInstanceForNativeUi();
+  native_theme->set_preferred_color_scheme(
+      ui::NativeTheme::PreferredColorScheme::kLight);
   AddTestingProfile();
   base::FilePath profile_path = GetProfilePath("testing_profile_path0");
 
@@ -1705,7 +1706,7 @@ TEST_F(ProfileAttributesStorageTest, ProfileThemeColors) {
   ProfileThemeColors light_colors = GetDefaultProfileThemeColors();
   EXPECT_EQ(entry->GetProfileThemeColors(), light_colors);
 
-  os_settings_provider.SetPreferredColorScheme(
+  native_theme->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_EQ(entry->GetProfileThemeColors(), GetDefaultProfileThemeColors());
   EXPECT_NE(entry->GetProfileThemeColors(), light_colors);
@@ -1719,7 +1720,7 @@ TEST_F(ProfileAttributesStorageTest, ProfileThemeColors) {
   VerifyAndResetCallExpectations();
 
   // Colors shouldn't change after switching back to the light mode.
-  os_settings_provider.SetPreferredColorScheme(
+  native_theme->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_EQ(entry->GetProfileThemeColors(), colors);
 
diff --git a/chrome/browser/themes/theme_service_browsertest.cc b/chrome/browser/themes/theme_service_browsertest.cc
index 926e2be9da7d6..b2d0a7db0a45b 100644
--- a/chrome/browser/themes/theme_service_browsertest.cc
+++ b/chrome/browser/themes/theme_service_browsertest.cc
@@ -19,7 +19,7 @@
 #include "content/public/test/test_utils.h"
 #include "ui/base/buildflags.h"
 #include "ui/color/color_provider.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
+#include "ui/native_theme/native_theme.h"
 
 #if BUILDFLAG(IS_LINUX)
 #include "ui/linux/linux_ui.h"
@@ -46,9 +46,6 @@ class ThemeServiceBrowserTest : public extensions::ExtensionBrowserTest {
     extensions::ComponentLoader::EnableBackgroundExtensionsForTesting();
     extensions::ExtensionBrowserTest::SetUp();
   }
-
- private:
-  ui::MockOsSettingsProvider os_settings_provider_;  // Forces light mode.
 };
 
 // Test that the theme is recreated from the extension when the data pack is
@@ -93,6 +90,11 @@ IN_PROC_BROWSER_TEST_F(ThemeServiceBrowserTest, ThemeDataPackInvalid) {
 }
 
 IN_PROC_BROWSER_TEST_F(ThemeServiceBrowserTest, IncognitoTest) {
+  // This test relies on incognito being meaningfully different than default,
+  // which is not currently true in dark mode.
+  ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
+      ui::NativeTheme::PreferredColorScheme::kLight);
+
   // Should get a different ColorProvider for incognito and original windows.
   Browser* incognito_browser = CreateIncognitoBrowser();
   const auto* color_provider = GetColorProviderFor(browser());
@@ -149,12 +151,16 @@ IN_PROC_BROWSER_TEST_F(ThemeServiceBrowserTest,
 }
 
 IN_PROC_BROWSER_TEST_F(ThemeServiceBrowserTest, GetColorForToolbarButton) {
+  // This test relies on toolbar buttons having no tint, which is not currently
+  // true in dark mode.
+  ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
+      ui::NativeTheme::PreferredColorScheme::kLight);
 #if BUILDFLAG(IS_LINUX)
   // This test relies on toolbar buttons having no tint, which is not currently
   // true when using the system theme.
   ui::LinuxUiGetter::set_instance(nullptr);
-  ui::NativeTheme::GetInstanceForNativeUi()->NotifyOnNativeThemeUpdated();
 #endif
+  ui::NativeTheme::GetInstanceForNativeUi()->NotifyOnNativeThemeUpdated();
 
   SkColor default_toolbar_button_color =
       GetColorProviderFor(browser())->GetColor(kColorToolbarButtonIcon);
diff --git a/chrome/browser/themes/theme_service_unittest.cc b/chrome/browser/themes/theme_service_unittest.cc
index ed3a77671043c..91e3a7265108d 100644
--- a/chrome/browser/themes/theme_service_unittest.cc
+++ b/chrome/browser/themes/theme_service_unittest.cc
@@ -5,7 +5,6 @@
 #include "chrome/browser/themes/theme_service.h"
 
 #include <cmath>
-#include <memory>
 
 #include "base/compiler_specific.h"
 #include "base/containers/fixed_flat_map.h"
@@ -14,7 +13,6 @@
 #include "base/memory/scoped_refptr.h"
 #include "base/path_service.h"
 #include "base/run_loop.h"
-#include "base/scoped_observation.h"
 #include "base/strings/strcat.h"
 #include "base/strings/string_util.h"
 #include "base/test/task_environment.h"
@@ -41,7 +39,6 @@
 #include "components/color/color_mixers.h"
 #include "components/sync_preferences/testing_pref_service_syncable.h"
 #include "components/themes/pref_names.h"
-#include "content/public/test/browser_task_environment.h"
 #include "content/public/test/test_utils.h"
 #include "extensions/browser/extension_registrar.h"
 #include "extensions/browser/extension_registry.h"
@@ -57,9 +54,7 @@
 #include "ui/color/color_provider_manager.h"
 #include "ui/gfx/color_palette.h"
 #include "ui/gfx/color_utils.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
-#include "ui/native_theme/native_theme_observer.h"
 
 #if BUILDFLAG(IS_LINUX)
 #include "ui/linux/linux_ui.h"
@@ -133,41 +128,6 @@ class LinuxUiGetterImpl : public ui::LinuxUiGetter {
 
 namespace theme_service_internal {
 
-class ThemeUpdatedTest : public ::testing::Test,
-                         public ::testing::WithParamInterface<SystemTheme> {
- public:
-#if BUILDFLAG(IS_LINUX)
-  // ::testing::Test:
-  void SetUp() override {
-    static bool initialized = false;
-    if (!initialized) {
-      // Ensures LinuxUi is configured on supported linux platforms.
-      auto* const linux_ui = ui::GetDefaultLinuxUi();
-      ASSERT_TRUE(linux_ui);
-      ui::LinuxUi::SetInstance(linux_ui);
-      initialized = true;
-    }
-
-    linux_ui_getter_ =
-        std::make_unique<LinuxUiGetterImpl>(GetParam() == SystemTheme::kCustom);
-  }
-#endif
-
-  Profile* profile() { return &profile_; }
-
- private:
-  content::BrowserTaskEnvironment task_environment_;
-  TestingProfile profile_;
-#if BUILDFLAG(IS_LINUX)
-  std::unique_ptr<ui::LinuxUiGetter> linux_ui_getter_;
-#endif
-};
-
-INSTANTIATE_TEST_SUITE_P(,
-                         ThemeUpdatedTest,
-                         ::testing::Values(SystemTheme::kDefault,
-                                           SystemTheme::kCustom));
-
 class ThemeServiceTest : public extensions::ExtensionServiceTestBase {
  public:
   void SetUp() override {
@@ -255,7 +215,7 @@ class ColorProviderTest : public ThemeServiceTest,
                        ui::NativeTheme::PreferredColorScheme::kDark)
                           ? "Dark"
                           : "Light";
-    if (GetPreferredContrast(param_info.param) ==
+    if (preferred_contrast(param_info.param) ==
         ui::NativeTheme::PreferredContrast::kMore) {
       str += "HighContrast";
     }
@@ -296,12 +256,39 @@ class ColorProviderTest : public ThemeServiceTest,
         GetSystemTheme() == SystemTheme::kCustom);
 #endif  // BUILDFLAG(IS_LINUX)
 
-    os_settings_provider_.SetPreferredColorScheme(GetPreferredColorScheme());
-    os_settings_provider_.SetPreferredContrast(GetPreferredContrast());
+    native_theme_ = ui::NativeTheme::GetInstanceForNativeUi();
+#if BUILDFLAG(IS_LINUX)
+    if (GetSystemTheme() == SystemTheme::kCustom) {
+      native_theme_ = ui::GetDefaultLinuxUiTheme()->GetNativeTheme();
+    }
+#endif
+    original_forced_colors_ = native_theme_->forced_colors();
+    original_preferred_contrast_ = native_theme_->preferred_contrast();
+    original_preferred_color_scheme_ = native_theme_->preferred_color_scheme();
+
+    auto preferred_color_scheme = GetPreferredColorScheme();
 #if BUILDFLAG(IS_WIN)
-    os_settings_provider_.SetForcedColorsActive(
-        GetPreferredContrast() == ui::NativeTheme::PreferredContrast::kMore);
+    const bool high_contrast =
+        preferred_contrast() == ui::NativeTheme::PreferredContrast::kMore;
+    if (high_contrast) {
+      preferred_color_scheme = ui::NativeTheme::PreferredColorScheme::kLight;
+    }
+    native_theme_->set_forced_colors(high_contrast);
 #endif  // BUILDFLAG(IS_WIN)
+    native_theme_->SetPreferredContrast(preferred_contrast());
+    native_theme_->set_preferred_color_scheme(preferred_color_scheme);
+
+    // If native_theme_ has changed, call
+    // NativeTheme::NotifyOnNativeThemeUpdated to notify observers that the
+    // NativeTheme has been updated so that the ThemeService will know to update
+    // its ThemeSupplier to match the NativeTheme. The ColorProvider cache will
+    // also be reset.
+    if (original_forced_colors_ != native_theme_->forced_colors() ||
+        original_preferred_contrast_ != native_theme_->preferred_contrast() ||
+        original_preferred_color_scheme_ !=
+            native_theme_->preferred_color_scheme()) {
+      native_theme_->NotifyOnNativeThemeUpdated();
+    }
 
     // Update ThemeService to use the system theme if necessary.
     if (GetSystemTheme() == SystemTheme::kCustom) {
@@ -311,13 +298,22 @@ class ColorProviderTest : public ThemeServiceTest,
     }
   }
 
+  void TearDown() override {
+    // Restore the original NativeTheme parameters.
+    native_theme_->set_forced_colors(original_forced_colors_);
+    native_theme_->SetPreferredContrast(original_preferred_contrast_);
+    native_theme_->set_preferred_color_scheme(original_preferred_color_scheme_);
+    native_theme_->NotifyOnNativeThemeUpdated();
+    ThemeServiceTest::TearDown();
+  }
+
  protected:
   static ui::NativeTheme::PreferredColorScheme GetPreferredColorScheme(
       const ParamType& param = GetParam()) {
     return std::get<ui::NativeTheme::PreferredColorScheme>(param);
   }
 
-  static ui::NativeTheme::PreferredContrast GetPreferredContrast(
+  static ui::NativeTheme::PreferredContrast preferred_contrast(
       const ParamType& param = GetParam()) {
     return std::get<ui::NativeTheme::PreferredContrast>(param);
   }
@@ -339,7 +335,15 @@ class ColorProviderTest : public ThemeServiceTest,
   }
 
  private:
-  ui::MockOsSettingsProvider os_settings_provider_;
+  // Store the parameter values of the global NativeTheme for UI instance
+  // configured during SetUp() to check if an update should be propagated and
+  // to restore the NativeTheme to its original state in TearDown().
+  bool original_forced_colors_ = false;
+  ui::NativeTheme::PreferredContrast original_preferred_contrast_ =
+      ui::NativeTheme::PreferredContrast::kNoPreference;
+  ui::NativeTheme::PreferredColorScheme original_preferred_color_scheme_ =
+      ui::NativeTheme::PreferredColorScheme::kLight;
+  raw_ptr<ui::NativeTheme> native_theme_;
 #if BUILDFLAG(IS_LINUX)
   std::unique_ptr<ui::LinuxUiGetter> linux_ui_getter_;
 #endif
@@ -356,25 +360,6 @@ INSTANTIATE_TEST_SUITE_P(
         ::testing::Values(SystemTheme::kDefault, SystemTheme::kCustom)),
     ColorProviderTest::ParamInfoToString);
 
-TEST_P(ThemeUpdatedTest, NoUpdateOnCreation) {
-  // Monitor calls to `OnNativeThemeUpdated()`.
-  struct MockObserver : ui::NativeThemeObserver {
-    void OnNativeThemeUpdated(ui::NativeTheme* observed_theme) override {
-      ++call_count;
-    }
-
-    int call_count = 0;
-  } observer;
-  base::ScopedObservation<ui::NativeTheme, ui::NativeThemeObserver> observation(
-      &observer);
-  observation.Observe(ui::NativeTheme::GetInstanceForNativeUi());
-
-  // Creating the theme service should not synchronously trigger any NativeTheme
-  // notifications.
-  ThemeServiceFactory::GetForProfile(profile());
-  EXPECT_EQ(observer.call_count, 0);
-}
-
 // Installs then uninstalls a theme and makes sure that the ThemeService
 // reverts to the default theme after the uninstall.
 TEST_F(ThemeServiceTest, ThemeInstallUninstall) {
@@ -616,7 +601,7 @@ TEST_P(ColorProviderTest, OmniboxContrast) {
   // TODO(crbug.com/40847629): Windows platform high contrast colors are
   // not sufficiently high-contrast to pass this test.
 #if BUILDFLAG(IS_WIN)
-  if (GetPreferredContrast() == ui::NativeTheme::PreferredContrast::kMore) {
+  if (preferred_contrast() == ui::NativeTheme::PreferredContrast::kMore) {
     return;
   }
 #endif
@@ -698,7 +683,7 @@ TEST_P(ColorProviderTest, OmniboxContrast) {
 #if !BUILDFLAG(USE_GTK)
   // TODO(crbug.com/40847971): GTK does not have a sufficiently
   // high-contrast selected row color to pass this test.
-  if (GetPreferredContrast() == ui::NativeTheme::PreferredContrast::kMore) {
+  if (preferred_contrast() == ui::NativeTheme::PreferredContrast::kMore) {
     check_sufficient_contrast(kColorOmniboxResultsBackgroundSelected,
                               kColorOmniboxResultsBackground,
                               color_utils::kMinimumVisibleContrastRatio);
diff --git a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
index 8bf2c7f461e36..23d324460ad28 100644
--- a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
+++ b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
@@ -18,12 +18,12 @@
 #include "ui/color/color_mixer.h"
 #include "ui/color/color_provider.h"
 #include "ui/color/color_provider_key.h"
-#include "ui/color/color_provider_manager.h"
 #include "ui/color/color_provider_utils.h"
 #include "ui/color/color_recipe.h"
 #include "ui/color/color_transform.h"
 #include "ui/color/win/accent_color_observer.h"
 #include "ui/gfx/color_utils.h"
+#include "ui/native_theme/native_theme.h"
 #include "ui/views/views_features.h"
 
 namespace {
@@ -101,12 +101,25 @@ FrameTransforms GetFrameTransforms(const ui::ColorProviderKey& key) {
   return frame_transforms;
 }
 
-void EnsureColorProviderCacheWillBeResetWhenAccentColorStateChanges() {
+// Updates the NativeTheme's user_color to reflect the system accent color.
+// TODO(crbug.com/40280436): Explore moving logic into NativeThemeWin.
+void UpdateUserColor() {
+  const auto accent_color = ui::AccentColorObserver::Get()->accent_color();
+  ui::NativeTheme::GetInstanceForNativeUi()->set_user_color(accent_color);
+  ui::NativeTheme::GetInstanceForWeb()->set_user_color(accent_color);
+}
+
+void OnAccentColorUpdated() {
+  UpdateUserColor();
+  ui::NativeTheme::GetInstanceForNativeUi()->NotifyOnNativeThemeUpdated();
+  ui::NativeTheme::GetInstanceForWeb()->NotifyOnNativeThemeUpdated();
+}
+
+void UpdateUserColorWhenAccentColorStateChanges() {
+  UpdateUserColor();
   static base::NoDestructor<base::CallbackListSubscription> subscription(
-      ui::AccentColorObserver::Get()->Subscribe(base::BindRepeating(
-          // CAUTION: Do not bind directly to `ui::ColorProviderManager::Get()`
-          // here, as tests may reset that value!
-          [] { ui::ColorProviderManager::Get().ResetColorProviderCache(); })));
+      ui::AccentColorObserver::Get()->Subscribe(
+          base::BindRepeating(&OnAccentColorUpdated)));
 }
 
 SkColor GetAccentBorderColor() {
@@ -251,18 +264,7 @@ void AddNativeNonHighContrastColors(ui::ColorMixer& mixer,
 
 void AddNativeChromeColorMixer(ui::ColorProvider* provider,
                                const ui::ColorProviderKey& key) {
-  // If anything related to the accent color state changes, the color provider
-  // cache should be reset, so that changes to the recipes below are picked up
-  // even if the browser frame's color provider key does not change.
-  //
-  // When `ui::AccentColorObserver::accent_color()` itself changes, this happens
-  // anyway, because the change causes `ui::OsSettingsProviderWin` to call
-  // `ui::NativeTheme::NotifyOnNativeThemeUpdated()`, which will also reset the
-  // cache. However, changes to other accent-color-related state (e.g.
-  // `ui::AccentColorObserver::accent_border_color()`) will not (and should not)
-  // trigger this codepath, but can still affect the recipes below and thus
-  // require a reset.
-  EnsureColorProviderCacheWillBeResetWhenAccentColorStateChanges();
+  UpdateUserColorWhenAccentColorStateChanges();
 
   ui::ColorMixer& mixer = provider->AddMixer();
 
diff --git a/chrome/browser/ui/extensions/BUILD.gn b/chrome/browser/ui/extensions/BUILD.gn
index 294ff0364771b..f3d7279be3e0a 100644
--- a/chrome/browser/ui/extensions/BUILD.gn
+++ b/chrome/browser/ui/extensions/BUILD.gn
@@ -324,7 +324,6 @@ source_set("browser_tests") {
       "//ui/color:color_headers",
       "//ui/gfx",
       "//ui/native_theme",
-      "//ui/native_theme:test_support",
     ]
 
     if (is_linux) {
diff --git a/chrome/browser/ui/extensions/extension_image_util_browsertest.cc b/chrome/browser/ui/extensions/extension_image_util_browsertest.cc
index a04570244b683..d80d2a8e884c4 100644
--- a/chrome/browser/ui/extensions/extension_image_util_browsertest.cc
+++ b/chrome/browser/ui/extensions/extension_image_util_browsertest.cc
@@ -11,12 +11,11 @@
 #include "ui/base/buildflags.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/color/color_provider.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
+#include "ui/native_theme/native_theme.h"
 
 #if BUILDFLAG(IS_LINUX)
 #include "ui/linux/linux_ui.h"
 #include "ui/linux/linux_ui_getter.h"
-#include "ui/native_theme/native_theme.h"
 #endif
 
 namespace {
@@ -40,11 +39,12 @@ using ImageUtilTest = extensions::ExtensionBrowserTest;
 // consider deleting this test.
 IN_PROC_BROWSER_TEST_F(ImageUtilTest, DISABLED_CheckDefaultToolbarColor) {
   // This test relies on being run with the default light mode theme.
-  ui::MockOsSettingsProvider os_settings_provider;  // Forces light mode.
+  ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
+      ui::NativeTheme::PreferredColorScheme::kLight);
 #if BUILDFLAG(IS_LINUX)
   ui::LinuxUiGetter::set_instance(nullptr);
+#endif
   ui::NativeTheme::GetInstanceForNativeUi()->NotifyOnNativeThemeUpdated();
-#endif  // BUILDFLAG(IS_LINUX)
 
   EXPECT_EQ(extensions::image_util::kDefaultToolbarColor,
             browser()->window()->GetColorProvider()->GetColor(kColorToolbar))
diff --git a/chrome/browser/ui/profiles/BUILD.gn b/chrome/browser/ui/profiles/BUILD.gn
index 2c31a4d31f212..5981aaaf18e7f 100644
--- a/chrome/browser/ui/profiles/BUILD.gn
+++ b/chrome/browser/ui/profiles/BUILD.gn
@@ -161,7 +161,6 @@ source_set("unit_tests") {
         "profile_colors_util_unittest.cc",
         "profile_customization_synced_theme_waiter_unittest.cc",
       ]
-      deps += [ "//ui/native_theme:test_support" ]
     }
   }
 
diff --git a/chrome/browser/ui/profiles/profile_colors_util_unittest.cc b/chrome/browser/ui/profiles/profile_colors_util_unittest.cc
index 5b2932105396e..ae4a5c3126007 100644
--- a/chrome/browser/ui/profiles/profile_colors_util_unittest.cc
+++ b/chrome/browser/ui/profiles/profile_colors_util_unittest.cc
@@ -22,7 +22,6 @@
 #include "components/account_id/account_id.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gfx/color_utils.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
 
 namespace {
@@ -188,9 +187,9 @@ TEST_F(ProfileColorsUtilTest, IsLightForAutoselection) {
 class ProfileColorsUtilTestDarkModeParam
     : public ProfileColorsUtilTest,
       public testing::WithParamInterface<bool> {
- protected:
+ public:
   ProfileColorsUtilTestDarkModeParam() {
-    os_settings_provider_.SetPreferredColorScheme(
+    ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
         GetParam() ? ui::NativeTheme::PreferredColorScheme::kDark
                    : ui::NativeTheme::PreferredColorScheme::kLight);
   }
@@ -207,9 +206,6 @@ class ProfileColorsUtilTestDarkModeParam
       }
     }
   }
-
- private:
-  ui::MockOsSettingsProvider os_settings_provider_;
 };
 
 // Test that all colors matching the native light-or-dark color scheme are
diff --git a/chrome/browser/ui/views/dark_mode_manager_linux.cc b/chrome/browser/ui/views/dark_mode_manager_linux.cc
index 588c1995f3d7a..b465cbf2f8853 100644
--- a/chrome/browser/ui/views/dark_mode_manager_linux.cc
+++ b/chrome/browser/ui/views/dark_mode_manager_linux.cc
@@ -20,16 +20,22 @@
 namespace ui {
 
 DarkModeManagerLinux::DarkModeManagerLinux()
-    : DarkModeManagerLinux(dbus_thread_linux::GetSharedSessionBus(),
-                           ui::GetDefaultLinuxUiTheme(),
-                           &ui::GetLinuxUiThemes()) {}
+    : DarkModeManagerLinux(
+          dbus_thread_linux::GetSharedSessionBus(),
+          ui::GetDefaultLinuxUiTheme(),
+          &ui::GetLinuxUiThemes(),
+          std::vector<raw_ptr<ui::NativeTheme, VectorExperimental>>{
+              ui::NativeTheme::GetInstanceForNativeUi(),
+              ui::NativeTheme::GetInstanceForWeb()}) {}
 
 DarkModeManagerLinux::DarkModeManagerLinux(
     scoped_refptr<dbus::Bus> bus,
     LinuxUiTheme* default_linux_ui_theme,
     const std::vector<raw_ptr<LinuxUiTheme, VectorExperimental>>*
-        linux_ui_themes)
+        linux_ui_themes,
+    std::vector<raw_ptr<NativeTheme, VectorExperimental>> native_themes)
     : linux_ui_themes_(linux_ui_themes),
+      native_themes_(native_themes),
       bus_(bus),
       settings_proxy_(bus_->GetObjectProxy(
           kFreedesktopSettingsService,
@@ -199,11 +205,12 @@ void DarkModeManagerLinux::SetColorScheme(bool prefer_dark_theme,
   }
   prefer_dark_theme_ = prefer_dark_theme;
 
-  auto* const native_theme = NativeTheme::GetInstanceForNativeUi();
-  native_theme->set_preferred_color_scheme(
-      prefer_dark_theme_ ? NativeTheme::PreferredColorScheme::kDark
-                         : NativeTheme::PreferredColorScheme::kLight);
-  native_theme->NotifyOnNativeThemeUpdated();
+  for (NativeTheme* theme : native_themes_) {
+    theme->set_preferred_color_scheme(
+        prefer_dark_theme_ ? NativeTheme::PreferredColorScheme::kDark
+                           : NativeTheme::PreferredColorScheme::kLight);
+    theme->NotifyOnNativeThemeUpdated();
+  }
 }
 
 void DarkModeManagerLinux::SetAccentColor(dbus::MessageReader* reader) {
@@ -239,9 +246,10 @@ void DarkModeManagerLinux::SetAccentColor(dbus::MessageReader* reader) {
     linux_ui_theme->SetAccentColor(accent_color);
   }
 
-  auto* const native_theme = NativeTheme::GetInstanceForNativeUi();
-  native_theme->set_user_color(accent_color);
-  native_theme->NotifyOnNativeThemeUpdated();
+  for (NativeTheme* theme : native_themes_) {
+    theme->set_user_color(accent_color);
+    theme->NotifyOnNativeThemeUpdated();
+  }
 }
 
 }  // namespace ui
diff --git a/chrome/browser/ui/views/dark_mode_manager_linux.h b/chrome/browser/ui/views/dark_mode_manager_linux.h
index 19005b0021e14..bbd2099657407 100644
--- a/chrome/browser/ui/views/dark_mode_manager_linux.h
+++ b/chrome/browser/ui/views/dark_mode_manager_linux.h
@@ -36,10 +36,8 @@ class DarkModeManagerLinuxTest;
 
 // Observes the system color scheme preference using
 // org.freedesktop.portal.Settings. Falls back to the toolkit preference if
-// org.freedesktop.portal.Settings is unavailable.
-// TODO(pkasting): Perhaps this functionality should be in a new
-// `OsSettingsProviderLinux` class instead? Not sure how it should interact with
-// `OsSettingsProviderGtk`/`OsSettingsProviderQt`.
+// org.freedesktop.portal.Settings is unavailable.  Propagates the dark mode
+// preference to the web theme.
 class DarkModeManagerLinux : public NativeThemeObserver {
  public:
   DarkModeManagerLinux();
@@ -47,7 +45,8 @@ class DarkModeManagerLinux : public NativeThemeObserver {
       scoped_refptr<dbus::Bus> bus,
       LinuxUiTheme* default_linux_ui_theme,
       const std::vector<raw_ptr<LinuxUiTheme, VectorExperimental>>*
-          linux_ui_themes);
+          linux_ui_themes,
+      std::vector<raw_ptr<NativeTheme, VectorExperimental>> native_themes);
   DarkModeManagerLinux(const DarkModeManagerLinux&) = delete;
   DarkModeManagerLinux& operator=(const DarkModeManagerLinux&) = delete;
   ~DarkModeManagerLinux() override;
@@ -94,6 +93,7 @@ class DarkModeManagerLinux : public NativeThemeObserver {
 
   raw_ptr<const std::vector<raw_ptr<LinuxUiTheme, VectorExperimental>>>
       linux_ui_themes_;
+  std::vector<raw_ptr<NativeTheme, VectorExperimental>> native_themes_;
 
   scoped_refptr<dbus::Bus> bus_;
   raw_ptr<dbus::ObjectProxy> settings_proxy_;
diff --git a/chrome/browser/ui/views/dark_mode_manager_linux_unittest.cc b/chrome/browser/ui/views/dark_mode_manager_linux_unittest.cc
index 0967d05702b00..1556867236223 100644
--- a/chrome/browser/ui/views/dark_mode_manager_linux_unittest.cc
+++ b/chrome/browser/ui/views/dark_mode_manager_linux_unittest.cc
@@ -13,7 +13,6 @@
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/linux/fake_linux_ui.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
 
 namespace ui {
@@ -27,6 +26,39 @@ class MockLinuxUi : public FakeLinuxUi {
   MOCK_METHOD(void, SetAccentColor, (std::optional<SkColor> color), (override));
 };
 
+class MockNativeTheme : public NativeTheme {
+ public:
+  MockNativeTheme() = default;
+  ~MockNativeTheme() override = default;
+
+  void SetPreferredColorScheme(NativeTheme::PreferredColorScheme color_scheme) {
+    set_preferred_color_scheme(color_scheme);
+    NotifyOnNativeThemeUpdated();
+  }
+
+  // Mock some pure-virtual methods even though they're not used.
+  MOCK_METHOD(gfx::Size,
+              GetPartSize,
+              (Part part, State state, const ExtraParams& extra),
+              (const override));
+  MOCK_METHOD(void,
+              Paint,
+              (cc::PaintCanvas * canvas,
+               const ui::ColorProvider* color_provider,
+               Part part,
+               State state,
+               const gfx::Rect& rect,
+               const ExtraParams& extra,
+               bool forced_colors,
+               PreferredColorScheme color_scheme,
+               PreferredContrast contrast,
+               const std::optional<SkColor>& accent_color),
+              (const override));
+  MOCK_METHOD(bool, SupportsNinePatch, (Part part), (const override));
+  MOCK_METHOD(gfx::Size, GetNinePatchCanvasSize, (Part part), (const override));
+  MOCK_METHOD(gfx::Rect, GetNinePatchAperture, (Part part), (const override));
+};
+
 ACTION_P2(RegisterSignalCallback, signal_callback, connected_callback) {
   *signal_callback = arg2;
   *connected_callback = std::move(*arg3);
@@ -69,9 +101,7 @@ class DarkModeManagerLinuxTest : public testing::Test {
   dbus::ObjectProxy::ResponseOrErrorCallback& accent_color_callback() {
     return accent_color_callback_;
   }
-  MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
-  }
+  MockNativeTheme* mock_native_theme() { return mock_native_theme_.get(); }
   MockLinuxUi* mock_linux_ui() { return mock_linux_ui_.get(); }
 
  private:
@@ -145,9 +175,10 @@ class DarkModeManagerLinuxTest : public testing::Test {
     mock_linux_ui_ = std::make_unique<MockLinuxUi>();
     linux_ui_themes_ = std::vector<raw_ptr<LinuxUiTheme, VectorExperimental>>{
         mock_linux_ui_.get()};
-    auto* const native_theme = ui::NativeTheme::GetInstanceForNativeUi();
+
+    mock_native_theme_ = std::make_unique<MockNativeTheme>();
     EXPECT_CALL(*mock_linux_ui_, GetNativeTheme())
-        .WillOnce(Return(native_theme));
+        .WillOnce(Return(mock_native_theme_.get()));
 
     enable_portal_accent_color_.InitAndEnableFeature(
         features::kUsePortalAccentColor);
@@ -155,12 +186,14 @@ class DarkModeManagerLinuxTest : public testing::Test {
     dbus_xdg::ResetCachedStateForTesting();
 
     manager_ = std::make_unique<DarkModeManagerLinux>(
-        mock_bus_, mock_linux_ui_.get(), &linux_ui_themes_);
+        mock_bus_, mock_linux_ui_.get(), &linux_ui_themes_,
+        std::vector<raw_ptr<NativeTheme, VectorExperimental>>{
+            mock_native_theme_.get()});
 
     EXPECT_FALSE(manager_->prefer_dark_theme());
-    EXPECT_EQ(native_theme->preferred_color_scheme(),
+    EXPECT_EQ(mock_native_theme_->preferred_color_scheme(),
               NativeTheme::PreferredColorScheme::kLight);
-    EXPECT_FALSE(native_theme->user_color().has_value());
+    EXPECT_FALSE(mock_native_theme_->user_color().has_value());
   }
 
   void TearDown() override { manager_.reset(); }
@@ -168,7 +201,7 @@ class DarkModeManagerLinuxTest : public testing::Test {
   std::unique_ptr<MockLinuxUi> mock_linux_ui_;
   std::vector<raw_ptr<LinuxUiTheme, VectorExperimental>> linux_ui_themes_;
 
-  MockOsSettingsProvider os_settings_provider_;
+  std::unique_ptr<MockNativeTheme> mock_native_theme_;
 
   scoped_refptr<dbus::MockBus> mock_bus_;
   scoped_refptr<dbus::MockObjectProxy> mock_dbus_proxy_;
@@ -188,10 +221,10 @@ class DarkModeManagerLinuxTest : public testing::Test {
 
 TEST_F(DarkModeManagerLinuxTest, UseNativeThemeSetting) {
   // Set the native theme preference before the async DBus calls complete.
-  os_settings_provider().SetPreferredColorScheme(
+  mock_native_theme()->SetPreferredColorScheme(
       NativeTheme::PreferredColorScheme::kDark);
   EXPECT_TRUE(ManagerPrefersDarkTheme());
-  os_settings_provider().SetPreferredColorScheme(
+  mock_native_theme()->SetPreferredColorScheme(
       NativeTheme::PreferredColorScheme::kLight);
   EXPECT_FALSE(ManagerPrefersDarkTheme());
 
@@ -208,10 +241,10 @@ TEST_F(DarkModeManagerLinuxTest, UseNativeThemeSetting) {
            DarkModeManagerLinux::kSettingChangedSignal, false);
 
   // The native theme preference should still toggle the manager preference.
-  os_settings_provider().SetPreferredColorScheme(
+  mock_native_theme()->SetPreferredColorScheme(
       NativeTheme::PreferredColorScheme::kDark);
   EXPECT_TRUE(ManagerPrefersDarkTheme());
-  os_settings_provider().SetPreferredColorScheme(
+  mock_native_theme()->SetPreferredColorScheme(
       NativeTheme::PreferredColorScheme::kLight);
   EXPECT_FALSE(ManagerPrefersDarkTheme());
 }
@@ -232,8 +265,7 @@ TEST_F(DarkModeManagerLinuxTest, UsePortalSetting) {
   EXPECT_CALL(*mock_linux_ui(), SetDarkTheme(true));
   std::move(color_scheme_callback()).Run(response.get(), nullptr);
   EXPECT_TRUE(ManagerPrefersDarkTheme());
-  auto* const native_theme = ui::NativeTheme::GetInstanceForNativeUi();
-  EXPECT_EQ(native_theme->preferred_color_scheme(),
+  EXPECT_EQ(mock_native_theme()->preferred_color_scheme(),
             NativeTheme::PreferredColorScheme::kDark);
 
   // Changes in the portal preference should be processed by the manager and the
@@ -247,15 +279,15 @@ TEST_F(DarkModeManagerLinuxTest, UsePortalSetting) {
   EXPECT_CALL(*mock_linux_ui(), SetDarkTheme(false));
   std::move(setting_changed_callback()).Run(&signal);
   EXPECT_FALSE(ManagerPrefersDarkTheme());
-  EXPECT_EQ(native_theme->preferred_color_scheme(),
+  EXPECT_EQ(mock_native_theme()->preferred_color_scheme(),
             NativeTheme::PreferredColorScheme::kLight);
 
   // The native theme preference should have no effect when the portal
   // preference is being used.
-  os_settings_provider().SetPreferredColorScheme(
+  mock_native_theme()->SetPreferredColorScheme(
       NativeTheme::PreferredColorScheme::kDark);
   EXPECT_FALSE(ManagerPrefersDarkTheme());
-  os_settings_provider().SetPreferredColorScheme(
+  mock_native_theme()->SetPreferredColorScheme(
       NativeTheme::PreferredColorScheme::kLight);
   EXPECT_FALSE(ManagerPrefersDarkTheme());
 }
@@ -284,8 +316,7 @@ TEST_F(DarkModeManagerLinuxTest, UsePortalAccentColor) {
       SkColorSetRGB(0, 127, 255);
   EXPECT_CALL(*mock_linux_ui(), SetAccentColor(kExpectedColor1));
   std::move(accent_color_callback()).Run(response.get(), nullptr);
-  auto* const native_theme = ui::NativeTheme::GetInstanceForNativeUi();
-  EXPECT_EQ(native_theme->user_color(), kExpectedColor1);
+  EXPECT_EQ(mock_native_theme()->user_color(), kExpectedColor1);
   Mock::VerifyAndClearExpectations(mock_linux_ui());
 
   // Changes in the portal accent color should be processed by the manager and
@@ -308,7 +339,7 @@ TEST_F(DarkModeManagerLinuxTest, UsePortalAccentColor) {
       SkColorSetRGB(255, 127, 0);
   EXPECT_CALL(*mock_linux_ui(), SetAccentColor(kExpectedColor2));
   std::move(setting_changed_callback()).Run(&signal);
-  EXPECT_EQ(native_theme->user_color(), kExpectedColor2);
+  EXPECT_EQ(mock_native_theme()->user_color(), kExpectedColor2);
 }
 
 }  // namespace ui
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_browsertest.cc b/chrome/browser/ui/views/frame/browser_frame_view_browsertest.cc
index 7ec5943ef2f3b..0f7bd124224e6 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_browsertest.cc
+++ b/chrome/browser/ui/views/frame/browser_frame_view_browsertest.cc
@@ -36,7 +36,6 @@
 #include "ui/color/color_id.h"
 #include "ui/color/color_provider.h"
 #include "ui/gfx/color_utils.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 
 namespace {
 
@@ -219,8 +218,9 @@ IN_PROC_BROWSER_TEST_F(BrowserFrameViewBrowserTest,
 // Verifies that the incognito window frame is always the right color.
 IN_PROC_BROWSER_TEST_F(BrowserFrameViewBrowserTest, IncognitoIsCorrectColor) {
   // Set the color that's expected to be ignored.
-  ui::MockOsSettingsProvider os_settings_provider;
-  os_settings_provider.SetAccentColor(gfx::kGoogleBlue400);
+  auto* theme = ui::NativeTheme::GetInstanceForNativeUi();
+  theme->set_user_color(gfx::kGoogleBlue400);
+  theme->NotifyOnNativeThemeUpdated();
 
   Browser* incognito_browser = CreateIncognitoBrowser(browser()->profile());
 
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_chromeos_browsertest.cc b/chrome/browser/ui/views/frame/browser_frame_view_chromeos_browsertest.cc
index b81e3cb9936f2..3376badb0d5f1 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_chromeos_browsertest.cc
+++ b/chrome/browser/ui/views/frame/browser_frame_view_chromeos_browsertest.cc
@@ -132,8 +132,6 @@
 #include "ui/gfx/color_palette.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/vector_icon_types.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
-#include "ui/native_theme/native_theme.h"
 #include "ui/views/accessibility/view_accessibility.h"
 #include "ui/views/focus/focus_manager.h"
 #include "ui/views/test/views_test_utils.h"
@@ -1802,11 +1800,13 @@ class BrowserFrameViewAshThemeChangeTest
 
   // Toggles the color mode, triggering propagation of theme change events.
   void ToggleColorMode() {
-    os_settings_provider_.SetPreferredColorScheme(
-        (os_settings_provider_.PreferredColorScheme() ==
+    auto* native_theme = ui::NativeTheme::GetInstanceForNativeUi();
+    native_theme->set_preferred_color_scheme(
+        (native_theme->preferred_color_scheme() ==
          ui::NativeTheme::PreferredColorScheme::kDark)
             ? ui::NativeTheme::PreferredColorScheme::kLight
             : ui::NativeTheme::PreferredColorScheme::kDark);
+    native_theme->NotifyOnNativeThemeUpdated();
   }
 
   // Installs the web app under test, blocking until installation is complete,
@@ -1841,7 +1841,6 @@ class BrowserFrameViewAshThemeChangeTest
   Profile* profile() { return browser()->profile(); }
 
  private:
-  ui::MockOsSettingsProvider os_settings_provider_;
   std::unique_ptr<ash::TestSystemWebAppInstallation>
       system_web_app_installation_;
   std::unique_ptr<net::EmbeddedTestServer> test_server_;
diff --git a/chrome/browser/ui/views/frame/browser_widget_browsertest.cc b/chrome/browser/ui/views/frame/browser_widget_browsertest.cc
index b547eb2f4eb29..0bb0a6dc1743f 100644
--- a/chrome/browser/ui/views/frame/browser_widget_browsertest.cc
+++ b/chrome/browser/ui/views/frame/browser_widget_browsertest.cc
@@ -34,8 +34,7 @@
 #include "ui/color/color_provider_key.h"
 #include "ui/color/color_provider_manager.h"
 #include "ui/color/color_recipe.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
-#include "ui/native_theme/native_theme.h"
+#include "ui/native_theme/test_native_theme.h"
 #include "ui/views/bubble/bubble_dialog_model_host.h"
 #include "ui/views/views_delegate.h"
 
@@ -175,6 +174,13 @@ class BrowserWidgetColorProviderTest : public BrowserWidgetTest {
   void SetUpOnMainThread() override {
     BrowserWidgetTest::SetUpOnMainThread();
 
+    test_native_theme_.SetPreferredColorScheme(
+        ui::NativeTheme::PreferredColorScheme::kLight);
+    // TODO(tluk): BrowserWidget may update the NativeTheme when a theme update
+    // event is received, which may unset the test NativeTheme. There should be
+    // a way to prevent updates resetting the test NativeTheme when set.
+    GetBrowserWidget(browser())->SetNativeThemeForTest(&test_native_theme_);
+
     // Set the default browser pref to follow system color mode.
     profile()->GetPrefs()->SetInteger(
         prefs::kBrowserColorScheme,
@@ -219,16 +225,12 @@ class BrowserWidgetColorProviderTest : public BrowserWidgetTest {
   }
 
   Profile* profile() { return browser()->profile(); }
-  ui::MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
-  }
 
   ThemeService* GetThemeService(Profile* profile) {
     return ThemeServiceFactory::GetForProfile(profile);
   }
 
- private:
-  ui::MockOsSettingsProvider os_settings_provider_;
+  ui::TestNativeTheme test_native_theme_;
 };
 
 // Verifies the BrowserWidget honors the BrowserColorScheme pref.
@@ -236,26 +238,32 @@ IN_PROC_BROWSER_TEST_F(BrowserWidgetColorProviderTest,
                        TracksBrowserColorScheme) {
   SetFollowDevice(profile(), false);
 
-  // Assert the browser follows the system color scheme.
+  // Assert the browser follows the system color scheme (i.e. the color scheme
+  // set on the associated native theme)
+  views::Widget* browser_widget = GetBrowserWidget(browser());
+  test_native_theme_.SetPreferredColorScheme(
+      ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_EQ(ui::ColorProviderKey::ColorMode::kLight,
             GetColorProviderKey(browser()).color_mode);
 
-  os_settings_provider().SetPreferredColorScheme(
+  test_native_theme_.SetPreferredColorScheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_EQ(ui::ColorProviderKey::ColorMode::kDark,
             GetColorProviderKey(browser()).color_mode);
 
   // Set the BrowserColorScheme pref. The BrowserWidget should ignore the system
   // color scheme.
-  os_settings_provider().SetPreferredColorScheme(
+  test_native_theme_.SetPreferredColorScheme(
       ui::NativeTheme::PreferredColorScheme::kLight);
   SetBrowserColorScheme(profile(), ThemeService::BrowserColorScheme::kDark);
+  browser_widget->SetNativeThemeForTest(&test_native_theme_);
   EXPECT_EQ(ui::ColorProviderKey::ColorMode::kDark,
             GetColorProviderKey(browser()).color_mode);
 
-  os_settings_provider().SetPreferredColorScheme(
+  test_native_theme_.SetPreferredColorScheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
   SetBrowserColorScheme(profile(), ThemeService::BrowserColorScheme::kLight);
+  browser_widget->SetNativeThemeForTest(&test_native_theme_);
   EXPECT_EQ(ui::ColorProviderKey::ColorMode::kLight,
             GetColorProviderKey(browser()).color_mode);
 }
@@ -265,6 +273,8 @@ IN_PROC_BROWSER_TEST_F(BrowserWidgetColorProviderTest,
                        IncognitoAlwaysDarkMode) {
   // Create an incognito browser.
   Browser* incognito_browser = CreateIncognitoBrowser(profile());
+  views::Widget* incognito_browser_frame = GetBrowserWidget(incognito_browser);
+  incognito_browser_frame->SetNativeThemeForTest(&test_native_theme_);
 
   // The incognito browser should reflect the dark color mode irrespective of
   // the current BrowserColorScheme.
@@ -357,13 +367,14 @@ IN_PROC_BROWSER_TEST_F(BrowserWidgetColorProviderTest,
   // Create an incognito browser.
   Browser* incognito_browser = CreateIncognitoBrowser(profile());
   views::Widget* incognito_browser_frame = GetBrowserWidget(incognito_browser);
+  incognito_browser_frame->SetNativeThemeForTest(&test_native_theme_);
 
-  // Set the user color in both the OS and the profile pref.
-  os_settings_provider().SetAccentColor(SK_ColorBLUE);
+  // Set the user color override on both the NativeTheme and the profile pref.
+  test_native_theme_.set_user_color(SK_ColorBLUE);
   SetUserColor(incognito_browser->profile(), SK_ColorGREEN);
   incognito_browser_frame->ThemeChanged();
 
-  // The incognito browser should always set the user_color_source to grayscale.
+  // The ingognito browser should always set the user_color_source to grayscale.
   EXPECT_EQ(ui::ColorProviderKey::UserColorSource::kGrayscale,
             GetColorProviderKey(incognito_browser).user_color_source);
 }
@@ -390,10 +401,15 @@ IN_PROC_BROWSER_TEST_F(BrowserWidgetColorProviderTest,
                        GrayscaleIgnoresUserColor) {
   SetFollowDevice(profile(), false);
 
-  // Set OS user color to an obviously different color.
-  os_settings_provider().SetAccentColor(SK_ColorMAGENTA);
+  // Set native theme to an obviously different color.
+  test_native_theme_.set_user_color(SK_ColorMAGENTA);
+  test_native_theme_.set_scheme_variant(
+      ui::ColorProviderKey::SchemeVariant::kVibrant);
 
+  views::Widget* browser_widget = GetBrowserWidget(browser());
+  browser_widget->SetNativeThemeForTest(&test_native_theme_);
   SetIsGrayscale(profile(), true);
+
   EXPECT_EQ(ui::ColorProviderKey::UserColorSource::kGrayscale,
             GetColorProviderKey(browser()).user_color_source);
 }
@@ -404,13 +420,13 @@ IN_PROC_BROWSER_TEST_F(BrowserWidgetColorProviderTest,
   // Create an incognito browser.
   Browser* incognito_browser = CreateIncognitoBrowser(profile());
 
-  // Set the is_grayscale pref to false. The incognito browser should force the
+  // Set the is_grayscale pref to false. The ingognito browser should force the
   // is_grayscale setting to true.
   SetIsGrayscale(incognito_browser->profile(), false);
   EXPECT_EQ(ui::ColorProviderKey::UserColorSource::kGrayscale,
             GetColorProviderKey(incognito_browser).user_color_source);
 
-  // Set the is_grayscale pref to true. The incognito browser should continue to
+  // Set the is_grayscale pref to true. The ingognito browser should continue to
   // force the is_grayscale setting to true.
   SetIsGrayscale(incognito_browser->profile(), true);
   EXPECT_EQ(ui::ColorProviderKey::UserColorSource::kGrayscale,
@@ -440,8 +456,12 @@ IN_PROC_BROWSER_TEST_F(BrowserWidgetColorProviderTest, UseDeviceIgnoresTheme) {
   static constexpr SkColor kNativeThemeColor = SK_ColorMAGENTA;
   static constexpr SkColor kThemeServiceColor = SK_ColorGREEN;
 
-  // Set OS user color to an obviously different color.
-  os_settings_provider().SetAccentColor(kNativeThemeColor);
+  views::Widget* browser_widget = GetBrowserWidget(browser());
+  // Set native theme to an obviously different color.
+  ui::NativeTheme* native_theme = browser_widget->GetNativeTheme();
+  native_theme->set_user_color(kNativeThemeColor);
+  native_theme->set_scheme_variant(
+      ui::ColorProviderKey::SchemeVariant::kVibrant);
 
   // Set the color in `ThemeService`.
   SetUserColor(profile(), kThemeServiceColor);
@@ -464,7 +484,11 @@ IN_PROC_BROWSER_TEST_F(BrowserWidgetColorProviderTest,
                        UseDeviceIgnoresAutogeneratedTheme) {
   static constexpr SkColor kNativeThemeColor = SK_ColorMAGENTA;
 
-  os_settings_provider().SetAccentColor(kNativeThemeColor);
+  views::Widget* browser_widget = GetBrowserWidget(browser());
+  ui::NativeTheme* native_theme = browser_widget->GetNativeTheme();
+  native_theme->set_user_color(kNativeThemeColor);
+  native_theme->set_scheme_variant(
+      ui::ColorProviderKey::SchemeVariant::kVibrant);
 
   // Set `ThemeService` to use an autogenerated theme.
   auto* theme_service = GetThemeService(profile());
@@ -488,8 +512,12 @@ IN_PROC_BROWSER_TEST_F(BrowserWidgetColorProviderTest,
                        UseDeviceThemeIgnoresGrayscale) {
   static constexpr SkColor kNativeThemeColor = SK_ColorMAGENTA;
 
-  // Set OS user color to an obviously different color.
-  os_settings_provider().SetAccentColor(kNativeThemeColor);
+  views::Widget* browser_widget = GetBrowserWidget(browser());
+  // Set native theme to an obviously different color.
+  ui::NativeTheme* native_theme = browser_widget->GetNativeTheme();
+  native_theme->set_user_color(kNativeThemeColor);
+  native_theme->set_scheme_variant(
+      ui::ColorProviderKey::SchemeVariant::kVibrant);
 
   SetIsGrayscale(profile(), true);
   // Prefer color from NativeTheme.
@@ -503,8 +531,12 @@ IN_PROC_BROWSER_TEST_F(BrowserWidgetColorProviderTest,
 
 IN_PROC_BROWSER_TEST_F(BrowserWidgetColorProviderTest,
                        BaselineThemeIgnoresNativeThemeColor) {
-  // Set OS user color to an obviously different color.
-  os_settings_provider().SetAccentColor(SK_ColorMAGENTA);
+  views::Widget* browser_widget = GetBrowserWidget(browser());
+  // Set native theme to an obviously different color.
+  ui::NativeTheme* native_theme = browser_widget->GetNativeTheme();
+  native_theme->set_user_color(SK_ColorMAGENTA);
+  native_theme->set_scheme_variant(
+      ui::ColorProviderKey::SchemeVariant::kVibrant);
 
   // Set the color in `ThemeService` to nullopt to indicate the Baseline theme.
   SetUserColor(profile(), std::nullopt);
diff --git a/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_browsertest.cc b/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_browsertest.cc
index 1aec33058aaa2..739985ef8cbec 100644
--- a/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_browsertest.cc
+++ b/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_browsertest.cc
@@ -51,8 +51,6 @@
 #include "ui/compositor/layer.h"
 #include "ui/compositor/layer_animator.h"
 #include "ui/events/test/event_generator.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
-#include "ui/native_theme/native_theme.h"
 #include "ui/views/accessibility/ax_update_notifier.h"
 #include "ui/views/accessibility/ax_update_observer.h"
 #include "ui/views/accessibility/view_accessibility.h"
@@ -199,12 +197,10 @@ IN_PROC_BROWSER_TEST_F(OmniboxPopupViewViewsTest, ThemeIntegration) {
   UseDefaultTheme();
   SetUseDeviceTheme(false);
 
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kDark);
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kDark);
   const SkColor selection_color_dark = GetSelectedColor(browser());
 
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kLight);
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kLight);
   const SkColor selection_color_light = GetSelectedColor(browser());
 
   // Unthemed, non-incognito always has a white background. Exceptions: Inverted
@@ -250,14 +246,12 @@ IN_PROC_BROWSER_TEST_F(OmniboxPopupViewViewsTest, ThemeIntegrationInIncognito) {
   UseDefaultTheme();
   SetUseDeviceTheme(false);
 
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kDark);
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kDark);
   SetIsGrayscale(true);
 
   const SkColor selection_color_dark = GetSelectedColor(browser());
 
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kLight);
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kLight);
   SetIsGrayscale(false);
 
   // Install a theme (in both browsers, since it's the same profile).
diff --git a/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_interactive_uitest.cc b/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_interactive_uitest.cc
index 71c0f88ab9ffe..aa8b9511c1ad1 100644
--- a/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_interactive_uitest.cc
+++ b/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_interactive_uitest.cc
@@ -9,7 +9,6 @@
 #include "components/omnibox/common/omnibox_features.h"
 #include "content/public/test/browser_test.h"
 #include "ui/events/test/event_generator.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/views/widget/widget_utils.h"
 
 // Check that the location bar background (and the background of the textfield
@@ -19,7 +18,10 @@ IN_PROC_BROWSER_TEST_F(OmniboxPopupViewViewsTest,
                        PopupMatchesLocationBarBackground) {
   // In dark mode the omnibox focused and unfocused colors are the same, which
   // makes this test fail; see comments below.
-  ui::MockOsSettingsProvider os_settings_provider;  // Forces light mode.
+  BrowserView::GetBrowserViewForBrowser(browser())
+      ->GetNativeTheme()
+      ->set_preferred_color_scheme(
+          ui::NativeTheme::PreferredColorScheme::kLight);
 
   // Start with the Omnibox unfocused.
   omnibox_view()->GetFocusManager()->ClearFocus();
diff --git a/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_test.h b/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_test.h
index 82704e5f91b35..26b673424869e 100644
--- a/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_test.h
+++ b/chrome/browser/ui/views/omnibox/omnibox_popup_view_views_test.h
@@ -19,7 +19,6 @@
 #include "chrome/browser/ui/views/toolbar/toolbar_view.h"
 #include "chrome/test/base/in_process_browser_test.h"
 #include "components/omnibox/common/omnibox_features.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/views/widget/widget.h"
 
 // Base class for omnibox browser and ui tests.
@@ -48,9 +47,6 @@ class OmniboxPopupViewViewsTest : public InProcessBrowserTest {
     return popup_view()->result_view_at(index);
   }
 
-  ui::MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
-  }
   LocationBarView* location_bar() {
     auto* browser_view = BrowserView::GetBrowserViewForBrowser(browser());
     return browser_view->toolbar()->location_bar();
@@ -75,6 +71,13 @@ class OmniboxPopupViewViewsTest : public InProcessBrowserTest {
         ->GetColor(kColorOmniboxResultsBackground);
   }
 
+  void SetPreferredColorScheme(
+      ui::NativeTheme::PreferredColorScheme color_scheme) {
+    BrowserView* browser_view =
+        BrowserView::GetBrowserViewForBrowser(browser());
+    browser_view->GetNativeTheme()->set_preferred_color_scheme(color_scheme);
+  }
+
   void SetIsGrayscale(bool is_grayscale) {
     ThemeServiceFactory::GetForProfile(browser()->profile())
         ->SetIsGrayscale(is_grayscale);
@@ -96,7 +99,6 @@ class OmniboxPopupViewViewsTest : public InProcessBrowserTest {
   }
 
  private:
-  ui::MockOsSettingsProvider os_settings_provider_;
   OmniboxTriggeredFeatureService triggered_feature_service_;
 };
 
diff --git a/chrome/browser/ui/views/omnibox/omnibox_popup_view_webui_interactive_uitest.cc b/chrome/browser/ui/views/omnibox/omnibox_popup_view_webui_interactive_uitest.cc
index 3a81bc9f681d5..40458aadbd21d 100644
--- a/chrome/browser/ui/views/omnibox/omnibox_popup_view_webui_interactive_uitest.cc
+++ b/chrome/browser/ui/views/omnibox/omnibox_popup_view_webui_interactive_uitest.cc
@@ -9,7 +9,6 @@
 #include "components/omnibox/common/omnibox_features.h"
 #include "content/public/test/browser_test.h"
 #include "ui/base/ui_base_features.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 
 // ChromeOS environment doesn't instantiate the NewWebUI<OmniboxPopupUI>
 // in the factory's GetWebUIFactoryFunction, so these don't work there yet.
@@ -24,7 +23,10 @@ IN_PROC_BROWSER_TEST_F(OmniboxPopupViewWebUITest,
                        PopupMatchesLocationBarBackground) {
   // In dark mode the omnibox focused and unfocused colors are the same, which
   // makes this test fail; see comments below.
-  ui::MockOsSettingsProvider os_settings_provider;  // Forces light mode.
+  BrowserView::GetBrowserViewForBrowser(browser())
+      ->GetNativeTheme()
+      ->set_preferred_color_scheme(
+          ui::NativeTheme::PreferredColorScheme::kLight);
 
   // Start with the Omnibox unfocused.
   omnibox_view()->GetFocusManager()->ClearFocus();
diff --git a/chrome/browser/ui/views/omnibox/omnibox_popup_view_webui_test.h b/chrome/browser/ui/views/omnibox/omnibox_popup_view_webui_test.h
index 0751cad4ca110..b776e8a2ec549 100644
--- a/chrome/browser/ui/views/omnibox/omnibox_popup_view_webui_test.h
+++ b/chrome/browser/ui/views/omnibox/omnibox_popup_view_webui_test.h
@@ -71,6 +71,12 @@ class OmniboxPopupViewWebUITest : public InProcessBrowserTest {
         ->GetColor(kColorOmniboxResultsBackground);
   }
 
+  void SetUseDarkColor(ui::NativeTheme::PreferredColorScheme color_scheme) {
+    BrowserView* browser_view =
+        BrowserView::GetBrowserViewForBrowser(browser());
+    browser_view->GetNativeTheme()->set_preferred_color_scheme(color_scheme);
+  }
+
   // Some tests relies on the light/dark variants of the result background to be
   // different. But when using the system theme on Linux, these colors will be
   // the same. Ensure we're not using the system theme, which may be
diff --git a/chrome/browser/ui/web_applications/BUILD.gn b/chrome/browser/ui/web_applications/BUILD.gn
index ddeac4bc6e9b5..a7256d78cb13f 100644
--- a/chrome/browser/ui/web_applications/BUILD.gn
+++ b/chrome/browser/ui/web_applications/BUILD.gn
@@ -302,7 +302,6 @@ source_set("browser_tests") {
     "//components/webapps/browser",
     "//components/webapps/common",
     "//components/webapps/isolated_web_apps/test_support",
-    "//ui/native_theme:test_support",
   ]
 
   if (is_chromeos) {
diff --git a/chrome/browser/ui/web_applications/app_browser_controller.cc b/chrome/browser/ui/web_applications/app_browser_controller.cc
index 5c27d5f96e528..d4b5f0f6a42ec 100644
--- a/chrome/browser/ui/web_applications/app_browser_controller.cc
+++ b/chrome/browser/ui/web_applications/app_browser_controller.cc
@@ -69,7 +69,6 @@
 #include "ui/gfx/geometry/resize_utils.h"
 #include "ui/gfx/image/image_skia.h"
 #include "ui/native_theme/native_theme.h"
-#include "ui/native_theme/os_settings_provider.h"
 #include "url/gurl.h"
 #include "url/origin.h"
 #include "url/url_constants.h"
@@ -546,11 +545,12 @@ void AppBrowserController::PrimaryPageChanged(content::Page& page) {
 }
 
 std::optional<SkColor> AppBrowserController::GetThemeColor() const {
-  if (ui::NativeTheme::GetInstanceForNativeUi()->preferred_contrast() ==
+  if (ui::NativeTheme* native_theme = ui::NativeTheme::GetInstanceForNativeUi();
+      native_theme->preferred_contrast() ==
       ui::NativeTheme::PreferredContrast::kMore) {
     if (const std::optional<SkColor> window_color =
-            ui::OsSettingsProvider::Get().Color(
-                ui::OsSettingsProvider::ColorId::kWindow)) {
+            native_theme->GetSystemThemeColor(
+                ui::NativeTheme::SystemThemeColor::kWindow)) {
       return window_color;
     }
   }
diff --git a/chrome/browser/ui/web_applications/app_browser_controller_browsertest.cc b/chrome/browser/ui/web_applications/app_browser_controller_browsertest.cc
index a8fb54873a600..c0917133e3974 100644
--- a/chrome/browser/ui/web_applications/app_browser_controller_browsertest.cc
+++ b/chrome/browser/ui/web_applications/app_browser_controller_browsertest.cc
@@ -10,9 +10,7 @@
 #include "content/public/test/browser_test.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/skia/include/core/SkColor.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
-#include "ui/native_theme/os_settings_provider.h"
 
 namespace web_app {
 
@@ -27,11 +25,11 @@ IN_PROC_BROWSER_TEST_F(AppBrowserControllerBrowserTest,
 
   // Enable high contrast theme.
   static constexpr SkColor kWindowColor = SK_ColorBLUE;
-  ui::MockOsSettingsProvider os_settings_provider;
-  os_settings_provider.SetColor(ui::OsSettingsProvider::ColorId::kWindow,
-                                kWindowColor);
-  os_settings_provider.SetPreferredContrast(
-      ui::NativeTheme::PreferredContrast::kMore);
+  ui::NativeTheme* native_theme = ui::NativeTheme::GetInstanceForNativeUi();
+  const std::map<ui::NativeTheme::SystemThemeColor, SkColor> kSystemColors(
+      {{ui::NativeTheme::SystemThemeColor::kWindow, kWindowColor}});
+  native_theme->set_system_colors(kSystemColors);
+  native_theme->SetPreferredContrast(ui::NativeTheme::PreferredContrast::kMore);
   EXPECT_EQ(controller->GetThemeColor(), kWindowColor);
 }
 
diff --git a/chrome/browser/ui/web_applications/web_app_dark_mode_browsertest.cc b/chrome/browser/ui/web_applications/web_app_dark_mode_browsertest.cc
index 84b8247d02183..a6d2090a0a9a3 100644
--- a/chrome/browser/ui/web_applications/web_app_dark_mode_browsertest.cc
+++ b/chrome/browser/ui/web_applications/web_app_dark_mode_browsertest.cc
@@ -8,7 +8,6 @@
 #include "chrome/browser/web_applications/test/web_app_install_test_utils.h"
 #include "content/public/test/browser_test.h"
 #include "third_party/skia/include/core/SkColor.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
 
 namespace web_app {
@@ -32,18 +31,18 @@ class WebAppDarkModeBrowserTest : public WebAppBrowserTestBase {
 };
 
 IN_PROC_BROWSER_TEST_F(WebAppDarkModeBrowserTest, DarkColors) {
-  ui::MockOsSettingsProvider os_settings_provider;
-
   webapps::AppId app_id = InstallWebAppFromInfo();
 
   WebAppBrowserController* controller;
   Browser* app_browser = LaunchWebAppBrowser(app_id);
   controller = app_browser->app_controller()->AsWebAppBrowserController();
 
+  ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
+      ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_EQ(controller->GetThemeColor().value(), SK_ColorBLUE);
   EXPECT_EQ(controller->GetBackgroundColor().value(), SK_ColorBLUE);
 
-  os_settings_provider.SetPreferredColorScheme(
+  ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_EQ(controller->GetThemeColor().value(), SK_ColorRED);
   EXPECT_EQ(controller->GetBackgroundColor().value(), SK_ColorRED);
diff --git a/chrome/browser/ui/webui/cr_components/theme_color_picker/theme_color_picker_handler_unittest.cc b/chrome/browser/ui/webui/cr_components/theme_color_picker/theme_color_picker_handler_unittest.cc
index 08c289d112204..96e0792888ec0 100644
--- a/chrome/browser/ui/webui/cr_components/theme_color_picker/theme_color_picker_handler_unittest.cc
+++ b/chrome/browser/ui/webui/cr_components/theme_color_picker/theme_color_picker_handler_unittest.cc
@@ -37,7 +37,6 @@
 #include "ui/color/color_provider.h"
 #include "ui/color/color_provider_key.h"
 #include "ui/color/dynamic_color/palette_factory.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
 
 namespace content {
@@ -230,10 +229,6 @@ class ThemeColorPickerHandlerSetThemeTest
     : public ThemeColorPickerHandlerTest,
       public ::testing::WithParamInterface<ThemeUpdateSource> {
  protected:
-  ui::MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
-  }
-
   theme_color_picker::mojom::ThemePtr UpdateTheme() {
     // Flush any existing updates so the flush below only sees what results from
     // the update below.
@@ -264,9 +259,6 @@ class ThemeColorPickerHandlerSetThemeTest
     Mock::VerifyAndClearExpectations(&mock_client_);
     return theme;
   }
-
- private:
-  ui::MockOsSettingsProvider os_settings_provider_;
 };
 
 TEST_P(ThemeColorPickerHandlerSetThemeTest, SetTheme) {
@@ -295,7 +287,7 @@ TEST_P(ThemeColorPickerHandlerSetThemeTest, SetTheme) {
       .WillByDefault(testing::Return(false));
   ON_CALL(mock_theme_service(), GetBrowserColorVariant())
       .WillByDefault(testing::Return(ui::mojom::BrowserColorVariant::kNeutral));
-  os_settings_provider().SetPreferredColorScheme(
+  ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
 
   theme_color_picker::mojom::ThemePtr theme = UpdateTheme();
@@ -347,7 +339,7 @@ TEST_P(ThemeColorPickerHandlerSetThemeTest, SetThemeColorSchemeGM3) {
   ON_CALL(mock_theme_service(), GetBrowserColorScheme())
       .WillByDefault(
           testing::Return(ThemeService::BrowserColorScheme::kSystem));
-  os_settings_provider().SetPreferredColorScheme(
+  ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
 
   // Theme should be dark to match the system.
@@ -394,7 +386,7 @@ TEST_P(ThemeColorPickerHandlerSetThemeTest, UsingDeviceThemeGM3) {
       .WillByDefault(testing::Return(kUnusedColor));
   ON_CALL(mock_theme_service(), UsingDeviceTheme())
       .WillByDefault(testing::Return(true));
-  os_settings_provider().SetAccentColor(kUsedColor);
+  ui::NativeTheme::GetInstanceForNativeUi()->set_user_color(kUsedColor);
 
   theme_color_picker::mojom::ThemePtr theme = UpdateTheme();
   ASSERT_TRUE(theme);
diff --git a/chrome/browser/ui/webui/favicon_source.h b/chrome/browser/ui/webui/favicon_source.h
index 34a26d5e50a35..59b132d9040a4 100644
--- a/chrome/browser/ui/webui/favicon_source.h
+++ b/chrome/browser/ui/webui/favicon_source.h
@@ -65,6 +65,8 @@ class FaviconSource : public content::URLDataSource {
 
  protected:
   // Exposed for testing.
+  virtual ui::NativeTheme* GetNativeTheme(
+      const content::WebContents::Getter& wc_getter);
   virtual base::RefCountedMemory* LoadIconBytes(float scale_factor,
                                                 int resource_id);
 
@@ -74,9 +76,6 @@ class FaviconSource : public content::URLDataSource {
   // Defines the allowed pixel sizes for requested favicons.
   enum IconSize { SIZE_16, SIZE_32, SIZE_64, NUM_SIZES };
 
-  ui::NativeTheme* GetNativeTheme(
-      const content::WebContents::Getter& wc_getter);
-
   // Called when favicon data is available from the history backend. If
   // |bitmap_result| is valid, returns it to caller using |callback|. Otherwise
   // will send appropriate default icon for |size_in_dip| and |scale_factor|.
diff --git a/chrome/browser/ui/webui/favicon_source_unittest.cc b/chrome/browser/ui/webui/favicon_source_unittest.cc
index a03acdf8bf514..1b420b398b465 100644
--- a/chrome/browser/ui/webui/favicon_source_unittest.cc
+++ b/chrome/browser/ui/webui/favicon_source_unittest.cc
@@ -31,8 +31,7 @@
 #include "extensions/common/manifest.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
-#include "ui/native_theme/native_theme.h"
+#include "ui/native_theme/test_native_theme.h"
 #include "ui/resources/grit/ui_resources.h"
 
 using GotDataCallback = content::URLDataSource::GotDataCallback;
@@ -68,16 +67,30 @@ class MockHistoryUiFaviconRequestHandler
 
 class TestFaviconSource : public FaviconSource {
  public:
-  using FaviconSource::FaviconSource;
+  TestFaviconSource(Profile* profile,
+                    chrome::FaviconUrlFormat format,
+                    bool serve_untrusted,
+                    ui::NativeTheme* theme)
+      : FaviconSource(profile, format, serve_untrusted), theme_(theme) {}
 
   MOCK_METHOD(base::RefCountedMemory*, LoadIconBytes, (float, int));
+
+ protected:
+  // FaviconSource:
+  ui::NativeTheme* GetNativeTheme(
+      const content::WebContents::Getter& wc_getter) override {
+    return theme_;
+  }
+
+ private:
+  const raw_ptr<ui::NativeTheme> theme_;
 };
 
 class FaviconSourceTestBase : public testing::Test {
  public:
   explicit FaviconSourceTestBase(chrome::FaviconUrlFormat format,
                                  bool serve_untrusted = false)
-      : source_(&profile_, format, serve_untrusted) {
+      : source_(&profile_, format, serve_untrusted, &theme_) {
     Init();
   }
 
@@ -123,11 +136,12 @@ class FaviconSourceTestBase : public testing::Test {
         .WillByDefault(Return(dummy_icon_bytes_.get()));
   }
 
- protected:
-  ui::MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
+  void SetPreferredColorScheme(
+      ui::NativeTheme::PreferredColorScheme color_scheme) {
+    theme_.SetPreferredColorScheme(color_scheme);
   }
 
+ protected:
   content::WebContents* test_web_contents() { return test_web_contents_.get(); }
 
   const WebContentsGetter& test_web_contents_getter() const {
@@ -146,17 +160,17 @@ class FaviconSourceTestBase : public testing::Test {
   NiceMock<TestFaviconSource>& source() { return source_; }
 
  private:
-  ui::MockOsSettingsProvider os_settings_provider_;
   content::BrowserTaskEnvironment task_environment_;
   content::RenderViewHostTestEnabler test_render_host_factories_;
   TestingProfile profile_;
+  ui::TestNativeTheme theme_;
   std::unique_ptr<content::WebContents> test_web_contents_;
   WebContentsGetter test_web_contents_getter_;
   raw_ptr<NiceMock<favicon::MockFaviconService>> mock_favicon_service_;
   raw_ptr<NiceMock<MockHistoryUiFaviconRequestHandler>>
       mock_history_ui_favicon_request_handler_;
   NiceMock<TestFaviconSource> source_;
-  scoped_refptr<base::RefCountedBytes> dummy_icon_bytes_;
+  const scoped_refptr<base::RefCountedBytes> dummy_icon_bytes_;
 };
 
 class FaviconSourceTestWithLegacyFormat : public FaviconSourceTestBase {
@@ -166,14 +180,14 @@ class FaviconSourceTestWithLegacyFormat : public FaviconSourceTestBase {
 };
 
 TEST_F(FaviconSourceTestWithLegacyFormat, DarkDefault) {
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kDark);
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_CALL(source(), LoadIconBytes(_, IDR_DEFAULT_FAVICON_DARK));
   source().StartDataRequest(GURL(kDummyPrefix), test_web_contents_getter(),
                             base::DoNothing());
 }
 
 TEST_F(FaviconSourceTestWithLegacyFormat, LightDefault) {
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_CALL(source(), LoadIconBytes(_, IDR_DEFAULT_FAVICON));
   source().StartDataRequest(GURL(kDummyPrefix), test_web_contents_getter(),
                             base::DoNothing());
@@ -247,22 +261,21 @@ TEST_P(FaviconSourceTestWithFavicon2Format,
 }
 
 TEST_P(FaviconSourceTestWithFavicon2Format, DarkDefault) {
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kDark);
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_CALL(source(), LoadIconBytes(_, IDR_DEFAULT_FAVICON_DARK));
   source().StartDataRequest(GURL(kDummyPrefix), test_web_contents_getter(),
                             base::DoNothing());
 }
 
 TEST_P(FaviconSourceTestWithFavicon2Format, LightDefault) {
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_CALL(source(), LoadIconBytes(_, IDR_DEFAULT_FAVICON));
   source().StartDataRequest(GURL(kDummyPrefix), test_web_contents_getter(),
                             base::DoNothing());
 }
 
 TEST_P(FaviconSourceTestWithFavicon2Format, LightOverride) {
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kDark);
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_CALL(source(), LoadIconBytes(_, IDR_DEFAULT_FAVICON));
   source().StartDataRequest(
       GURL(base::StrCat({kDummyPrefix,
diff --git a/chrome/browser/ui/webui/ntp/ntp_resource_cache.cc b/chrome/browser/ui/webui/ntp/ntp_resource_cache.cc
index 80d0b63cf4a67..a60445f716b71 100644
--- a/chrome/browser/ui/webui/ntp/ntp_resource_cache.cc
+++ b/chrome/browser/ui/webui/ntp/ntp_resource_cache.cc
@@ -95,8 +95,7 @@ SkColor GetThemeColor(const ui::NativeTheme* native_theme,
   // If web contents are being inverted because the system is in high-contrast
   // mode, any system theme colors we use must be inverted too to cancel out.
   // TODO(pkasting): I'm not sure this conditional is correct anymore.
-  return (native_theme->forced_colors() !=
-              ui::ColorProviderKey::ForcedColors::kNone &&
+  return (native_theme->forced_colors() &&
           native_theme->preferred_color_scheme() ==
               ui::NativeTheme::PreferredColorScheme::kDark)
              ? color_utils::InvertColor(color)
diff --git a/chrome/browser/ui/webui/side_panel/customize_chrome/customize_chrome_page_handler_unittest.cc b/chrome/browser/ui/webui/side_panel/customize_chrome/customize_chrome_page_handler_unittest.cc
index fdc7bb8998c21..5257d83b80c08 100644
--- a/chrome/browser/ui/webui/side_panel/customize_chrome/customize_chrome_page_handler_unittest.cc
+++ b/chrome/browser/ui/webui/side_panel/customize_chrome/customize_chrome_page_handler_unittest.cc
@@ -69,7 +69,6 @@
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/color/color_provider.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
 #include "ui/shell_dialogs/select_file_dialog_factory.h"
 #include "ui/shell_dialogs/selected_file_info.h"
@@ -532,7 +531,6 @@ class CustomizeChromePageHandlerSetThemeTest
 };
 
 TEST_P(CustomizeChromePageHandlerSetThemeTest, SetTheme) {
-  ui::MockOsSettingsProvider os_settings_provider;
   CustomBackground custom_background;
   custom_background.custom_background_url = GURL("https://foo.com/img.png");
   custom_background.custom_background_attribution_line_1 = "foo line";
@@ -552,7 +550,7 @@ TEST_P(CustomizeChromePageHandlerSetThemeTest, SetTheme) {
   ON_CALL(mock_ntp_custom_background_service_,
           IsCustomBackgroundDisabledByPolicy())
       .WillByDefault(Return(true));
-  os_settings_provider.SetPreferredColorScheme(
+  ui::NativeTheme::GetInstanceForNativeUi()->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
 
   side_panel::mojom::ThemePtr theme = UpdateTheme();
diff --git a/components/media_message_center/media_notification_background_impl_unittest.cc b/components/media_message_center/media_notification_background_impl_unittest.cc
index 071362b64797b..26e3f21819f91 100644
--- a/components/media_message_center/media_notification_background_impl_unittest.cc
+++ b/components/media_message_center/media_notification_background_impl_unittest.cc
@@ -14,7 +14,6 @@
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/gfx/color_utils.h"
 #include "ui/gfx/geometry/skia_conversions.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/views/test/test_views.h"
 #include "ui/views/test/views_test_base.h"
 
@@ -211,14 +210,15 @@ TEST_F(MediaNotificationBackgroundImplTest,
 }
 
 TEST_F(MediaNotificationBackgroundImplTest, GetBackgroundColorRespectsTheme) {
-  ui::MockOsSettingsProvider os_settings_provider;
-
   std::unique_ptr<views::Widget> widget =
       CreateTestWidget(views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET);
+  auto* theme = widget->GetNativeTheme();
+  theme->set_preferred_color_scheme(
+      ui::NativeTheme::PreferredColorScheme::kLight);
   auto* owner = widget->SetContentsView(std::make_unique<views::View>());
   SkColor light_background_color = background()->GetBackgroundColor(*owner);
 
-  os_settings_provider.SetPreferredColorScheme(
+  theme->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
   EXPECT_NE(light_background_color, background()->GetBackgroundColor(*owner));
 }
diff --git a/content/browser/accessibility/browser_accessibility_state_impl_android.cc b/content/browser/accessibility/browser_accessibility_state_impl_android.cc
index 978a699ccd729..48b4383b5635e 100644
--- a/content/browser/accessibility/browser_accessibility_state_impl_android.cc
+++ b/content/browser/accessibility/browser_accessibility_state_impl_android.cc
@@ -407,6 +407,29 @@ void BrowserAccessibilityStateImplAndroid::OnAnimatorDurationScaleChanged() {
   NotifyWebContentsPreferencesChanged();
 }
 
+void BrowserAccessibilityStateImplAndroid::OnDisplayInversionEnabledChanged(
+    bool enabled) {
+  // We need to call into GetInstanceForWeb on the UI thread,
+  // so ensure that we setup the notification on the correct thread.
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  ui::NativeTheme* native_theme = ui::NativeTheme::GetInstanceForWeb();
+  native_theme->set_inverted_colors(enabled);
+  native_theme->NotifyOnNativeThemeUpdated();
+}
+
+void BrowserAccessibilityStateImplAndroid::OnContrastLevelChanged(
+    bool highContrastEnabled) {
+  // We need to call into GetInstanceForWeb on the UI thread,
+  // so ensure that we setup the notification on the correct thread.
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  ui::NativeTheme* native_theme = ui::NativeTheme::GetInstanceForWeb();
+  native_theme->SetPreferredContrast(
+      highContrastEnabled ? ui::NativeTheme::PreferredContrast::kMore
+                          : ui::NativeTheme::PreferredContrast::kNoPreference);
+  native_theme->set_prefers_reduced_transparency(highContrastEnabled);
+  native_theme->NotifyOnNativeThemeUpdated();
+}
+
 void BrowserAccessibilityStateImplAndroid::RefreshAssistiveTech() {
   bool is_active = GetAccessibilityMode().has_mode(ui::AXMode::kScreenReader);
   static auto* ax_talkback_crash_key = base::debug::AllocateCrashKeyString(
diff --git a/content/browser/accessibility/browser_accessibility_state_impl_android.h b/content/browser/accessibility/browser_accessibility_state_impl_android.h
index cc211e354e345..8ac35f0315b0f 100644
--- a/content/browser/accessibility/browser_accessibility_state_impl_android.h
+++ b/content/browser/accessibility/browser_accessibility_state_impl_android.h
@@ -20,6 +20,8 @@ class BrowserAccessibilityStateImplAndroid
 
   // ui::AccessibilityState::AccessibilityStateObserver:
   void OnAnimatorDurationScaleChanged() override;
+  void OnDisplayInversionEnabledChanged(bool enabled) override;
+  void OnContrastLevelChanged(bool highContrastEnabled) override;
   void RecordAccessibilityServiceInfoHistograms() override;
 
   // BrowserAccessibilityStateImpl implementation.
diff --git a/content/shell/BUILD.gn b/content/shell/BUILD.gn
index 1c30c1e268004..6635030850913 100644
--- a/content/shell/BUILD.gn
+++ b/content/shell/BUILD.gn
@@ -102,7 +102,6 @@ static_library("content_shell_app") {
       "//content/web_test:web_test_browser",
       "//content/web_test:web_test_common",
       "//content/web_test:web_test_renderer",
-      "//ui/native_theme",
     ]
   }
   if (!is_fuchsia) {
@@ -460,6 +459,7 @@ static_library("content_shell_lib") {
       public_deps += [ "//ui/base/mojom:ui_base_types" ]
       deps += [
         "//ui/color:color_headers",
+        "//ui/native_theme",
         "//ui/resources",
         "//ui/views:test_support",
         "//ui/views/controls/webview",
diff --git a/content/shell/app/shell_main_delegate.cc b/content/shell/app/shell_main_delegate.cc
index 18c383888eba3..576e2f105357b 100644
--- a/content/shell/app/shell_main_delegate.cc
+++ b/content/shell/app/shell_main_delegate.cc
@@ -5,7 +5,6 @@
 #include "content/shell/app/shell_main_delegate.h"
 
 #include <iostream>
-#include <memory>
 #include <tuple>
 #include <utility>
 #include <variant>
@@ -47,7 +46,6 @@
 #include "content/web_test/browser/web_test_browser_main_runner.h"  // nogncheck
 #include "content/web_test/browser/web_test_content_browser_client.h"  // nogncheck
 #include "content/web_test/renderer/web_test_content_renderer_client.h"  // nogncheck
-#include "ui/native_theme/mock_os_settings_provider.h"  // nogncheck
 #endif
 
 #if BUILDFLAG(IS_ANDROID)
@@ -237,12 +235,6 @@ std::optional<int> ShellMainDelegate::BasicStartupComplete() {
 
 #if !BUILDFLAG(IS_ANDROID)
   if (switches::IsRunWebTestsSwitchPresent()) {
-    // Instantiating `ui::OsSettingsProvider` will both provide sane default
-    // behavior and prevent `ui::OsSettingsProvider::Get()` from instantiating a
-    // platform-specific subclass.
-    os_settings_provider_ = std::make_unique<ui::OsSettingsProvider>(
-        ui::OsSettingsProvider::PriorityLevel::kTesting);
-
     const bool browser_process =
         command_line.GetSwitchValueASCII(switches::kProcessType).empty();
     if (browser_process) {
diff --git a/content/shell/app/shell_main_delegate.h b/content/shell/app/shell_main_delegate.h
index 1e681fefdcde6..7215a58d0a363 100644
--- a/content/shell/app/shell_main_delegate.h
+++ b/content/shell/app/shell_main_delegate.h
@@ -13,12 +13,6 @@
 #include "components/memory_system/memory_system.h"
 #include "content/public/app/content_main_delegate.h"
 
-#if !BUILDFLAG(IS_ANDROID)
-namespace ui {
-class OsSettingsProvider;
-}
-#endif
-
 namespace content {
 class ShellContentClient;
 class ShellContentBrowserClient;
@@ -70,11 +64,7 @@ class ShellMainDelegate : public ContentMainDelegate {
 
 #if !BUILDFLAG(IS_ANDROID)
   // Only present when running web tests, which run inside Content Shell.
-
-  // Web tests should not use the current machine settings for theming, but
-  // should default to a consistent baseline.
-  std::unique_ptr<ui::OsSettingsProvider> os_settings_provider_;
-
+  //
   // Web tests are not browser tests, so |is_content_browsertests_| and
   // |web_test_runner_| are mututally exclusive.
   std::unique_ptr<WebTestBrowserMainRunner> web_test_runner_;
diff --git a/third_party/blink/renderer/core/paint/theme_painter_default.cc b/third_party/blink/renderer/core/paint/theme_painter_default.cc
index f575e4a49afb7..19c4bc18bf173 100644
--- a/third_party/blink/renderer/core/paint/theme_painter_default.cc
+++ b/third_party/blink/renderer/core/paint/theme_painter_default.cc
@@ -53,6 +53,7 @@
 #include "ui/color/color_provider.h"
 #include "ui/gfx/color_utils.h"
 #include "ui/gfx/geometry/rect_conversions.h"
+#include "ui/native_theme/native_theme.h"
 
 namespace blink {
 
@@ -102,11 +103,10 @@ SkColor GetContrastingColorFor(const Element& element,
   switch (part) {
     case WebThemeEngine::kPartCheckbox:
     case WebThemeEngine::kPartRadio:
-      return is_disabled
-                 ? color_provider->GetColor(
-                       ui::kColorWebNativeControlCheckboxBackgroundDisabled)
-                 : color_provider->GetColor(
-                       ui::kColorWebNativeControlCheckboxBackground);
+      return is_disabled ? color_provider->GetColor(
+                               ui::kColorWebNativeControlBackgroundDisabled)
+                         : color_provider->GetColor(
+                               ui::kColorWebNativeControlBackground);
     case WebThemeEngine::kPartSliderTrack:
     case WebThemeEngine::kPartSliderThumb:
     case WebThemeEngine::kPartProgressBar:
diff --git a/third_party/blink/renderer/platform/theme/web_theme_engine_conversions.cc b/third_party/blink/renderer/platform/theme/web_theme_engine_conversions.cc
index f297760fb9c81..a3ee45ea3b7ad 100644
--- a/third_party/blink/renderer/platform/theme/web_theme_engine_conversions.cc
+++ b/third_party/blink/renderer/platform/theme/web_theme_engine_conversions.cc
@@ -56,9 +56,10 @@ NT::PreferredColorScheme NativeColorScheme(
   return kColorSchemeMap.at(color_scheme);
 }
 
-NT::PreferredContrast NativeContrast(mojom::blink::PreferredContrast contrast) {
+ui::NativeTheme::PreferredContrast NativeContrast(
+    mojom::blink::PreferredContrast contrast) {
   using MPC = mojom::blink::PreferredContrast;
-  using NTPC = NT::PreferredContrast;
+  using NTPC = ui::NativeTheme::PreferredContrast;
   static constexpr auto kContrastMap = base::MakeFixedFlatMap<MPC, NTPC>(
       {{MPC::kMore, NTPC::kMore},
        {MPC::kLess, NTPC::kLess},
diff --git a/third_party/blink/renderer/platform/theme/web_theme_engine_default.cc b/third_party/blink/renderer/platform/theme/web_theme_engine_default.cc
index a356e37e92299..77c9f053a9a94 100644
--- a/third_party/blink/renderer/platform/theme/web_theme_engine_default.cc
+++ b/third_party/blink/renderer/platform/theme/web_theme_engine_default.cc
@@ -273,7 +273,7 @@ SkColor4f WebThemeEngineDefault::GetScrollbarThumbColor(
 
   return SkColor4f::FromColor(
       ui::NativeTheme::GetInstanceForWeb()->GetScrollbarThumbColor(
-          color_provider, NativeThemeState(state), native_theme_extra_params));
+          *color_provider, NativeThemeState(state), native_theme_extra_params));
 }
 
 void WebThemeEngineDefault::GetOverlayScrollbarStyle(ScrollbarStyle* style) {
diff --git a/third_party/blink/web_tests/virtual/fluent-overlay-scrollbar/README.md b/third_party/blink/web_tests/virtual/fluent-overlay-scrollbar/README.md
index 28bca36697e5c..d6571376b901d 100644
--- a/third_party/blink/web_tests/virtual/fluent-overlay-scrollbar/README.md
+++ b/third_party/blink/web_tests/virtual/fluent-overlay-scrollbar/README.md
@@ -4,7 +4,7 @@ Please see more details here: https://crbug.com/1479156.
 
 If you are trying to rebase Win10 expectations in a Win11 machine, you can
 follow these instructions to temporarily disable Win11 arrows:
-1. Navigate to `ui/native_theme/native_theme_fluent.cc`.
+1. Navigate to `ui/native_theme/native_theme_constants_fluent.h`.
 1. Change the value `"Segoe Fluent Icons"` to another name, e.g.
    `"Segoe Fluent Icons1"`.
 1. Rebuild.
diff --git a/ui/color/color_id.h b/ui/color/color_id.h
index e340ccdfb4c36..b6fe461a04dfa 100644
--- a/ui/color/color_id.h
+++ b/ui/color/color_id.h
@@ -546,6 +546,8 @@
   E_CPONLY(kColorWebNativeControlAccentHovered) \
   E_CPONLY(kColorWebNativeControlAccentPressed) \
   E_CPONLY(kColorWebNativeControlAutoCompleteBackground) \
+  E_CPONLY(kColorWebNativeControlBackground) \
+  E_CPONLY(kColorWebNativeControlBackgroundDisabled) \
   E_CPONLY(kColorWebNativeControlBorder) \
   E_CPONLY(kColorWebNativeControlBorderDisabled) \
   E_CPONLY(kColorWebNativeControlBorderHovered) \
@@ -558,30 +560,24 @@
   E_CPONLY(kColorWebNativeControlButtonFillDisabled) \
   E_CPONLY(kColorWebNativeControlButtonFillHovered) \
   E_CPONLY(kColorWebNativeControlButtonFillPressed) \
-  E_CPONLY(kColorWebNativeControlCheckboxBackground) \
-  E_CPONLY(kColorWebNativeControlCheckboxBackgroundDisabled) \
   E_CPONLY(kColorWebNativeControlFill) \
   E_CPONLY(kColorWebNativeControlFillDisabled) \
   E_CPONLY(kColorWebNativeControlFillHovered) \
   E_CPONLY(kColorWebNativeControlFillPressed) \
   E_CPONLY(kColorWebNativeControlLightenLayer) \
   E_CPONLY(kColorWebNativeControlProgressValue) \
-  E_CPONLY(kColorWebNativeControlScrollbarArrowBackgroundDisabled) \
   E_CPONLY(kColorWebNativeControlScrollbarArrowBackgroundHovered) \
   E_CPONLY(kColorWebNativeControlScrollbarArrowBackgroundPressed) \
   E_CPONLY(kColorWebNativeControlScrollbarArrowForeground) \
-  E_CPONLY(kColorWebNativeControlScrollbarArrowForegroundDisabled) \
   E_CPONLY(kColorWebNativeControlScrollbarArrowForegroundPressed) \
   E_CPONLY(kColorWebNativeControlScrollbarCorner) \
   E_CPONLY(kColorWebNativeControlScrollbarThumb) \
   E_CPONLY(kColorWebNativeControlScrollbarThumbHovered) \
+  E_CPONLY(kColorWebNativeControlScrollbarThumbInactive) \
   E_CPONLY(kColorWebNativeControlScrollbarThumbOverlayMinimalMode) \
   E_CPONLY(kColorWebNativeControlScrollbarThumbPressed) \
   E_CPONLY(kColorWebNativeControlScrollbarTrack) \
   E_CPONLY(kColorWebNativeControlSlider) \
-  E_CPONLY(kColorWebNativeControlSliderBorder) \
-  E_CPONLY(kColorWebNativeControlSliderBorderHovered) \
-  E_CPONLY(kColorWebNativeControlSliderBorderPressed) \
   E_CPONLY(kColorWebNativeControlSliderDisabled) \
   E_CPONLY(kColorWebNativeControlSliderHovered) \
   E_CPONLY(kColorWebNativeControlSliderPressed) \
diff --git a/ui/color/color_id.mojom b/ui/color/color_id.mojom
index 4b05e525ee4bd..e54117be123c6 100644
--- a/ui/color/color_id.mojom
+++ b/ui/color/color_id.mojom
@@ -36,6 +36,8 @@ enum RendererColorId {
   kColorWebNativeControlAccentHovered,
   kColorWebNativeControlAccentPressed,
   kColorWebNativeControlAutoCompleteBackground,
+  kColorWebNativeControlBackground,
+  kColorWebNativeControlBackgroundDisabled,
   kColorWebNativeControlBorder,
   kColorWebNativeControlBorderDisabled,
   kColorWebNativeControlBorderHovered,
@@ -48,30 +50,24 @@ enum RendererColorId {
   kColorWebNativeControlButtonFillDisabled,
   kColorWebNativeControlButtonFillHovered,
   kColorWebNativeControlButtonFillPressed,
-  kColorWebNativeControlCheckboxBackground,
-  kColorWebNativeControlCheckboxBackgroundDisabled,
   kColorWebNativeControlFill,
   kColorWebNativeControlFillDisabled,
   kColorWebNativeControlFillHovered,
   kColorWebNativeControlFillPressed,
   kColorWebNativeControlLightenLayer,
   kColorWebNativeControlProgressValue,
-  kColorWebNativeControlScrollbarArrowBackgroundDisabled,
   kColorWebNativeControlScrollbarArrowBackgroundHovered,
   kColorWebNativeControlScrollbarArrowBackgroundPressed,
   kColorWebNativeControlScrollbarArrowForeground,
-  kColorWebNativeControlScrollbarArrowForegroundDisabled,
   kColorWebNativeControlScrollbarArrowForegroundPressed,
   kColorWebNativeControlScrollbarCorner,
   kColorWebNativeControlScrollbarThumb,
   kColorWebNativeControlScrollbarThumbHovered,
+  kColorWebNativeControlScrollbarThumbInactive,
   kColorWebNativeControlScrollbarThumbOverlayMinimalMode,
   kColorWebNativeControlScrollbarThumbPressed,
   kColorWebNativeControlScrollbarTrack,
   kColorWebNativeControlSlider,
-  kColorWebNativeControlSliderBorder,
-  kColorWebNativeControlSliderBorderHovered,
-  kColorWebNativeControlSliderBorderPressed,
   kColorWebNativeControlSliderDisabled,
   kColorWebNativeControlSliderHovered,
   kColorWebNativeControlSliderPressed,
diff --git a/ui/color/color_provider_utils.cc b/ui/color/color_provider_utils.cc
index 8a526c14c865e..e4587544d0d0a 100644
--- a/ui/color/color_provider_utils.cc
+++ b/ui/color/color_provider_utils.cc
@@ -66,10 +66,10 @@ constexpr RendererColorIdTable kRendererColorIdMap[] = {
      kColorWebNativeControlAccentPressed},
     {RendererColorId::kColorWebNativeControlAutoCompleteBackground,
      kColorWebNativeControlAutoCompleteBackground},
-    {RendererColorId::kColorWebNativeControlCheckboxBackground,
-     kColorWebNativeControlCheckboxBackground},
-    {RendererColorId::kColorWebNativeControlCheckboxBackgroundDisabled,
-     kColorWebNativeControlCheckboxBackgroundDisabled},
+    {RendererColorId::kColorWebNativeControlBackground,
+     kColorWebNativeControlBackground},
+    {RendererColorId::kColorWebNativeControlBackgroundDisabled,
+     kColorWebNativeControlBackgroundDisabled},
     {RendererColorId::kColorWebNativeControlBorder,
      kColorWebNativeControlBorder},
     {RendererColorId::kColorWebNativeControlBorderDisabled,
@@ -105,16 +105,12 @@ constexpr RendererColorIdTable kRendererColorIdMap[] = {
      kColorWebNativeControlLightenLayer},
     {RendererColorId::kColorWebNativeControlProgressValue,
      kColorWebNativeControlProgressValue},
-    {RendererColorId::kColorWebNativeControlScrollbarArrowBackgroundDisabled,
-     kColorWebNativeControlScrollbarArrowBackgroundDisabled},
     {RendererColorId::kColorWebNativeControlScrollbarArrowBackgroundHovered,
      kColorWebNativeControlScrollbarArrowBackgroundHovered},
     {RendererColorId::kColorWebNativeControlScrollbarArrowBackgroundPressed,
      kColorWebNativeControlScrollbarArrowBackgroundPressed},
     {RendererColorId::kColorWebNativeControlScrollbarArrowForeground,
      kColorWebNativeControlScrollbarArrowForeground},
-    {RendererColorId::kColorWebNativeControlScrollbarArrowForegroundDisabled,
-     kColorWebNativeControlScrollbarArrowForegroundDisabled},
     {RendererColorId::kColorWebNativeControlScrollbarArrowForegroundPressed,
      kColorWebNativeControlScrollbarArrowForegroundPressed},
     {RendererColorId::kColorWebNativeControlScrollbarCorner,
@@ -123,6 +119,8 @@ constexpr RendererColorIdTable kRendererColorIdMap[] = {
      kColorWebNativeControlScrollbarThumb},
     {RendererColorId::kColorWebNativeControlScrollbarThumbHovered,
      kColorWebNativeControlScrollbarThumbHovered},
+    {RendererColorId::kColorWebNativeControlScrollbarThumbInactive,
+     kColorWebNativeControlScrollbarThumbInactive},
     {RendererColorId::kColorWebNativeControlScrollbarThumbOverlayMinimalMode,
      kColorWebNativeControlScrollbarThumbOverlayMinimalMode},
     {RendererColorId::kColorWebNativeControlScrollbarThumbPressed,
@@ -131,12 +129,6 @@ constexpr RendererColorIdTable kRendererColorIdMap[] = {
      kColorWebNativeControlScrollbarTrack},
     {RendererColorId::kColorWebNativeControlSlider,
      kColorWebNativeControlSlider},
-    {RendererColorId::kColorWebNativeControlSliderBorder,
-     kColorWebNativeControlSliderBorder},
-    {RendererColorId::kColorWebNativeControlSliderBorderHovered,
-     kColorWebNativeControlSliderBorderHovered},
-    {RendererColorId::kColorWebNativeControlSliderBorderPressed,
-     kColorWebNativeControlSliderBorderPressed},
     {RendererColorId::kColorWebNativeControlSliderDisabled,
      kColorWebNativeControlSliderDisabled},
     {RendererColorId::kColorWebNativeControlSliderHovered,
@@ -403,6 +395,8 @@ CreateEmulatedForcedColorsColorProviderForTest() {
   mixer[kColorWebNativeControlAccentHovered] = {SK_ColorCYAN};
   mixer[kColorWebNativeControlAccentPressed] = {SK_ColorCYAN};
   mixer[kColorWebNativeControlAutoCompleteBackground] = {SK_ColorBLACK};
+  mixer[kColorWebNativeControlBackground] = {SK_ColorBLACK};
+  mixer[kColorWebNativeControlBackgroundDisabled] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlBorder] = {SK_ColorWHITE};
   mixer[kColorWebNativeControlBorderDisabled] = {SK_ColorGREEN};
   mixer[kColorWebNativeControlBorderHovered] = {SK_ColorWHITE};
@@ -415,38 +409,30 @@ CreateEmulatedForcedColorsColorProviderForTest() {
   mixer[kColorWebNativeControlButtonFillDisabled] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlButtonFillHovered] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlButtonFillPressed] = {SK_ColorBLACK};
-  mixer[kColorWebNativeControlCheckboxBackground] = {SK_ColorBLACK};
-  mixer[kColorWebNativeControlCheckboxBackgroundDisabled] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlFill] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlFillDisabled] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlFillHovered] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlFillPressed] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlLightenLayer] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlProgressValue] = {SK_ColorCYAN};
-  mixer[kColorWebNativeControlScrollbarArrowBackgroundDisabled] = {
-      SK_ColorWHITE};
   mixer[kColorWebNativeControlScrollbarArrowBackgroundHovered] = {
       SkColorSetRGB(0x1A, 0xEB, 0xFF)};
   mixer[kColorWebNativeControlScrollbarArrowBackgroundPressed] = {
       SkColorSetRGB(0x1A, 0xEB, 0xFF)};
   mixer[kColorWebNativeControlScrollbarArrowForeground] = {SK_ColorBLACK};
-  mixer[kColorWebNativeControlScrollbarArrowForegroundDisabled] = {
-      SK_ColorBLACK};
   mixer[kColorWebNativeControlScrollbarArrowForegroundPressed] = {
       SK_ColorBLACK};
   mixer[kColorWebNativeControlScrollbarCorner] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlScrollbarThumb] = {SK_ColorBLACK};
   mixer[kColorWebNativeControlScrollbarThumbHovered] = {
       SkColorSetRGB(0x1A, 0xEB, 0xFF)};
+  mixer[kColorWebNativeControlScrollbarThumbInactive] = {SK_ColorWHITE};
   mixer[kColorWebNativeControlScrollbarThumbOverlayMinimalMode] = {
       SK_ColorBLACK};
   mixer[kColorWebNativeControlScrollbarThumbPressed] = {
       SkColorSetRGB(0x1A, 0xEB, 0xFF)};
   mixer[kColorWebNativeControlScrollbarTrack] = {SK_ColorWHITE};
   mixer[kColorWebNativeControlSlider] = {SK_ColorCYAN};
-  mixer[kColorWebNativeControlSliderBorder] = {SK_ColorWHITE};
-  mixer[kColorWebNativeControlSliderBorderHovered] = {SK_ColorWHITE};
-  mixer[kColorWebNativeControlSliderBorderPressed] = {SK_ColorWHITE};
   mixer[kColorWebNativeControlSliderDisabled] = {SK_ColorGREEN};
   mixer[kColorWebNativeControlSliderHovered] = {SK_ColorCYAN};
   mixer[kColorWebNativeControlSliderPressed] = {SK_ColorCYAN};
@@ -488,6 +474,8 @@ void CompleteScrollbarColorsDefinition(ui::ColorMixer& mixer) {
       kColorWebNativeControlScrollbarArrowForeground};
   mixer[kColorWebNativeControlScrollbarThumbHovered] = {
       kColorWebNativeControlScrollbarArrowForegroundPressed};
+  mixer[kColorWebNativeControlScrollbarThumbInactive] = {
+      kColorWebNativeControlScrollbarThumb};
   mixer[kColorWebNativeControlScrollbarThumbPressed] = {
       kColorWebNativeControlScrollbarThumbHovered};
   mixer[kColorWebNativeControlScrollbarTrack] = {
@@ -500,6 +488,8 @@ void CompleteControlsForcedColorsDefinition(ui::ColorMixer& mixer) {
   mixer[kColorWebNativeControlAccentHovered] = {kColorCssSystemHighlight};
   mixer[kColorWebNativeControlAccentPressed] = {kColorCssSystemHighlight};
   mixer[kColorWebNativeControlAutoCompleteBackground] = {kColorCssSystemWindow};
+  mixer[kColorWebNativeControlBackground] = {kColorCssSystemWindow};
+  mixer[kColorWebNativeControlBackgroundDisabled] = {kColorCssSystemWindow};
   mixer[kColorWebNativeControlBorder] = {kColorCssSystemBtnText};
   mixer[kColorWebNativeControlBorderDisabled] = {kColorCssSystemGrayText};
   mixer[kColorWebNativeControlBorderHovered] = {kColorCssSystemBtnText};
@@ -512,30 +502,20 @@ void CompleteControlsForcedColorsDefinition(ui::ColorMixer& mixer) {
   mixer[kColorWebNativeControlButtonFillDisabled] = {kColorCssSystemWindow};
   mixer[kColorWebNativeControlButtonFillHovered] = {kColorCssSystemWindow};
   mixer[kColorWebNativeControlButtonFillPressed] = {kColorCssSystemWindow};
-  mixer[kColorWebNativeControlCheckboxBackground] = {kColorCssSystemWindow};
-  mixer[kColorWebNativeControlCheckboxBackgroundDisabled] = {
-      kColorCssSystemWindow};
   mixer[kColorWebNativeControlFill] = {kColorCssSystemWindow};
   mixer[kColorWebNativeControlFillDisabled] = {kColorCssSystemWindow};
   mixer[kColorWebNativeControlFillHovered] = {kColorCssSystemWindow};
   mixer[kColorWebNativeControlFillPressed] = {kColorCssSystemWindow};
   mixer[kColorWebNativeControlLightenLayer] = {kColorCssSystemWindow};
   mixer[kColorWebNativeControlProgressValue] = {kColorCssSystemHighlight};
-  mixer[kColorWebNativeControlScrollbarArrowBackgroundDisabled] = {
-      kColorCssSystemWindow};
   mixer[kColorWebNativeControlScrollbarArrowForeground] = {
       kColorCssSystemBtnText};
-  mixer[kColorWebNativeControlScrollbarArrowForegroundDisabled] = {
-      kColorCssSystemGrayText};
   mixer[kColorWebNativeControlScrollbarArrowForegroundPressed] = {
       kColorCssSystemHighlight};
   mixer[kColorWebNativeControlScrollbarThumbOverlayMinimalMode] = {
       kColorCssSystemBtnText};
   mixer[kColorWebNativeControlScrollbarCorner] = {kColorCssSystemBtnFace};
   mixer[kColorWebNativeControlSlider] = {kColorCssSystemHighlight};
-  mixer[kColorWebNativeControlSliderBorder] = {kColorCssSystemBtnText};
-  mixer[kColorWebNativeControlSliderBorderHovered] = {kColorCssSystemBtnText};
-  mixer[kColorWebNativeControlSliderBorderPressed] = {kColorCssSystemBtnText};
   mixer[kColorWebNativeControlSliderDisabled] = {kColorCssSystemGrayText};
   mixer[kColorWebNativeControlSliderHovered] = {kColorCssSystemHighlight};
   mixer[kColorWebNativeControlSliderPressed] = {kColorCssSystemHighlight};
@@ -589,6 +569,9 @@ void COMPONENT_EXPORT(COLOR)
         SkColorSetRGB(0x61, 0xA9, 0xFF)};
     mixer[kColorWebNativeControlAutoCompleteBackground] = {
         SkColorSetARGB(0x66, 0x46, 0x5a, 0x7E)};
+    mixer[kColorWebNativeControlBackground] = {SkColorSetRGB(0x3B, 0x3B, 0x3B)};
+    mixer[kColorWebNativeControlBackgroundDisabled] = {
+        SkColorSetRGB(0x3B, 0x3B, 0x3B)};
     mixer[kColorWebNativeControlBorder] = {SkColorSetRGB(0x85, 0x85, 0x85)};
     mixer[kColorWebNativeControlBorderDisabled] = {
         SkColorSetRGB(0x62, 0x62, 0x62)};
@@ -611,10 +594,6 @@ void COMPONENT_EXPORT(COLOR)
         SkColorSetRGB(0x7B, 0x7B, 0x7B)};
     mixer[kColorWebNativeControlButtonFillPressed] = {
         SkColorSetRGB(0x61, 0x61, 0x61)};
-    mixer[kColorWebNativeControlCheckboxBackground] = {
-        SkColorSetRGB(0x3B, 0x3B, 0x3B)};
-    mixer[kColorWebNativeControlCheckboxBackgroundDisabled] = {
-        SkColorSetRGB(0x3B, 0x3B, 0x3B)};
     mixer[kColorWebNativeControlFill] = {SkColorSetRGB(0x3B, 0x3B, 0x3B)};
     mixer[kColorWebNativeControlFillDisabled] = {
         SkColorSetRGB(0x36, 0x36, 0x36)};
@@ -626,15 +605,11 @@ void COMPONENT_EXPORT(COLOR)
         SkColorSetRGB(0x3B, 0x3B, 0x3B)};
     mixer[kColorWebNativeControlProgressValue] = {
         SkColorSetRGB(0x63, 0xAD, 0xE5)};
-    mixer[kColorWebNativeControlScrollbarArrowBackgroundDisabled] = {
-        SkColorSetRGB(0x36, 0x36, 0x36)};
     mixer[kColorWebNativeControlScrollbarArrowBackgroundHovered] = {
         SkColorSetRGB(0x4F, 0x4F, 0x4F)};
     mixer[kColorWebNativeControlScrollbarArrowBackgroundPressed] = {
         SkColorSetRGB(0xB1, 0xB1, 0xB1)};
     mixer[kColorWebNativeControlScrollbarArrowForeground] = {SK_ColorWHITE};
-    mixer[kColorWebNativeControlScrollbarArrowForegroundDisabled] = {
-        SkColorSetRGB(0xAF, 0xAF, 0xAF)};
     mixer[kColorWebNativeControlScrollbarArrowForegroundPressed] = {
         SK_ColorBLACK};
     mixer[kColorWebNativeControlScrollbarCorner] = {
@@ -643,6 +618,7 @@ void COMPONENT_EXPORT(COLOR)
         SkColorSetA(SK_ColorWHITE, 0x33)};
     mixer[kColorWebNativeControlScrollbarThumbHovered] = {
         SkColorSetA(SK_ColorWHITE, 0x4D)};
+    mixer[kColorWebNativeControlScrollbarThumbInactive] = {SK_ColorWHITE};
     mixer[kColorWebNativeControlScrollbarThumbOverlayMinimalMode] = {
         SkColorSetA(SK_ColorWHITE, 0x8B)};
     mixer[kColorWebNativeControlScrollbarThumbPressed] = {
@@ -650,11 +626,6 @@ void COMPONENT_EXPORT(COLOR)
     mixer[kColorWebNativeControlScrollbarTrack] = {
         SkColorSetRGB(0x42, 0x42, 0x42)};
     mixer[kColorWebNativeControlSlider] = {SkColorSetRGB(0x99, 0xC8, 0xFF)};
-    mixer[kColorWebNativeControlSliderBorder] = {kColorWebNativeControlBorder};
-    mixer[kColorWebNativeControlSliderBorderHovered] = {
-        kColorWebNativeControlBorderHovered};
-    mixer[kColorWebNativeControlSliderBorderPressed] = {
-        kColorWebNativeControlBorderPressed};
     mixer[kColorWebNativeControlSliderDisabled] = {
         SkColorSetRGB(0x75, 0x75, 0x75)};
     mixer[kColorWebNativeControlSliderHovered] = {
@@ -671,6 +642,9 @@ void COMPONENT_EXPORT(COLOR)
         SkColorSetRGB(0x37, 0x93, 0xFF)};
     mixer[kColorWebNativeControlAutoCompleteBackground] = {
         SkColorSetRGB(0xE8, 0xF0, 0xFE)};
+    mixer[kColorWebNativeControlBackground] = {SK_ColorWHITE};
+    mixer[kColorWebNativeControlBackgroundDisabled] = {
+        SkColorSetA(SK_ColorWHITE, 0x99)};
     mixer[kColorWebNativeControlBorder] = {SkColorSetRGB(0x76, 0x76, 0x76)};
     mixer[kColorWebNativeControlBorderDisabled] = {
         SkColorSetARGB(0x4D, 0x76, 0x76, 0x76)};
@@ -693,9 +667,6 @@ void COMPONENT_EXPORT(COLOR)
         SkColorSetRGB(0xE5, 0xE5, 0xE5)};
     mixer[kColorWebNativeControlButtonFillPressed] = {
         SkColorSetRGB(0xF5, 0xF5, 0xF5)};
-    mixer[kColorWebNativeControlCheckboxBackground] = {SK_ColorWHITE};
-    mixer[kColorWebNativeControlCheckboxBackgroundDisabled] = {
-        SkColorSetA(SK_ColorWHITE, 0x99)};
     mixer[kColorWebNativeControlFill] = {SkColorSetRGB(0xEF, 0xEF, 0xEF)};
     mixer[kColorWebNativeControlFillDisabled] = {
         SkColorSetARGB(0x4D, 0xEF, 0xEF, 0xEF)};
@@ -707,16 +678,12 @@ void COMPONENT_EXPORT(COLOR)
         SkColorSetARGB(0x33, 0xA9, 0xA9, 0xA9)};
     mixer[kColorWebNativeControlProgressValue] = {
         SkColorSetRGB(0x00, 0x75, 0xFF)};
-    mixer[kColorWebNativeControlScrollbarArrowBackgroundDisabled] = {
-        SkColorSetARGB(0x4D, 0xF1, 0xF1, 0xF1)};
     mixer[kColorWebNativeControlScrollbarArrowBackgroundHovered] = {
         SkColorSetRGB(0xD2, 0xD2, 0xD2)};
     mixer[kColorWebNativeControlScrollbarArrowBackgroundPressed] = {
         SkColorSetRGB(0x78, 0x78, 0x78)};
     mixer[kColorWebNativeControlScrollbarArrowForeground] = {
         SkColorSetRGB(0x50, 0x50, 0x50)};
-    mixer[kColorWebNativeControlScrollbarArrowForegroundDisabled] = {
-        SkColorSetARGB(0x4D, 0x50, 0x50, 0x50)};
     mixer[kColorWebNativeControlScrollbarArrowForegroundPressed] = {
         SK_ColorWHITE};
     mixer[kColorWebNativeControlScrollbarCorner] = {
@@ -725,6 +692,8 @@ void COMPONENT_EXPORT(COLOR)
         SkColorSetA(SK_ColorBLACK, 0x33)};
     mixer[kColorWebNativeControlScrollbarThumbHovered] = {
         SkColorSetA(SK_ColorBLACK, 0x4D)};
+    mixer[kColorWebNativeControlScrollbarThumbInactive] = {
+        SkColorSetRGB(0xEA, 0xEA, 0xEA)};
     mixer[kColorWebNativeControlScrollbarThumbOverlayMinimalMode] = {
         SkColorSetA(SK_ColorBLACK, 0x72)};
     mixer[kColorWebNativeControlScrollbarThumbPressed] = {
@@ -732,15 +701,6 @@ void COMPONENT_EXPORT(COLOR)
     mixer[kColorWebNativeControlScrollbarTrack] = {
         SkColorSetRGB(0xF1, 0xF1, 0xF1)};
     mixer[kColorWebNativeControlSlider] = {SkColorSetRGB(0x00, 0x75, 0xFF)};
-    mixer[kColorWebNativeControlSliderBorder] =
-        high_contrast ? kColorWebNativeControlBorder
-                      : SetAlpha(kColorWebNativeControlBorder, 0x80);
-    mixer[kColorWebNativeControlSliderBorderHovered] =
-        high_contrast ? kColorWebNativeControlBorderHovered
-                      : SetAlpha(kColorWebNativeControlBorderHovered, 0x80);
-    mixer[kColorWebNativeControlSliderBorderPressed] =
-        high_contrast ? kColorWebNativeControlBorderPressed
-                      : SetAlpha(kColorWebNativeControlBorderPressed, 0x80);
     mixer[kColorWebNativeControlSliderDisabled] = {
         SkColorSetRGB(0xCB, 0xCB, 0xCB)};
     mixer[kColorWebNativeControlSliderHovered] = {
diff --git a/ui/color/fluent_ui_color_mixer.cc b/ui/color/fluent_ui_color_mixer.cc
index e39b3880cdaa4..e38a8f3a0939c 100644
--- a/ui/color/fluent_ui_color_mixer.cc
+++ b/ui/color/fluent_ui_color_mixer.cc
@@ -19,13 +19,9 @@ void AddFluentUiColorMixer(ColorProvider* provider,
   if (key.contrast_mode == ColorProviderKey::ContrastMode::kNormal) {
     const bool dark_mode = key.color_mode == ColorProviderKey::ColorMode::kDark;
 
-    mixer[kColorWebNativeControlScrollbarArrowBackgroundDisabled] = {
-        kColorWebNativeControlScrollbarCorner};
     mixer[kColorWebNativeControlScrollbarArrowForeground] = {
         dark_mode ? SkColorSetRGB(0x9F, 0x9F, 0x9F)
                   : SkColorSetRGB(0x8B, 0x8B, 0x8B)};
-    mixer[kColorWebNativeControlScrollbarArrowForegroundDisabled] = {
-        kColorWebNativeControlScrollbarArrowForeground};
     mixer[kColorWebNativeControlScrollbarArrowForegroundPressed] = {
         dark_mode ? SkColorSetRGB(0xD1, 0xD1, 0xD1)
                   : SkColorSetRGB(0x63, 0x63, 0x63)};
diff --git a/ui/gtk/gtk_ui.cc b/ui/gtk/gtk_ui.cc
index 027bb14379bde..207da78dcf997 100644
--- a/ui/gtk/gtk_ui.cc
+++ b/ui/gtk/gtk_ui.cc
@@ -823,6 +823,7 @@ void GtkUi::OnThemeChanged(GtkSettings* settings, GtkParamSpec* param) {
   colors_.clear();
   custom_frame_colors_.clear();
   native_frame_colors_.clear();
+  native_theme_->OnThemeChanged(settings, param);
   LoadGtkValues();
   native_theme_->NotifyOnNativeThemeUpdated();
 }
diff --git a/ui/gtk/native_theme_gtk.cc b/ui/gtk/native_theme_gtk.cc
index 80fb9471fb4d5..3bcac8e348a1d 100644
--- a/ui/gtk/native_theme_gtk.cc
+++ b/ui/gtk/native_theme_gtk.cc
@@ -18,7 +18,7 @@
 #include "ui/color/color_id.h"
 #include "ui/color/color_provider.h"
 #include "ui/color/system_theme.h"
-#include "ui/gfx/geometry/insets.h"
+#include "ui/gfx/color_utils.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/geometry/skia_conversions.h"
@@ -27,30 +27,43 @@
 #include "ui/native_theme/native_theme.h"
 #include "ui/native_theme/native_theme_base.h"
 
+using base::StrCat;
+
 namespace gtk {
 
 namespace {
 
+enum BackgroundRenderMode {
+  BG_RENDER_NORMAL,
+  BG_RENDER_NONE,
+  BG_RENDER_RECURSIVE,
+};
+
 SkBitmap GetWidgetBitmap(const gfx::Size& size,
                          GtkCssContext context,
-                         bool use_recursive_rendering,
+                         BackgroundRenderMode bg_mode,
                          bool render_frame) {
+  DCHECK(bg_mode != BG_RENDER_NONE || render_frame);
   SkBitmap bitmap;
   bitmap.allocN32Pixels(size.width(), size.height());
   bitmap.eraseColor(0);
 
   CairoSurface surface(bitmap);
-  cairo_t* const cr = surface.cairo();
+  cairo_t* cr = surface.cairo();
 
-  const double opacity = GetOpacityFromContext(context);
-  if (opacity < 1) {
+  double opacity = GetOpacityFromContext(context);
+  if (opacity < 1)
     cairo_push_group(cr);
-  }
 
-  if (use_recursive_rendering) {
-    RenderBackground(size, cr, context);
-  } else {
-    gtk_render_background(context, cr, 0, 0, size.width(), size.height());
+  switch (bg_mode) {
+    case BG_RENDER_NORMAL:
+      gtk_render_background(context, cr, 0, 0, size.width(), size.height());
+      break;
+    case BG_RENDER_RECURSIVE:
+      RenderBackground(size, cr, context);
+      break;
+    case BG_RENDER_NONE:
+      break;
   }
   if (render_frame) {
     gtk_render_frame(context, cr, 0, 0, size.width(), size.height());
@@ -69,12 +82,37 @@ SkBitmap GetWidgetBitmap(const gfx::Size& size,
 void PaintWidget(cc::PaintCanvas* canvas,
                  const gfx::Rect& rect,
                  GtkCssContext context,
-                 bool use_recursive_rendering,
+                 BackgroundRenderMode bg_mode,
                  bool render_frame) {
-  canvas->drawImage(
-      cc::PaintImage::CreateFromBitmap(GetWidgetBitmap(
-          rect.size(), context, use_recursive_rendering, render_frame)),
-      rect.x(), rect.y());
+  canvas->drawImage(cc::PaintImage::CreateFromBitmap(GetWidgetBitmap(
+                        rect.size(), context, bg_mode, render_frame)),
+                    rect.x(), rect.y());
+}
+
+void UpdateNativeUiInstance(const ui::NativeTheme* native_theme) {
+  auto* const ui_theme = ui::NativeTheme::GetInstanceForNativeUi();
+  bool updated = false;
+  if (ui_theme->forced_colors() != native_theme->forced_colors()) {
+    ui_theme->set_forced_colors(native_theme->forced_colors());
+    updated = true;
+  }
+  if (ui_theme->page_colors() != native_theme->page_colors()) {
+    ui_theme->set_page_colors(native_theme->page_colors());
+    updated = true;
+  }
+  if (ui_theme->preferred_color_scheme() !=
+      native_theme->preferred_color_scheme()) {
+    ui_theme->set_preferred_color_scheme(
+        native_theme->preferred_color_scheme());
+    updated = true;
+  }
+  if (ui_theme->preferred_contrast() != native_theme->preferred_contrast()) {
+    ui_theme->SetPreferredContrast(native_theme->preferred_contrast());
+    updated = true;
+  }
+  if (updated) {
+    ui_theme->NotifyOnNativeThemeUpdated();
+  }
 }
 
 }  // namespace
@@ -85,17 +123,110 @@ NativeThemeGtk* NativeThemeGtk::instance() {
   return s_native_theme.get();
 }
 
+NativeThemeGtk::NativeThemeGtk() : NativeThemeBase(ui::SystemTheme::kGtk) {
+  OnThemeChanged(gtk_settings_get_default(), nullptr);
+}
+
+NativeThemeGtk::~NativeThemeGtk() {
+  NOTREACHED();
+}
+
+void NativeThemeGtk::SetThemeCssOverride(ScopedCssProvider provider) {
+  if (theme_css_override_) {
+    if (GtkCheckVersion(4)) {
+      gtk_style_context_remove_provider_for_display(
+          gdk_display_get_default(),
+          GTK_STYLE_PROVIDER(theme_css_override_.get()));
+    } else {
+      gtk_style_context_remove_provider_for_screen(
+          gdk_screen_get_default(),
+          GTK_STYLE_PROVIDER(theme_css_override_.get()));
+    }
+  }
+  theme_css_override_ = std::move(provider);
+  if (theme_css_override_) {
+    if (GtkCheckVersion(4)) {
+      gtk_style_context_add_provider_for_display(
+          gdk_display_get_default(),
+          GTK_STYLE_PROVIDER(theme_css_override_.get()),
+          GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+    } else {
+      gtk_style_context_add_provider_for_screen(
+          gdk_screen_get_default(),
+          GTK_STYLE_PROVIDER(theme_css_override_.get()),
+          GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+    }
+  }
+}
+
+void NativeThemeGtk::NotifyOnNativeThemeUpdated() {
+  // NativeThemeGtk pulls information about contrast from NativeThemeAura. As
+  // such, Aura must be updated with this information before we call
+  // NotifyOnNativeThemeUpdated().
+  UpdateNativeUiInstance(this);
+  NativeTheme::NotifyOnNativeThemeUpdated();
+}
+
+void NativeThemeGtk::NotifyOnPreferredContrastUpdated() {
+  UpdateNativeUiInstance(this);
+  NativeTheme::NotifyOnPreferredContrastUpdated();
+}
+
+void NativeThemeGtk::OnThemeChanged(GtkSettings* settings,
+                                    GtkParamSpec* param) {
+  SetThemeCssOverride(ScopedCssProvider());
+
+  std::string theme_name =
+      GetGtkSettingsStringProperty(settings, "gtk-theme-name");
+
+  // GTK has a dark mode setting called "gtk-application-prefer-dark-theme", but
+  // this is really only used for themes that have a dark or light variant that
+  // gets toggled based on this setting (eg. Adwaita).  Most dark themes do not
+  // have a light variant and aren't affected by the setting.  Because of this,
+  // experimentally check if the theme is dark by checking if the window
+  // background color is dark.
+  const SkColor window_bg_color = GetBgColor("");
+  set_preferred_color_scheme(
+      (IsForcedDarkMode() || color_utils::IsDark(window_bg_color))
+          ? ui::NativeTheme::PreferredColorScheme::kDark
+          : ui::NativeTheme::PreferredColorScheme::kLight);
+
+  // GTK doesn't have a native high contrast setting.  Rather, it's implied by
+  // the theme name.  The only high contrast GTK themes that I know of are
+  // HighContrast (GNOME) and ContrastHighInverse (MATE).  So infer the contrast
+  // based on if the theme name contains both "high" and "contrast",
+  // case-insensitive.
+  std::ranges::transform(theme_name, theme_name.begin(), ::tolower);
+  bool high_contrast = theme_name.find("high") != std::string::npos &&
+                       theme_name.find("contrast") != std::string::npos;
+  SetPreferredContrast(
+      high_contrast ? ui::NativeThemeBase::PreferredContrast::kMore
+                    : ui::NativeThemeBase::PreferredContrast::kNoPreference);
+
+  NotifyOnNativeThemeUpdated();
+}
+
 void NativeThemeGtk::PaintMenuPopupBackground(
     cc::PaintCanvas* canvas,
     const ui::ColorProvider* color_provider,
     const gfx::Size& size,
-    const MenuBackgroundExtraParams& extra_params) const {
-  GtkCssContext context = GetStyleContextFromCss(GtkCssMenu());
-
+    const MenuBackgroundExtraParams& menu_background) const {
+  auto context = GetStyleContextFromCss(GtkCssMenu());
   // Chrome menus aren't rendered with transparency, so avoid rounded corners.
   ApplyCssToContext(context, "* { border-radius: 0px; }");
+  PaintWidget(canvas, gfx::Rect(size), context, BG_RENDER_RECURSIVE, false);
+}
 
-  PaintWidget(canvas, gfx::Rect(size), std::move(context), true, false);
+void NativeThemeGtk::PaintMenuItemBackground(
+    cc::PaintCanvas* canvas,
+    const ui::ColorProvider* color_provider,
+    State state,
+    const gfx::Rect& rect,
+    const MenuItemExtraParams& menu_item) const {
+  auto context =
+      GetStyleContextFromCss(StrCat({GtkCssMenu(), " ", GtkCssMenuItem()}));
+  gtk_style_context_set_state(context, StateToStateFlags(state));
+  PaintWidget(canvas, rect, context, BG_RENDER_NORMAL, true);
 }
 
 void NativeThemeGtk::PaintMenuSeparator(
@@ -103,79 +234,68 @@ void NativeThemeGtk::PaintMenuSeparator(
     const ui::ColorProvider* color_provider,
     State state,
     const gfx::Rect& rect,
-    const MenuSeparatorExtraParams& extra_params) const {
-  // TODO(crbug.com/41312291): Use GTK to draw vertical separators too.
-  if (extra_params.type == ui::VERTICAL_SEPARATOR) {
-    CHECK(color_provider);
+    const MenuSeparatorExtraParams& menu_separator) const {
+  // TODO(estade): use GTK to draw vertical separators too. See
+  // crbug.com/710183
+  if (menu_separator.type == ui::VERTICAL_SEPARATOR) {
     cc::PaintFlags paint;
-    paint.setColor(color_provider->GetColor(extra_params.color_id));
+    paint.setStyle(cc::PaintFlags::kFill_Style);
+    DCHECK(color_provider);
+    paint.setColor(color_provider->GetColor(ui::kColorMenuSeparator));
     canvas->drawRect(gfx::RectToSkRect(rect), paint);
     return;
   }
 
-  GtkCssContext context = GetStyleContextFromCss(
-      base::StrCat({GtkCssMenu(), " separator.horizontal"}));
-  const gfx::Insets margin = GtkStyleContextGetMargin(context);
-  const gfx::Insets border = GtkStyleContextGetBorder(context);
-  const gfx::Insets padding = GtkStyleContextGetPadding(context);
-  int min_height;
+  auto separator_offset = [&](int separator_thickness) {
+    switch (menu_separator.type) {
+      case ui::LOWER_SEPARATOR:
+        return rect.height() - separator_thickness;
+      case ui::UPPER_SEPARATOR:
+        return 0;
+      default:
+        return (rect.height() - separator_thickness) / 2;
+    }
+  };
+  auto context =
+      GetStyleContextFromCss(StrCat({GtkCssMenu(), " separator.horizontal"}));
+  int min_height = 1;
+  auto margin = GtkStyleContextGetMargin(context);
+  auto border = GtkStyleContextGetBorder(context);
+  auto padding = GtkStyleContextGetPadding(context);
   if (GtkCheckVersion(4)) {
     min_height = GetSeparatorSize(true).height();
   } else {
     GtkStyleContextGet(context, "min-height", &min_height, nullptr);
   }
-
-  const auto separator_offset = [&](int separator_thickness) {
-    if (extra_params.type == ui::UPPER_SEPARATOR) {
-      return 0;
-    }
-    const int offset = rect.height() - separator_thickness;
-    return (extra_params.type == ui::LOWER_SEPARATOR) ? offset : (offset / 2);
-  };
-
-  const int w = rect.width() - margin.width();
-  const int h = std::max(min_height + padding.height() + border.height(), 1);
-  const int x = margin.left();
-  const int y = separator_offset(h);
-  PaintWidget(canvas, gfx::Rect(x, y, w, h), std::move(context), false, true);
-}
-
-void NativeThemeGtk::PaintMenuItemBackground(
-    cc::PaintCanvas* canvas,
-    const ui::ColorProvider* color_provider,
-    State state,
-    const gfx::Rect& rect,
-    const MenuItemExtraParams& extra_params) const {
-  GtkCssContext context = GetStyleContextFromCss(
-      base::StrCat({GtkCssMenu(), " ", GtkCssMenuItem()}));
-  gtk_style_context_set_state(context, StateToStateFlags(state));
-  PaintWidget(canvas, rect, std::move(context), false, true);
+  int w = rect.width() - margin.left() - margin.right();
+  int h = std::max(min_height + padding.top() + padding.bottom() +
+                       border.top() + border.bottom(),
+                   1);
+  int x = margin.left();
+  int y = separator_offset(h);
+  PaintWidget(canvas, gfx::Rect(x, y, w, h), context, BG_RENDER_NORMAL, true);
 }
 
 void NativeThemeGtk::PaintFrameTopArea(
     cc::PaintCanvas* canvas,
     State state,
     const gfx::Rect& rect,
-    const FrameTopAreaExtraParams& extra_params) const {
-  GtkCssContext context = GetStyleContextFromCss(
-      extra_params.use_custom_frame ? "headerbar.header-bar.titlebar"
-                                    : "menubar");
+    const FrameTopAreaExtraParams& frame_top_area) const {
+  auto context = GetStyleContextFromCss(frame_top_area.use_custom_frame
+                                            ? "headerbar.header-bar.titlebar"
+                                            : "menubar");
   ApplyCssToContext(context, "* { border-radius: 0px; border-style: none; }");
-  gtk_style_context_set_state(context, extra_params.is_active
+  gtk_style_context_set_state(context, frame_top_area.is_active
                                            ? GTK_STATE_FLAG_NORMAL
                                            : GTK_STATE_FLAG_BACKDROP);
 
-  SkBitmap bitmap = GetWidgetBitmap(rect.size(), std::move(context),
-                                    !extra_params.use_custom_frame, false);
+  SkBitmap bitmap = GetWidgetBitmap(
+      rect.size(), context,
+      frame_top_area.use_custom_frame ? BG_RENDER_NORMAL : BG_RENDER_RECURSIVE,
+      false);
   bitmap.setImmutable();
   canvas->drawImage(cc::PaintImage::CreateFromBitmap(std::move(bitmap)),
                     rect.x(), rect.y());
 }
 
-NativeThemeGtk::NativeThemeGtk() : NativeThemeBase(ui::SystemTheme::kGtk) {
-  BeginObservingOsSettingChanges();
-}
-
-NativeThemeGtk::~NativeThemeGtk() = default;
-
 }  // namespace gtk
diff --git a/ui/gtk/native_theme_gtk.h b/ui/gtk/native_theme_gtk.h
index 34b2acb5146fa..ab7c23092dd83 100644
--- a/ui/gtk/native_theme_gtk.h
+++ b/ui/gtk/native_theme_gtk.h
@@ -6,10 +6,17 @@
 #define UI_GTK_NATIVE_THEME_GTK_H_
 
 #include "base/no_destructor.h"
+#include "ui/base/glib/scoped_gobject.h"
 #include "ui/native_theme/native_theme_base.h"
 
+typedef struct _GtkCssProvider GtkCssProvider;
+typedef struct _GtkParamSpec GtkParamSpec;
+typedef struct _GtkSettings GtkSettings;
+
 namespace gtk {
 
+using ScopedCssProvider = ScopedGObject<GtkCssProvider>;
+
 class NativeThemeGtk : public ui::NativeThemeBase {
  public:
   static NativeThemeGtk* instance();
@@ -22,30 +29,38 @@ class NativeThemeGtk : public ui::NativeThemeBase {
       cc::PaintCanvas* canvas,
       const ui::ColorProvider* color_provider,
       const gfx::Size& size,
-      const MenuBackgroundExtraParams& extra_params) const override;
+      const MenuBackgroundExtraParams& menu_background) const override;
   void PaintMenuSeparator(
       cc::PaintCanvas* canvas,
       const ui::ColorProvider* color_provider,
       State state,
       const gfx::Rect& rect,
-      const MenuSeparatorExtraParams& extra_params) const override;
+      const MenuSeparatorExtraParams& menu_separator) const override;
   void PaintMenuItemBackground(
       cc::PaintCanvas* canvas,
       const ui::ColorProvider* color_provider,
       State state,
       const gfx::Rect& rect,
-      const MenuItemExtraParams& extra_params) const override;
+      const MenuItemExtraParams& menu_item) const override;
   void PaintFrameTopArea(
       cc::PaintCanvas* canvas,
       State state,
       const gfx::Rect& rect,
-      const FrameTopAreaExtraParams& extra_params) const override;
+      const FrameTopAreaExtraParams& frame_top_area) const override;
+  void NotifyOnNativeThemeUpdated() override;
+  void NotifyOnPreferredContrastUpdated() override;
+
+  void OnThemeChanged(GtkSettings* settings, GtkParamSpec* param);
 
  private:
   friend class base::NoDestructor<NativeThemeGtk>;
 
   NativeThemeGtk();
   ~NativeThemeGtk() override;
+
+  void SetThemeCssOverride(ScopedCssProvider provider);
+
+  ScopedCssProvider theme_css_override_;
 };
 
 }  // namespace gtk
diff --git a/ui/gtk/os_settings_provider_gtk.cc b/ui/gtk/os_settings_provider_gtk.cc
index e6992b7ed3e7f..4fc2e951122b1 100644
--- a/ui/gtk/os_settings_provider_gtk.cc
+++ b/ui/gtk/os_settings_provider_gtk.cc
@@ -7,17 +7,11 @@
 #include <glib-object.h>
 #include <glib.h>
 
-#include <string>
-
-#include "base/containers/contains.h"
 #include "base/functional/bind.h"
-#include "base/strings/string_util.h"
 #include "base/time/time.h"
 #include "ui/base/glib/scoped_gsignal.h"
-#include "ui/gfx/color_utils.h"
 #include "ui/gtk/gtk_compat.h"
 #include "ui/gtk/gtk_util.h"
-#include "ui/native_theme/native_theme.h"
 
 namespace gtk {
 
@@ -26,35 +20,6 @@ OsSettingsProviderGtk::OsSettingsProviderGtk()
 
 OsSettingsProviderGtk::~OsSettingsProviderGtk() = default;
 
-ui::NativeTheme::PreferredColorScheme
-OsSettingsProviderGtk::PreferredColorScheme() const {
-  // GTK has a dark mode setting called "gtk-application-prefer-dark-theme", but
-  // this is really only used for themes that have a dark or light variant that
-  // gets toggled based on this setting (eg. Adwaita).  Most dark themes do not
-  // have a light variant and aren't affected by the setting.  Because of this,
-  // experimentally check if the theme is dark by checking if the window
-  // background color is dark.
-  return color_utils::IsDark(GetBgColor({}))
-             ? ui::NativeTheme::PreferredColorScheme::kDark
-             : ui::NativeTheme::PreferredColorScheme::kLight;
-}
-
-ui::NativeTheme::PreferredContrast OsSettingsProviderGtk::PreferredContrast()
-    const {
-  // GTK doesn't have a native high contrast setting.  Rather, it's implied by
-  // the theme name.  The only high contrast GTK themes that I know of are
-  // HighContrast (GNOME) and ContrastHighInverse (MATE).  So infer the contrast
-  // based on if the theme name contains both "high" and "contrast",
-  // case-insensitive.
-  const std::string theme_name =
-      base::ToLowerASCII(GetGtkSettingsStringProperty(
-          gtk_settings_get_default(), "gtk-theme-name"));
-  const bool high_contrast = base::Contains(theme_name, "high") &&
-                             base::Contains(theme_name, "contrast");
-  return high_contrast ? ui::NativeTheme::PreferredContrast::kMore
-                       : ui::NativeTheme::PreferredContrast::kNoPreference;
-}
-
 base::TimeDelta OsSettingsProviderGtk::CaretBlinkInterval() const {
   // Default value for `gtk-cursor-blink-time` from
   // https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-blink-time.html.
diff --git a/ui/gtk/os_settings_provider_gtk.h b/ui/gtk/os_settings_provider_gtk.h
index 6e3bbc451d6da..b965fec9d3d11 100644
--- a/ui/gtk/os_settings_provider_gtk.h
+++ b/ui/gtk/os_settings_provider_gtk.h
@@ -26,8 +26,6 @@ class OsSettingsProviderGtk : public ui::OsSettingsProvider {
   ~OsSettingsProviderGtk() override;
 
   // ui::OsSettingsProvider:
-  ui::NativeTheme::PreferredColorScheme PreferredColorScheme() const override;
-  ui::NativeTheme::PreferredContrast PreferredContrast() const override;
   base::TimeDelta CaretBlinkInterval() const override;
 
  private:
@@ -38,11 +36,10 @@ class OsSettingsProviderGtk : public ui::OsSettingsProvider {
 
   // Have to explicitly give template params instead of using `std::to_array()`,
   // since CTAD is banned in non-static member declarations :(
-  std::array<ScopedGSignal, 4> signals_{
+  std::array<ScopedGSignal, 3> signals_{
       ConnectSignal("notify::gtk-application-prefer-dark-theme"),
       ConnectSignal("notify::gtk-cursor-blink"),
       ConnectSignal("notify::gtk-cursor-blink-time"),
-      ConnectSignal("notify::gtk-theme-name"),
   };
 };
 
diff --git a/ui/linux/linux_ui_factory.cc b/ui/linux/linux_ui_factory.cc
index 9307de3ae9ccd..f7c49e9fcf843 100644
--- a/ui/linux/linux_ui_factory.cc
+++ b/ui/linux/linux_ui_factory.cc
@@ -14,7 +14,6 @@
 #include "base/nix/xdg_util.h"
 #include "base/no_destructor.h"
 #include "base/strings/string_util.h"
-#include "base/task/sequenced_task_runner.h"
 #include "build/chromecast_buildflags.h"
 #include "ui/base/buildflags.h"
 #include "ui/base/ui_base_switches.h"
@@ -22,7 +21,6 @@
 #include "ui/linux/fallback_linux_ui.h"
 #include "ui/linux/linux_ui.h"
 #include "ui/linux/linux_ui_delegate.h"
-#include "ui/native_theme/native_theme.h"
 
 #if BUILDFLAG(USE_GTK)
 #include "ui/gtk/gtk_ui_factory.h"
@@ -66,16 +64,6 @@ LinuxUiAndTheme* GetLinuxUi(CreateLinuxUiFunc&& create_linux_ui) {
     return nullptr;
   }
 
-  // Calling `Initialize()` below may create new `NativeTheme` and/or
-  // `OsSettingsProvider` instances, triggering NativeTheme update
-  // notifications. If these happen synchronously, observers may attempt to
-  // obtain the `ThemeService` instance while this callstack is still setting it
-  // up, leading to unexpected null pointers. To avoid this, delay any such
-  // notifications until the callstack has unwound.
-  base::SequencedTaskRunner::GetCurrentDefault()->DeleteSoon(
-      FROM_HERE,
-      std::make_unique<NativeTheme::UpdateNotificationDelayScoper>());
-
   // This function is reentrant: it may be called while Initialize() is running.
   // In that case, return `linux_ui`. However, if Initialize() fails,
   // `linux_ui` is reset and future calls will not try to initialize again.
diff --git a/ui/message_center/BUILD.gn b/ui/message_center/BUILD.gn
index 3047e2c9da72d..d081004ac94c9 100644
--- a/ui/message_center/BUILD.gn
+++ b/ui/message_center/BUILD.gn
@@ -240,7 +240,6 @@ if (enable_message_center) {
       deps += [
         "//ui/color",
         "//ui/display",
-        "//ui/native_theme:test_support",
         "//ui/strings",
         "//ui/views",
         "//ui/views:test_support",
diff --git a/ui/message_center/views/notification_view_unittest.cc b/ui/message_center/views/notification_view_unittest.cc
index 5e4873b7c59f7..3ef8a224c330a 100644
--- a/ui/message_center/views/notification_view_unittest.cc
+++ b/ui/message_center/views/notification_view_unittest.cc
@@ -25,7 +25,6 @@
 #include "ui/message_center/views/notification_control_buttons_view.h"
 #include "ui/message_center/views/notification_header_view.h"
 #include "ui/message_center/views/proportional_image_view.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/views/animation/ink_drop.h"
 #include "ui/views/animation/ink_drop_impl.h"
 #include "ui/views/animation/ink_drop_observer.h"
@@ -272,7 +271,6 @@ class NotificationViewTest : public views::ViewsTestBase,
   scoped_refptr<NotificationTestDelegate> delegate_;
 
  private:
-  ui::MockOsSettingsProvider os_settings_provider_;  // Ensures light mode.
   raw_ptr<NotificationView> notification_view_ = nullptr;
   bool delete_on_notification_removed_ = false;
   bool ink_drop_stopped_ = false;
@@ -455,6 +453,13 @@ TEST_F(NotificationViewTest, InlineSettingsBlockAll) {
 TEST_F(NotificationViewTest, DISABLED_TestAccentColor) {
   std::unique_ptr<Notification> notification = CreateSimpleNotification();
   notification->set_buttons(CreateButtons(2));
+
+  // The code below is not prepared to deal with dark mode.
+  notification_view()
+      ->GetWidget()
+      ->GetNativeTheme()
+      ->set_preferred_color_scheme(
+          ui::NativeTheme::PreferredColorScheme::kLight);
   UpdateNotificationViews(*notification);
 
   notification_view()->GetWidget()->Show();
diff --git a/ui/native_theme/BUILD.gn b/ui/native_theme/BUILD.gn
index 0f0cfc29207d4..304e64e86a303 100644
--- a/ui/native_theme/BUILD.gn
+++ b/ui/native_theme/BUILD.gn
@@ -13,6 +13,7 @@ component("native_theme") {
     "native_theme.h",
     "native_theme_base.cc",
     "native_theme_base.h",
+    "native_theme_constants_fluent.h",
     "native_theme_fluent.cc",
     "native_theme_fluent.h",
     "native_theme_observer.cc",
@@ -45,15 +46,6 @@ component("native_theme") {
     "//ui/resources",
   ]
 
-  if (is_android) {
-    sources += [
-      "os_settings_provider_android.cc",
-      "os_settings_provider_android.h",
-    ]
-
-    deps += [ "//ui/accessibility:ax_base_android" ]
-  }
-
   if (is_android || is_ios) {
     sources += [
       "native_theme_mobile.cc",
@@ -61,13 +53,6 @@ component("native_theme") {
     ]
   }
 
-  if (is_chromeos) {
-    sources += [
-      "os_settings_provider_ash.cc",
-      "os_settings_provider_ash.h",
-    ]
-  }
-
   if (is_mac) {
     frameworks = [
       "Accessibility.framework",
@@ -95,8 +80,6 @@ component("native_theme") {
       "os_settings_provider_win.h",
     ]
 
-    public_deps += [ "//ui/color:accent_color_observer" ]
-
     libs = [ "uxtheme.lib" ]
   }
 
@@ -116,6 +99,8 @@ component("test_support") {
   sources = [
     "mock_os_settings_provider.cc",
     "mock_os_settings_provider.h",
+    "test_native_theme.cc",
+    "test_native_theme.h",
   ]
 
   defines = [ "IS_NATIVE_THEME_IMPL" ]
@@ -123,7 +108,6 @@ component("test_support") {
   deps = [
     ":native_theme",
     "//base",
-    "//ui/color:color_provider_key",
   ]
 }
 
@@ -134,7 +118,6 @@ test("native_theme_unittests") {
     "native_theme_base_unittest.cc",
     "native_theme_fluent_unittest.cc",
     "native_theme_unittest.cc",
-    "os_settings_provider_unittest.cc",
   ]
 
   deps = [
@@ -144,6 +127,7 @@ test("native_theme_unittests") {
     "//base/test:test_support",
     "//skia",
     "//testing/gtest",
+    "//ui/base",
     "//ui/color",
     "//ui/gfx:test_support",
     "//ui/gfx/geometry",
@@ -158,6 +142,13 @@ test("native_theme_unittests") {
   }
 
   if (is_win) {
-    sources += [ "caption_style_win_unittest.cc" ]
+    sources += [
+      "caption_style_win_unittest.cc",
+      "native_theme_win_unittest.cc",
+    ]
+  }
+
+  if (use_aura) {
+    sources += [ "native_theme_aura_unittest.cc" ]
   }
 }
diff --git a/ui/native_theme/DEPS b/ui/native_theme/DEPS
index 8600064e857a8..5397e5514e79d 100644
--- a/ui/native_theme/DEPS
+++ b/ui/native_theme/DEPS
@@ -2,7 +2,6 @@ include_rules = [
   "+cc/paint",
   "+skia/ext",
   "+third_party/skia",
-  "+ui/accessibility",
   "+ui/base",
   "+ui/color",
   "+ui/display",
diff --git a/ui/native_theme/caption_style_win_unittest.cc b/ui/native_theme/caption_style_win_unittest.cc
index f335dacca93dc..eadfb60348eab 100644
--- a/ui/native_theme/caption_style_win_unittest.cc
+++ b/ui/native_theme/caption_style_win_unittest.cc
@@ -4,14 +4,18 @@
 
 #include "ui/native_theme/caption_style.h"
 
+#include "base/test/scoped_feature_list.h"
 #include "base/win/scoped_com_initializer.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "ui/base/ui_base_features.h"
 
 namespace ui {
 
 // Test to ensure closed caption styling from system settings can be obtained
 // (we obtain a CaptionStyle).
 TEST(CaptionStyleWinTest, TestWinCaptionStyle) {
+  base::test::ScopedFeatureList scoped_feature_list;
+
   base::win::ScopedCOMInitializer com_initializer;
   ASSERT_TRUE(com_initializer.Succeeded());
 
diff --git a/ui/native_theme/mock_os_settings_provider.cc b/ui/native_theme/mock_os_settings_provider.cc
index 66403b83e4ccc..4121cb174ea1f 100644
--- a/ui/native_theme/mock_os_settings_provider.cc
+++ b/ui/native_theme/mock_os_settings_provider.cc
@@ -6,11 +6,7 @@
 
 #include <optional>
 
-#include "base/containers/flat_map.h"
 #include "base/time/time.h"
-#include "third_party/skia/include/core/SkColor.h"
-#include "ui/color/color_provider_key.h"
-#include "ui/native_theme/native_theme.h"
 
 namespace ui {
 
@@ -19,112 +15,10 @@ MockOsSettingsProvider::MockOsSettingsProvider()
 
 MockOsSettingsProvider::~MockOsSettingsProvider() = default;
 
-bool MockOsSettingsProvider::DarkColorSchemeAvailable() const {
-  return dark_color_scheme_available_;
-}
-
-NativeTheme::PreferredColorScheme MockOsSettingsProvider::PreferredColorScheme()
-    const {
-  return preferred_color_scheme_;
-}
-
-ColorProviderKey::UserColorSource MockOsSettingsProvider::PreferredColorSource()
-    const {
-  return preferred_color_source_;
-}
-
-NativeTheme::PreferredContrast MockOsSettingsProvider::PreferredContrast()
-    const {
-  return preferred_contrast_;
-}
-
-bool MockOsSettingsProvider::PrefersReducedTransparency() const {
-  return prefers_reduced_transparency_;
-}
-
-bool MockOsSettingsProvider::PrefersInvertedColors() const {
-  return prefers_inverted_colors_;
-}
-
-bool MockOsSettingsProvider::ForcedColorsActive() const {
-  return forced_colors_active_;
-}
-
-std::optional<SkColor> MockOsSettingsProvider::AccentColor() const {
-  return accent_color_;
-}
-
-std::optional<SkColor> MockOsSettingsProvider::Color(ColorId color_id) const {
-  const auto it = colors_.find(color_id);
-  return (it == colors_.end()) ? std::nullopt : std::make_optional(it->second);
-}
-
-std::optional<ColorProviderKey::SchemeVariant>
-MockOsSettingsProvider::SchemeVariant() const {
-  return scheme_variant_;
-}
-
 base::TimeDelta MockOsSettingsProvider::CaretBlinkInterval() const {
   return caret_blink_interval_;
 }
 
-void MockOsSettingsProvider::SetDarkColorSchemeAvailable(
-    bool dark_color_scheme_available) {
-  dark_color_scheme_available_ = dark_color_scheme_available;
-  NotifyOnSettingsChanged();
-}
-
-void MockOsSettingsProvider::SetPreferredColorScheme(
-    NativeTheme::PreferredColorScheme preferred_color_scheme) {
-  preferred_color_scheme_ = preferred_color_scheme;
-  NotifyOnSettingsChanged();
-}
-
-void MockOsSettingsProvider::SetPreferredColorSource(
-    ColorProviderKey::UserColorSource preferred_color_source) {
-  preferred_color_source_ = preferred_color_source;
-  NotifyOnSettingsChanged();
-}
-
-void MockOsSettingsProvider::SetPreferredContrast(
-    NativeTheme::PreferredContrast preferred_contrast) {
-  preferred_contrast_ = preferred_contrast;
-  NotifyOnSettingsChanged();
-}
-
-void MockOsSettingsProvider::SetPrefersReducedTransparency(
-    bool prefers_reduced_transparency) {
-  prefers_reduced_transparency_ = prefers_reduced_transparency;
-  NotifyOnSettingsChanged();
-}
-
-void MockOsSettingsProvider::SetPrefersInvertedColors(
-    bool prefers_inverted_colors) {
-  prefers_inverted_colors_ = prefers_inverted_colors;
-  NotifyOnSettingsChanged();
-}
-
-void MockOsSettingsProvider::SetForcedColorsActive(bool forced_colors_active) {
-  forced_colors_active_ = forced_colors_active;
-  NotifyOnSettingsChanged();
-}
-
-void MockOsSettingsProvider::SetAccentColor(SkColor accent_color) {
-  accent_color_ = accent_color;
-  NotifyOnSettingsChanged();
-}
-
-void MockOsSettingsProvider::SetColor(ColorId color_id, SkColor color) {
-  colors_[color_id] = color;
-  NotifyOnSettingsChanged();
-}
-
-void MockOsSettingsProvider::SetSchemeVariant(
-    ColorProviderKey::SchemeVariant scheme_variant) {
-  scheme_variant_ = scheme_variant;
-  NotifyOnSettingsChanged();
-}
-
 void MockOsSettingsProvider::SetCaretBlinkInterval(
     base::TimeDelta caret_blink_interval) {
   caret_blink_interval_ = caret_blink_interval;
diff --git a/ui/native_theme/mock_os_settings_provider.h b/ui/native_theme/mock_os_settings_provider.h
index 738a5b0d8abe2..146ad25a13282 100644
--- a/ui/native_theme/mock_os_settings_provider.h
+++ b/ui/native_theme/mock_os_settings_provider.h
@@ -8,11 +8,7 @@
 #include <optional>
 
 #include "base/component_export.h"
-#include "base/containers/flat_map.h"
 #include "base/time/time.h"
-#include "third_party/skia/include/core/SkColor.h"
-#include "ui/color/color_provider_key.h"
-#include "ui/native_theme/native_theme.h"
 #include "ui/native_theme/os_settings_provider.h"
 
 namespace ui {
@@ -27,47 +23,12 @@ class COMPONENT_EXPORT(NATIVE_THEME) MockOsSettingsProvider
   ~MockOsSettingsProvider() override;
 
   // OsSettingsProvider:
-  bool DarkColorSchemeAvailable() const override;
-  NativeTheme::PreferredColorScheme PreferredColorScheme() const override;
-  ColorProviderKey::UserColorSource PreferredColorSource() const override;
-  NativeTheme::PreferredContrast PreferredContrast() const override;
-  bool PrefersReducedTransparency() const override;
-  bool PrefersInvertedColors() const override;
-  bool ForcedColorsActive() const override;
-  std::optional<SkColor> AccentColor() const override;
-  std::optional<SkColor> Color(ColorId color_id) const override;
-  std::optional<ColorProviderKey::SchemeVariant> SchemeVariant() const override;
   base::TimeDelta CaretBlinkInterval() const override;
 
   // Setters for all the above settings.
-  void SetDarkColorSchemeAvailable(bool dark_color_scheme_available);
-  void SetPreferredColorScheme(
-      NativeTheme::PreferredColorScheme preferred_color_scheme);
-  void SetPreferredColorSource(
-      ColorProviderKey::UserColorSource preferred_color_source);
-  void SetPreferredContrast(NativeTheme::PreferredContrast preferred_contrast);
-  void SetPrefersReducedTransparency(bool prefers_reduced_transparency);
-  void SetPrefersInvertedColors(bool prefers_inverted_colors);
-  void SetForcedColorsActive(bool forced_colors_active);
-  void SetAccentColor(SkColor accent_color);
-  void SetColor(ColorId color_id, SkColor color);
-  void SetSchemeVariant(ColorProviderKey::SchemeVariant scheme_variant);
   void SetCaretBlinkInterval(base::TimeDelta caret_blink_interval);
 
  private:
-  bool dark_color_scheme_available_ = true;
-  NativeTheme::PreferredColorScheme preferred_color_scheme_ =
-      NativeTheme::PreferredColorScheme::kLight;
-  ColorProviderKey::UserColorSource preferred_color_source_ =
-      ColorProviderKey::UserColorSource::kBaseline;
-  NativeTheme::PreferredContrast preferred_contrast_ =
-      NativeTheme::PreferredContrast::kNoPreference;
-  bool prefers_reduced_transparency_ = false;
-  bool prefers_inverted_colors_ = false;
-  bool forced_colors_active_ = false;
-  std::optional<SkColor> accent_color_;
-  base::flat_map<ColorId, SkColor> colors_;
-  std::optional<ColorProviderKey::SchemeVariant> scheme_variant_;
   base::TimeDelta caret_blink_interval_ = kDefaultCaretBlinkInterval;
 };
 
diff --git a/ui/native_theme/native_theme.cc b/ui/native_theme/native_theme.cc
index e09cf382304fa..fd318696da3f0 100644
--- a/ui/native_theme/native_theme.cc
+++ b/ui/native_theme/native_theme.cc
@@ -11,19 +11,16 @@
 #include <optional>
 #include <utility>
 
-#include "base/callback_list.h"
 #include "base/command_line.h"
+#include "base/containers/fixed_flat_map.h"
 #include "base/functional/bind.h"
-#include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/scoped_refptr.h"
-#include "base/no_destructor.h"
 #include "base/notreached.h"
 #include "base/observer_list.h"
 #include "base/sequence_checker.h"
 #include "base/time/time.h"
 #include "base/timer/elapsed_timer.h"
-#include "base/types/pass_key.h"
 #include "build/build_config.h"
 #include "cc/paint/paint_canvas.h"
 #include "cc/paint/paint_flags.h"
@@ -35,10 +32,8 @@
 #include "ui/color/color_provider_key.h"
 #include "ui/color/color_provider_manager.h"
 #include "ui/color/system_theme.h"
-#include "ui/gfx/canvas.h"
-#include "ui/gfx/geometry/size.h"
 #include "ui/gfx/geometry/skia_conversions.h"
-#include "ui/gfx/scoped_canvas.h"
+#include "ui/native_theme/features/native_theme_features.h"
 #include "ui/native_theme/native_theme_observer.h"
 #include "ui/native_theme/os_settings_provider.h"
 
@@ -58,7 +53,19 @@
 
 namespace ui {
 
-namespace {
+NativeTheme::MenuListExtraParams::MenuListExtraParams() = default;
+NativeTheme::TextFieldExtraParams::TextFieldExtraParams() = default;
+
+NativeTheme::MenuListExtraParams::MenuListExtraParams(
+    const NativeTheme::MenuListExtraParams&) = default;
+
+NativeTheme::TextFieldExtraParams::TextFieldExtraParams(
+    const NativeTheme::TextFieldExtraParams&) = default;
+
+NativeTheme::MenuListExtraParams& NativeTheme::MenuListExtraParams::operator=(
+    const NativeTheme::MenuListExtraParams&) = default;
+NativeTheme::TextFieldExtraParams& NativeTheme::TextFieldExtraParams::operator=(
+    const NativeTheme::TextFieldExtraParams&) = default;
 
 #if BUILDFLAG(IS_MAC)
 using NativeUiTheme = NativeThemeMac;
@@ -89,63 +96,6 @@ using NativeUiTheme = NativeThemeMobile;
 using WebUiTheme = NativeThemeMobile;
 #endif
 
-}  // namespace
-
-NativeTheme::MenuListExtraParams::MenuListExtraParams() = default;
-
-NativeTheme::MenuListExtraParams::MenuListExtraParams(
-    const NativeTheme::MenuListExtraParams&) = default;
-
-NativeTheme::MenuListExtraParams& NativeTheme::MenuListExtraParams::operator=(
-    const NativeTheme::MenuListExtraParams&) = default;
-
-NativeTheme::TextFieldExtraParams::TextFieldExtraParams() = default;
-
-NativeTheme::TextFieldExtraParams::TextFieldExtraParams(
-    const NativeTheme::TextFieldExtraParams&) = default;
-
-NativeTheme::TextFieldExtraParams& NativeTheme::TextFieldExtraParams::operator=(
-    const NativeTheme::TextFieldExtraParams&) = default;
-
-NativeTheme::UpdateNotificationDelayScoper::UpdateNotificationDelayScoper() {
-  ++num_instances_;
-}
-
-NativeTheme::UpdateNotificationDelayScoper::UpdateNotificationDelayScoper(
-    const UpdateNotificationDelayScoper&) {
-  ++num_instances_;
-}
-
-NativeTheme::UpdateNotificationDelayScoper::UpdateNotificationDelayScoper(
-    UpdateNotificationDelayScoper&&) {
-  ++num_instances_;
-}
-
-NativeTheme::UpdateNotificationDelayScoper::~UpdateNotificationDelayScoper() {
-  if (--num_instances_ == 0) {
-    GetDelayedNotifications().Notify();
-  }
-}
-
-// static
-base::CallbackListSubscription
-NativeTheme::UpdateNotificationDelayScoper::RegisterCallback(
-    base::PassKey<NativeTheme>,
-    base::OnceClosure cb) {
-  return GetDelayedNotifications().Add(std::move(cb));
-}
-
-// static
-base::OnceClosureList&
-NativeTheme::UpdateNotificationDelayScoper::GetDelayedNotifications() {
-  static base::NoDestructor<base::OnceClosureList> s_delayed_notifications;
-  return *s_delayed_notifications;
-}
-
-// static
-size_t NativeTheme::UpdateNotificationDelayScoper::num_instances_ = 0;
-
-// static
 NativeTheme* NativeTheme::GetInstanceForNativeUi() {
   static base::NoDestructor<NativeUiTheme> s_native_theme;
   static bool initialized = false;
@@ -156,7 +106,6 @@ NativeTheme* NativeTheme::GetInstanceForNativeUi() {
   return s_native_theme.get();
 }
 
-// static
 NativeTheme* NativeTheme::GetInstanceForWeb() {
 #if defined(USE_AURA)
   NativeTheme* const native_theme = GetInstanceForWebImpl();
@@ -172,33 +121,60 @@ NativeTheme* NativeTheme::GetInstanceForWeb() {
   return native_theme;
 }
 
+#if !BUILDFLAG(IS_WIN) && !BUILDFLAG(IS_APPLE)
 // static
-float NativeTheme::AdjustBorderWidthByZoom(float border_width,
-                                           float zoom_level) {
-  return std::max(std::floor(border_width * zoom_level), 1.0f);
+bool NativeTheme::SystemDarkModeSupported() {
+  return false;
 }
+#endif
 
-// static
-float NativeTheme::AdjustBorderRadiusByZoom(Part part,
-                                            float border_radius,
-                                            float zoom) {
-  return (part == kCheckbox || part == kTextField || part == kPushButton)
-             ? AdjustBorderWidthByZoom(border_radius, zoom)
-             : border_radius;
-}
+ColorProviderKey NativeTheme::GetColorProviderKey(
+    scoped_refptr<ColorProviderKey::ThemeInitializerSupplier> custom_theme,
+    bool use_custom_frame) const {
+  const auto get_forced_colors_key = [](bool forced_colors,
+                                        PageColors page_colors) {
+    if (!forced_colors) {
+      return ColorProviderKey::ForcedColors::kNone;
+    }
+    static constexpr auto kForcedColorsMap =
+        base::MakeFixedFlatMap<PageColors, ColorProviderKey::ForcedColors>({
+            {PageColors::kOff, ColorProviderKey::ForcedColors::kNone},
+            {PageColors::kDusk, ColorProviderKey::ForcedColors::kDusk},
+            {PageColors::kDesert, ColorProviderKey::ForcedColors::kDesert},
+            {PageColors::kNightSky, ColorProviderKey::ForcedColors::kNightSky},
+            {PageColors::kWhite, ColorProviderKey::ForcedColors::kWhite},
+            {PageColors::kHighContrast,
+             ColorProviderKey::ForcedColors::kSystem},
+            {PageColors::kAquatic, ColorProviderKey::ForcedColors::kAquatic},
+        });
+
+    return kForcedColorsMap.at(page_colors);
+  };
 
-gfx::Size NativeTheme::GetPartSize(Part part,
-                                   State state,
-                                   const ExtraParams& extra_params) const {
-  return {};
-}
+  const bool dark_mode =
+      preferred_color_scheme() == PreferredColorScheme::kDark;
+  ui::ColorProviderKey key;
+  key.color_mode = dark_mode ? ColorProviderKey::ColorMode::kDark
+                             : ColorProviderKey::ColorMode::kLight;
+  key.contrast_mode = preferred_contrast() == PreferredContrast::kMore
+                          ? ColorProviderKey::ContrastMode::kHigh
+                          : ColorProviderKey::ContrastMode::kNormal;
+  key.forced_colors = get_forced_colors_key(forced_colors(), page_colors_);
+  key.system_theme = system_theme_;
+  key.frame_type = use_custom_frame ? ColorProviderKey::FrameType::kChromium
+                                    : ColorProviderKey::FrameType::kNative;
+  key.user_color_source = should_use_system_accent_color_
+                              ? ColorProviderKey::UserColorSource::kAccent
+                              : ColorProviderKey::UserColorSource::kBaseline;
+  key.user_color = user_color_;
+  key.scheme_variant = scheme_variant_;
+  key.custom_theme = std::move(custom_theme);
 
-int NativeTheme::GetPaintedScrollbarTrackInset() const {
-  return 0;
+  return key;
 }
 
-gfx::Insets NativeTheme::GetScrollbarSolidColorThumbInsets(Part part) const {
-  return {};
+SkColor NativeTheme::GetSystemButtonPressedColor(SkColor base_color) const {
+  return base_color;
 }
 
 float NativeTheme::GetBorderRadiusForPart(Part part,
@@ -207,29 +183,6 @@ float NativeTheme::GetBorderRadiusForPart(Part part,
   return 0;
 }
 
-bool NativeTheme::SupportsNinePatch(Part part) const {
-  return false;
-}
-
-gfx::Size NativeTheme::GetNinePatchCanvasSize(Part part) const {
-  NOTREACHED();
-}
-
-gfx::Rect NativeTheme::GetNinePatchAperture(Part part) const {
-  NOTREACHED();
-}
-
-SkColor NativeTheme::GetScrollbarThumbColor(
-    const ColorProvider* color_provider,
-    State state,
-    const ScrollbarThumbExtraParams& extra_params) const {
-  NOTREACHED();
-}
-
-SkColor NativeTheme::GetSystemButtonPressedColor(SkColor base_color) const {
-  return base_color;
-}
-
 void NativeTheme::BeginObservingOsSettingChanges() {
   os_settings_changed_subscription_ =
       OsSettingsProvider::RegisterOsSettingsChangedCallback(base::BindRepeating(
@@ -246,35 +199,15 @@ void NativeTheme::RemoveObserver(NativeThemeObserver* observer) {
 }
 
 void NativeTheme::NotifyOnNativeThemeUpdated() {
-  // This specific method is prone to being mistakenly called on the wrong
-  // sequence, because it is often invoked from a platform-specific event
-  // listener, and those events may be delivered on unexpected sequences.
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-
-  if (base::PassKey<NativeTheme> pass_key;
-      UpdateNotificationDelayScoper::exists(pass_key)) {
-    // At least one scoper exists, so delay notifications until it's gone.
-    if (!update_delay_subscription_) {
-      update_delay_subscription_ =
-          UpdateNotificationDelayScoper::RegisterCallback(
-              pass_key, base::BindOnce(&NativeTheme::NotifyOnNativeThemeUpdated,
-                                       base::Unretained(this)));
-    }
-    return;
-  }
-
-  if (update_delay_subscription_) {
-    // No scopers exist, but a subscription does: this is the callback from the
-    // last scoper being destroyed. Reset the subscription so it can be
-    // recreated in the future when necessary.
-    update_delay_subscription_ = {};
-  }
-
   base::ElapsedTimer timer;
-  auto& color_provider_manager = ColorProviderManager::Get();
+  auto& color_provider_manager = ui::ColorProviderManager::Get();
   const size_t initial_providers_initialized =
       color_provider_manager.num_providers_initialized();
 
+  // This specific method is prone to being mistakenly called on the wrong
+  // sequence, because it is often invoked from a platform-specific event
+  // listener, and those events may be delivered on unexpected sequences.
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   // Reset the ColorProviderManager's cache so that ColorProviders requested
   // from this point onwards incorporate the changes to the system theme.
   color_provider_manager.ResetColorProviderCache();
@@ -292,75 +225,90 @@ void NativeTheme::NotifyOnCaptionStyleUpdated() {
   // sequence, because it is often invoked from a platform-specific event
   // listener, and those events may be delivered on unexpected sequences.
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-
   native_theme_observers_.Notify(&NativeThemeObserver::OnCaptionStyleUpdated);
 }
 
-void NativeTheme::Paint(cc::PaintCanvas* canvas,
-                        const ColorProvider* color_provider,
-                        Part part,
-                        State state,
-                        const gfx::Rect& rect,
-                        const ExtraParams& extra_params,
-                        bool forced_colors,
-                        PreferredColorScheme color_scheme,
-                        PreferredContrast contrast,
-                        std::optional<SkColor> accent_color) const {
-  if (rect.IsEmpty()) {
-    return;
-  }
-
-  // For `color_scheme`, `kNoPreference` means "use current".
-  const bool dark_mode =
-      color_scheme == PreferredColorScheme::kDark ||
-      (color_scheme == PreferredColorScheme::kNoPreference &&
-       preferred_color_scheme() == PreferredColorScheme::kDark);
-
-  // Form control accents shouldn't be drawn with any transparency.
-  // TODO(C++23): Replace the below with:
-  // ```
-  //  const std::optional<SkColor> accent_color_opaque = accent_color.transform(
-  //      [](SkColor c) { return SkColorSetA(c, SK_AlphaOPAQUE); });
-  // ```
-  const std::optional<SkColor> accent_color_opaque =
-      accent_color.has_value() ? std::make_optional(SkColorSetA(
-                                     accent_color.value(), SK_AlphaOPAQUE))
-                               : std::nullopt;
-
-  gfx::Canvas gfx_canvas(canvas, 1.0f);
-  gfx::ScopedCanvas scoped_canvas(&gfx_canvas);
-  gfx_canvas.ClipRect(rect);
+void NativeTheme::NotifyOnPreferredContrastUpdated() {
+  // This specific method is prone to being mistakenly called on the wrong
+  // sequence, because it is often invoked from a platform-specific event
+  // listener, and those events may be delivered on unexpected sequences.
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  NotifyOnPreferredContrastUpdatedImpl();
+}
 
-  PaintImpl(canvas, color_provider, part, state, rect, extra_params,
-            forced_colors, dark_mode, contrast, accent_color_opaque);
+// static
+float NativeTheme::AdjustBorderWidthByZoom(float border_width,
+                                           float zoom_level) {
+  return std::max(std::floor(border_width * zoom_level), 1.0f);
 }
 
-ColorProviderKey NativeTheme::GetColorProviderKey(
-    scoped_refptr<ColorProviderKey::ThemeInitializerSupplier> custom_theme,
-    bool use_custom_frame) const {
-  ColorProviderKey key;
-  key.color_mode = preferred_color_scheme() == PreferredColorScheme::kDark
-                       ? ColorProviderKey::ColorMode::kDark
-                       : ColorProviderKey::ColorMode::kLight;
-  key.contrast_mode = preferred_contrast() == PreferredContrast::kMore
-                          ? ColorProviderKey::ContrastMode::kHigh
-                          : ColorProviderKey::ContrastMode::kNormal;
-  key.forced_colors = forced_colors();
-  key.system_theme = system_theme();
-  key.frame_type = use_custom_frame ? ColorProviderKey::FrameType::kChromium
-                                    : ColorProviderKey::FrameType::kNative;
-  key.user_color_source = preferred_color_source_;
-  key.user_color = user_color();
-  key.scheme_variant = scheme_variant();
-  key.custom_theme = std::move(custom_theme);
-  return key;
+// static
+float NativeTheme::AdjustBorderRadiusByZoom(Part part,
+                                            float border_radius,
+                                            float zoom) {
+  return (part == kCheckbox || part == kTextField || part == kPushButton)
+             ? AdjustBorderWidthByZoom(border_radius, zoom)
+             : border_radius;
 }
 
-NativeTheme::NativeTheme(SystemTheme system_theme)
-    : system_theme_(system_theme) {}
+NativeTheme::NativeTheme(ui::SystemTheme system_theme)
+    : system_theme_(system_theme),
+      forced_colors_(IsForcedHighContrast()),
+      page_colors_(forced_colors_ ? PageColors::kHighContrast
+                                  : PageColors::kOff),
+      preferred_color_scheme_(IsForcedDarkMode()
+                                  ? PreferredColorScheme::kDark
+                                  : PreferredColorScheme::kLight),
+      preferred_contrast_(CalculatePreferredContrast()) {}
 
 NativeTheme::~NativeTheme() = default;
 
+void NativeTheme::PaintMenuItemBackground(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
+    State state,
+    const gfx::Rect& rect,
+    const MenuItemExtraParams& extra_params) const {
+  DCHECK(color_provider);
+  cc::PaintFlags flags;
+  switch (state) {
+    case NativeTheme::kNormal:
+    case NativeTheme::kDisabled: {
+      ui::ColorId id = kColorMenuBackground;
+#if BUILDFLAG(IS_CHROMEOS)
+      id = kColorAshSystemUIMenuBackground;
+#endif
+      flags.setColor(color_provider->GetColor(id));
+      break;
+    }
+    case NativeTheme::kHovered: {
+      ui::ColorId id = kColorMenuItemBackgroundSelected;
+#if BUILDFLAG(IS_CHROMEOS)
+      id = kColorAshSystemUIMenuItemBackgroundSelected;
+#endif
+      flags.setColor(color_provider->GetColor(id));
+      break;
+    }
+    default:
+      NOTREACHED() << "Invalid state " << state;
+  }
+  if (extra_params.corner_radius > 0) {
+    const SkScalar radius = SkIntToScalar(extra_params.corner_radius);
+    canvas->drawRoundRect(gfx::RectToSkRect(rect), radius, radius, flags);
+    return;
+  }
+  canvas->drawRect(gfx::RectToSkRect(rect), flags);
+}
+
+void NativeTheme::SetPreferredContrast(
+    NativeTheme::PreferredContrast preferred_contrast) {
+  if (preferred_contrast_ == preferred_contrast) {
+    return;
+  }
+  preferred_contrast_ = preferred_contrast;
+  NotifyOnPreferredContrastUpdated();
+}
+
 bool NativeTheme::IsForcedDarkMode() {
   static bool kIsForcedDarkMode =
       base::CommandLine::ForCurrentProcess()->HasSwitch(
@@ -375,28 +323,33 @@ bool NativeTheme::IsForcedHighContrast() {
   return kIsForcedHighContrast;
 }
 
-void NativeTheme::PaintMenuItemBackground(
-    cc::PaintCanvas* canvas,
-    const ColorProvider* color_provider,
-    State state,
-    const gfx::Rect& rect,
-    const MenuItemExtraParams& extra_params) const {
-  const SkScalar radius = SkIntToScalar(extra_params.corner_radius);
-  cc::PaintFlags flags;
-  const ColorId id = (state == kHovered)
-#if BUILDFLAG(IS_CHROMEOS)
-                         ? kColorAshSystemUIMenuItemBackgroundSelected
-                         : kColorAshSystemUIMenuBackground;
-#else
-                         ? kColorMenuItemBackgroundSelected
-                         : kColorMenuBackground;
-#endif
-  flags.setColor(color_provider->GetColor(id));
-  canvas->drawRoundRect(gfx::RectToSkRect(rect), radius, radius, flags);
+NativeTheme::PreferredContrast NativeTheme::CalculatePreferredContrast() const {
+  return IsForcedHighContrast() ? PreferredContrast::kMore
+                                : PreferredContrast::kNoPreference;
+}
+
+std::optional<SkColor> NativeTheme::GetSystemThemeColor(
+    SystemThemeColor theme_color) const {
+  auto color = system_colors_.find(theme_color);
+  if (color != system_colors_.end()) {
+    return color->second;
+  }
+
+  return std::nullopt;
 }
 
-void NativeTheme::OnToolkitSettingsChanged(bool force_notify) {
-  if (UpdateVariablesForToolkitSettings() || force_notify) {
+bool NativeTheme::HasDifferentSystemColors(
+    const std::map<NativeTheme::SystemThemeColor, SkColor>& colors) const {
+  return system_colors_ != colors;
+}
+
+void NativeTheme::set_system_colors(
+    const std::map<NativeTheme::SystemThemeColor, SkColor>& colors) {
+  system_colors_ = colors;
+}
+
+void NativeTheme::OnToolkitSettingsChanged() {
+  if (UpdateVariablesForToolkitSettings()) {
     NotifyOnNativeThemeUpdated();
   }
 }
@@ -416,6 +369,38 @@ bool NativeTheme::UpdateWebInstance() const {
     return false;
   }
 
+  bool new_forced_colors = forced_colors();
+  PreferredContrast new_preferred_contrast = preferred_contrast();
+  PreferredColorScheme new_preferred_color_scheme = preferred_color_scheme();
+
+  const auto default_page_colors =
+      new_forced_colors ? PageColors::kHighContrast : PageColors::kOff;
+  if (page_colors() != default_page_colors) {
+    if (page_colors() == PageColors::kOff) {
+      new_forced_colors = false;
+      new_preferred_contrast = PreferredContrast::kNoPreference;
+    } else if (page_colors() != PageColors::kHighContrast) {
+      // Set other states based on the selected theme (i.e. `kDusk`, `kDesert`,
+      // `kNightSky`, `kWhite`, or `kAquatic`). This block is only executed when
+      // one of these themes is chosen. `kHighContrast` is not a valid theme
+      // here, as it is only available in forced colors mode.
+      CHECK_NE(page_colors(), ui::NativeTheme::PageColors::kOff);
+      CHECK_NE(page_colors(), ui::NativeTheme::PageColors::kHighContrast);
+      new_forced_colors = true;
+      new_preferred_contrast = PreferredContrast::kMore;
+    }
+  }
+
+  // Only update the color scheme if page colors is a selected theme.
+  if (page_colors() != PageColors::kOff &&
+      page_colors() != PageColors::kHighContrast) {
+    const bool is_dark_theme = page_colors() == PageColors::kNightSky ||
+                               page_colors() == PageColors::kDusk ||
+                               page_colors() == PageColors::kAquatic;
+    new_preferred_color_scheme = is_dark_theme ? PreferredColorScheme::kDark
+                                               : PreferredColorScheme::kLight;
+  }
+
   // NOTE: Intentionally does not copy the native "overlay scrollbar" setting to
   // the web instance, as the web instance often wants to differ there.
   // TODO(crbug.com/444399080): If we had a notion somewhere about "web wants
@@ -430,18 +415,33 @@ bool NativeTheme::UpdateWebInstance() const {
   // Refactor to a settings struct or similar.
 
   bool updated_web_instance = false;
-  if (associated_web_instance_->forced_colors() != forced_colors()) {
-    associated_web_instance_->forced_colors_ = forced_colors();
+  if (associated_web_instance_->system_colors() != system_colors()) {
+    associated_web_instance_->system_colors_ = system_colors();
+    updated_web_instance = true;
+  }
+  if (associated_web_instance_->should_use_system_accent_color() !=
+      should_use_system_accent_color()) {
+    associated_web_instance_->should_use_system_accent_color_ =
+        should_use_system_accent_color();
+    updated_web_instance = true;
+  }
+  if (associated_web_instance_->forced_colors() != new_forced_colors) {
+    associated_web_instance_->forced_colors_ = new_forced_colors;
+    updated_web_instance = true;
+  }
+  if (associated_web_instance_->page_colors() != page_colors()) {
+    associated_web_instance_->page_colors_ = page_colors();
     updated_web_instance = true;
   }
   if (associated_web_instance_->preferred_color_scheme() !=
-      preferred_color_scheme()) {
+      new_preferred_color_scheme) {
     associated_web_instance_->preferred_color_scheme_ =
-        preferred_color_scheme();
+        new_preferred_color_scheme;
     updated_web_instance = true;
   }
-  if (associated_web_instance_->preferred_contrast() != preferred_contrast()) {
-    associated_web_instance_->preferred_contrast_ = preferred_contrast();
+  if (associated_web_instance_->preferred_contrast() !=
+      new_preferred_contrast) {
+    associated_web_instance_->preferred_contrast_ = new_preferred_contrast;
     updated_web_instance = true;
   }
   if (associated_web_instance_->prefers_reduced_transparency() !=
@@ -454,19 +454,6 @@ bool NativeTheme::UpdateWebInstance() const {
     associated_web_instance_->inverted_colors_ = inverted_colors();
     updated_web_instance = true;
   }
-  if (associated_web_instance_->user_color() != user_color()) {
-    associated_web_instance_->user_color_ = user_color();
-    updated_web_instance = true;
-  }
-  if (associated_web_instance_->scheme_variant() != scheme_variant()) {
-    associated_web_instance_->scheme_variant_ = scheme_variant();
-    updated_web_instance = true;
-  }
-  if (associated_web_instance_->preferred_color_source_ !=
-      preferred_color_source_) {
-    associated_web_instance_->preferred_color_source_ = preferred_color_source_;
-    updated_web_instance = true;
-  }
   if (associated_web_instance_->caret_blink_interval() !=
       caret_blink_interval()) {
     associated_web_instance_->caret_blink_interval_ = caret_blink_interval();
@@ -491,9 +478,6 @@ void NativeTheme::NotifyOnNativeThemeUpdatedImpl() {
   // NOTE: If any above observers already called `NotifyOnNativeThemeUpdated()`
   // on the web theme, this is unnecessary jank; however, it's not worth the
   // hassle to try to detect this.
-  //
-  // TODO(pkasting): Adding a scoping object to batch updates would address
-  // this; see comments in header above accessors.
   if (updated_web_instance) {
     // Calling `NotifyOnNativeThemeUpdated()` here would unnecessarily churn the
     // color provider cache.
@@ -501,6 +485,15 @@ void NativeTheme::NotifyOnNativeThemeUpdatedImpl() {
   }
 }
 
+void NativeTheme::NotifyOnPreferredContrastUpdatedImpl() {
+  const bool updated_web_instance = UpdateWebInstance();
+  native_theme_observers_.Notify(
+      &NativeThemeObserver::OnPreferredContrastChanged, this);
+  if (updated_web_instance) {
+    associated_web_instance_->NotifyOnPreferredContrastUpdatedImpl();
+  }
+}
+
 bool NativeTheme::UpdateVariablesForToolkitSettings() {
   // This should not be called except in an instance that is monitoring OS
   // setting changes. Otherwise, either:
@@ -517,53 +510,11 @@ bool NativeTheme::UpdateVariablesForToolkitSettings() {
 
   // Calculate updated values.
   const auto& os_settings_provider = OsSettingsProvider::Get();
-  const auto new_forced_colors = CalculateForcedColors();
-  const auto new_preferred_color_scheme = CalculatePreferredColorScheme();
-  const auto new_preferred_contrast = CalculatePreferredContrast();
-  const auto new_prefers_reduced_transparency =
-      os_settings_provider.PrefersReducedTransparency();
-  const auto new_inverted_colors = os_settings_provider.PrefersInvertedColors();
-  const auto new_user_color = os_settings_provider.AccentColor();
-  const auto new_scheme_variant = os_settings_provider.SchemeVariant();
-  const auto new_preferred_color_source =
-      os_settings_provider.PreferredColorSource();
   const auto new_caret_blink_interval =
       os_settings_provider.CaretBlinkInterval();
 
   // Set updated values and see if anything changed.
   bool updated = false;
-  if (forced_colors() != new_forced_colors) {
-    forced_colors_ = new_forced_colors;
-    updated = true;
-  }
-  if (preferred_color_scheme() != new_preferred_color_scheme) {
-    preferred_color_scheme_ = new_preferred_color_scheme;
-    updated = true;
-  }
-  if (preferred_contrast() != new_preferred_contrast) {
-    preferred_contrast_ = new_preferred_contrast;
-    updated = true;
-  }
-  if (prefers_reduced_transparency() != new_prefers_reduced_transparency) {
-    prefers_reduced_transparency_ = new_prefers_reduced_transparency;
-    updated = true;
-  }
-  if (inverted_colors() != new_inverted_colors) {
-    inverted_colors_ = new_inverted_colors;
-    updated = true;
-  }
-  if (user_color() != new_user_color) {
-    user_color_ = new_user_color;
-    updated = true;
-  }
-  if (scheme_variant() != new_scheme_variant) {
-    scheme_variant_ = new_scheme_variant;
-    updated = true;
-  }
-  if (preferred_color_source_ != new_preferred_color_source) {
-    preferred_color_source_ = new_preferred_color_source;
-    updated = true;
-  }
   if (caret_blink_interval() != new_caret_blink_interval) {
     caret_blink_interval_ = new_caret_blink_interval;
     updated = true;
@@ -572,22 +523,21 @@ bool NativeTheme::UpdateVariablesForToolkitSettings() {
   return updated;
 }
 
-ColorProviderKey::ForcedColors NativeTheme::CalculateForcedColors() const {
-  return (IsForcedHighContrast() ||
-          OsSettingsProvider::Get().ForcedColorsActive())
-             ? ColorProviderKey::ForcedColors::kSystem
-             : ColorProviderKey::ForcedColors::kNone;
+int NativeTheme::GetPaintedScrollbarTrackInset() const {
+  return 0;
 }
 
-NativeTheme::PreferredColorScheme NativeTheme::CalculatePreferredColorScheme()
-    const {
-  return IsForcedDarkMode() ? PreferredColorScheme::kDark
-                            : OsSettingsProvider::Get().PreferredColorScheme();
+gfx::Insets NativeTheme::GetScrollbarSolidColorThumbInsets(Part part) const {
+  return gfx::Insets();
 }
 
-NativeTheme::PreferredContrast NativeTheme::CalculatePreferredContrast() const {
-  return IsForcedHighContrast() ? PreferredContrast::kMore
-                                : OsSettingsProvider::Get().PreferredContrast();
+SkColor NativeTheme::GetScrollbarThumbColor(
+    const ui::ColorProvider& color_provider,
+    State state,
+    const ScrollbarThumbExtraParams& extra_params) const {
+  // A native theme using solid color scrollbar thumb must override this
+  // method.
+  NOTREACHED();
 }
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme.h b/ui/native_theme/native_theme.h
index d8c168edc6c92..3d72e21f84265 100644
--- a/ui/native_theme/native_theme.h
+++ b/ui/native_theme/native_theme.h
@@ -5,20 +5,17 @@
 #ifndef UI_NATIVE_THEME_NATIVE_THEME_H_
 #define UI_NATIVE_THEME_NATIVE_THEME_H_
 
-#include <stddef.h>
-
+#include <map>
 #include <optional>
 #include <variant>
 
 #include "base/callback_list.h"
 #include "base/component_export.h"
-#include "base/functional/callback_forward.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/observer_list.h"
 #include "base/sequence_checker.h"
 #include "base/time/time.h"
-#include "base/types/pass_key.h"
 #include "build/build_config.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "ui/base/models/menu_separator_types.h"
@@ -58,7 +55,7 @@ class NativeThemeObserver;
 // the GetPartSize() method.
 class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
  public:
-  // A part being sized or painted.
+  // The part to be painted / sized.
   enum Part {
     kCheckbox,
 #if BUILDFLAG(IS_LINUX)
@@ -79,7 +76,7 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
     kPushButton,
     kRadio,
 
-    // The order of these enums is important, do not change without also
+    // The order of the arrow enums is important, do not change without also
     // changing the code in platform implementations.
     kScrollbarDownArrow,
     kScrollbarLeftArrow,
@@ -95,7 +92,6 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
     // The corner is drawn when there is both a horizontal and vertical
     // scrollbar.
     kScrollbarCorner,
-
     kSliderTrack,
     kSliderThumb,
     kTabPanelBackground,
@@ -106,9 +102,9 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
     kMaxPart,
   };
 
-  // The state of some part being sized or painted.
+  // The state of the part.
   enum State {
-    // CAUTION: These values are used as array indexes.
+    // IDs defined as specific values for use in arrays.
     kDisabled = 0,
     kHovered = 1,
     kNormal = 2,
@@ -116,6 +112,20 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
     kNumStates = kPressed + 1,
   };
 
+  // Enum used for kPageColors pref. Page Colors is a browser setting that can
+  // be used to simulate forced colors mode. This enum should match its React
+  // counterpart.
+  enum PageColors {
+    kOff = 0,
+    kDusk = 1,
+    kDesert = 2,
+    kNightSky = 3,
+    kWhite = 4,
+    kHighContrast = 5,
+    kAquatic = 6,
+    kMaxValue = kAquatic,
+  };
+
   enum class PreferredColorScheme {
     kNoPreference = 0,
     kLight = 1,
@@ -123,11 +133,12 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
     kMaxValue = kDark,
   };
 
+  // OS-level preferred contrast. (Ex. high contrast or increased contrast.)
   enum class PreferredContrast {
     kNoPreference = 0,
     kMore = 1,
     kLess = 2,
-    kCustom = 3,  // E.g. forced colors outside of a contrast-related setting.
+    kCustom = 3,
     kMaxValue = kCustom,
   };
 
@@ -185,7 +196,7 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
 
   struct MenuSeparatorExtraParams {
     raw_ptr<const gfx::Rect> paint_rect = nullptr;
-    ColorId color_id = kColorMenuSeparator;
+    ui::ColorId color_id = ui::kColorMenuSeparator;
     MenuSeparatorType type = MenuSeparatorType::NORMAL_SEPARATOR;
   };
 
@@ -342,84 +353,96 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
                                    TextFieldExtraParams,
                                    TrackbarExtraParams>;
 
-  // Creating an instance of this class prevents `NotifyOnNativeThemeUpdated()`
-  // from having an effect in any `NativeTheme` instance until no scopers
-  // remain. When the last scoper is destroyed, any such delayed notifications
-  // will be fired.
-  class [[maybe_unused, nodiscard]] COMPONENT_EXPORT(NATIVE_THEME)
-      UpdateNotificationDelayScoper {
-   public:
-    UpdateNotificationDelayScoper();
-    UpdateNotificationDelayScoper(const UpdateNotificationDelayScoper&);
-    UpdateNotificationDelayScoper(UpdateNotificationDelayScoper&&);
-    UpdateNotificationDelayScoper& operator=(
-        const UpdateNotificationDelayScoper&) = default;
-    UpdateNotificationDelayScoper& operator=(UpdateNotificationDelayScoper&&) =
-        default;
-    ~UpdateNotificationDelayScoper();
-
-    static bool exists(base::PassKey<NativeTheme>) { return !!num_instances_; }
-
-    static base::CallbackListSubscription RegisterCallback(
-        base::PassKey<NativeTheme>,
-        base::OnceClosure cb);
-
-   private:
-    static base::OnceClosureList& GetDelayedNotifications();
-
-    static size_t num_instances_;
-  };
-
   NativeTheme(const NativeTheme&) = delete;
   NativeTheme& operator=(const NativeTheme&) = delete;
 
-  // Returns shared instances of the default native theme for native UI or the
-  // web, respectively.
-  static NativeTheme* GetInstanceForNativeUi();
-  static NativeTheme* GetInstanceForWeb();
-
-  // Convenience methods to scale a width/radius by a zoom factor.
-  static float AdjustBorderWidthByZoom(float border_width, float zoom_level);
-  static float AdjustBorderRadiusByZoom(Part part,
-                                        float border_radius,
-                                        float zoom_level);
-
+  // Return the size of the part.
   virtual gfx::Size GetPartSize(Part part,
                                 State state,
-                                const ExtraParams& extra_params) const;
-
+                                const ExtraParams& extra) const = 0;
   virtual int GetPaintedScrollbarTrackInset() const;
 
   virtual gfx::Insets GetScrollbarSolidColorThumbInsets(Part part) const;
 
+  // Called if the theme uses solid color for scrollbar thumb.
+  virtual SkColor GetScrollbarThumbColor(
+      const ui::ColorProvider& color_provider,
+      State state,
+      const ScrollbarThumbExtraParams& extra_params) const;
+
   virtual float GetBorderRadiusForPart(Part part,
                                        float width,
                                        float height) const;
 
+  // Paint the part to the canvas.
+  virtual void Paint(cc::PaintCanvas* canvas,
+                     const ui::ColorProvider* color_provider,
+                     Part part,
+                     State state,
+                     const gfx::Rect& rect,
+                     const ExtraParams& extra,
+                     bool forced_colors,
+                     PreferredColorScheme color_scheme,
+                     PreferredContrast contrast,
+                     const std::optional<SkColor>& accent_color) const = 0;
+  void Paint(
+      cc::PaintCanvas* canvas,
+      const ui::ColorProvider* color_provider,
+      Part part,
+      State state,
+      const gfx::Rect& rect,
+      const ExtraParams& extra,
+      bool forced_colors = false,
+      PreferredColorScheme color_scheme = PreferredColorScheme::kNoPreference,
+      PreferredContrast contrast = PreferredContrast::kNoPreference) const {
+    Paint(canvas, color_provider, part, state, rect, extra, forced_colors,
+          color_scheme, contrast, std::nullopt);
+  }
+
   // Returns whether the theme uses a nine-patch resource for the given part.
   // If true, calling code should always paint into a canvas the size of which
   // can be gotten from GetNinePatchCanvasSize.
-  virtual bool SupportsNinePatch(Part part) const;
+  virtual bool SupportsNinePatch(Part part) const = 0;
 
   // If the part paints into a nine-patch resource, the size of the canvas
   // which should be painted into.
-  virtual gfx::Size GetNinePatchCanvasSize(Part part) const;
+  virtual gfx::Size GetNinePatchCanvasSize(Part part) const = 0;
 
   // If the part paints into a nine-patch resource, the rect in the canvas
   // which defines the center tile. This is the tile that should be resized out
   // when the part is resized.
-  virtual gfx::Rect GetNinePatchAperture(Part part) const;
+  virtual gfx::Rect GetNinePatchAperture(Part part) const = 0;
+
+  enum class SystemThemeColor {
+    kNotSupported,
+    kButtonFace,
+    kButtonHighlight,
+    kButtonText,
+    kGrayText,
+    kHighlight,
+    kHighlightText,
+    kHotlight,
+    kMenuHighlight,
+    kScrollbar,
+    kWindow,
+    kWindowText,
+    kMaxValue = kWindowText,
+  };
 
-  // The scrollbar thumb color, if the theme uses a solid color for the
-  // scrollbar thumb.
-  virtual SkColor GetScrollbarThumbColor(
-      const ColorProvider* color_provider,
-      State state,
-      const ScrollbarThumbExtraParams& extra_params) const;
+  // Returns the key corresponding to this native theme object.
+  // Use `use_custom_frame` == true when Chromium renders the titlebar.
+  // False when the window manager renders the titlebar (currently GTK only).
+  ColorProviderKey GetColorProviderKey(
+      scoped_refptr<ColorProviderKey::ThemeInitializerSupplier> custom_theme,
+      bool use_custom_frame = true) const;
 
-  // Returns the color the toolkit would use for a pressed button that has an
-  // unpressed color of `base_color`.
-  virtual SkColor GetSystemButtonPressedColor(SkColor base_color) const;
+  // Returns shared instances of the default native theme for native UI or the
+  // web, respectively.
+  static NativeTheme* GetInstanceForNativeUi();
+  static NativeTheme* GetInstanceForWeb();
+
+  // Whether OS-level dark mode is available in the current OS.
+  static bool SystemDarkModeSupported();
 
   // Registers this instance as an observer of `OsSettingsProvider` changes.
   // This should not be called on an instance marked as the "associated web
@@ -427,102 +450,81 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
   // notify about setting changes as necessary.
   void BeginObservingOsSettingChanges();
 
-  // Adds or removes observers to be notified when the native theme changes.
+  // Add or remove observers to be notified when the native theme changes.
   void AddObserver(NativeThemeObserver* observer);
   void RemoveObserver(NativeThemeObserver* observer);
 
-  // Notifies observers that something has changed and they should reload
-  // settings if needed. This also resets the color provider cache.
-  // CAUTION: This is expensive; minimize unnecessary calls.
-  void NotifyOnNativeThemeUpdated();
-
-  // TODO(pkasting): Consider combining this with
-  // `NotifyOnNativeThemeUpdated()`. This would make it easy to move the
-  // underpinnings to the `OsSettingsProvider`, as well as replace
-  // `NativeThemeObserver` with a `CallbackList`.
-  void NotifyOnCaptionStyleUpdated();
+  // Notify observers of native theme changes.
+  virtual void NotifyOnNativeThemeUpdated();
 
-  // Paints the provided `part`/`state`. This is largely a wrapper around
-  // `PaintImpl()`.
-  void Paint(
-      cc::PaintCanvas* canvas,
-      const ColorProvider* color_provider,
-      Part part,
-      State state,
-      const gfx::Rect& rect,
-      const ExtraParams& extra_params,
-      bool forced_colors = false,
-      PreferredColorScheme color_scheme = PreferredColorScheme::kNoPreference,
-      PreferredContrast contrast = PreferredContrast::kNoPreference,
-      std::optional<SkColor> accent_color = std::nullopt) const;
+  // Notify observers of caption style changes.
+  virtual void NotifyOnCaptionStyleUpdated();
 
-  // Returns the key corresponding to this native theme object.
-  // Use `use_custom_frame` == true when Chromium renders the titlebar.
-  // False when the window manager renders the titlebar (currently GTK only).
-  ColorProviderKey GetColorProviderKey(
-      scoped_refptr<ColorProviderKey::ThemeInitializerSupplier> custom_theme,
-      bool use_custom_frame = true) const;
+  // Notify observers of preferred contrast changes.
+  virtual void NotifyOnPreferredContrastUpdated();
 
-  // Accessors.
-  //
-  // NOTE: Be very cautious about using the setters here.
-  //   * Tests generally should not modify `NativeTheme` state; if the goal is
-  //     to pretend the underlying system is in a particular state, use
-  //     `MockOsSettingsProvider` instead.
-  //
-  //   * The values set below may be overwritten automatically, e.g. when system
-  //     settings change; so if the goal is to override system-native behavior,
-  //     "fire and forget" usage is insufficient.
-  //
-  //   * To avoid jank from repeated notifications, these do not automatically
-  //     call `NotifyOnNativeThemeUpdated()`. Failing to call that manually
-  //     after using them typically results in cryptic bugs.
-  //
-  // TODO(pkasting): To address the third point, consider using
-  // `UpdateNotificationDelayScoper` everywhere that currently calls these
-  // setters or writes directly to the underlying members. Then make the setters
-  // call `NotifyOnNativeThemeUpdated()` whenever the actual value changes and
-  // change all direct writes to use the setters. At that point forgetting to
-  // notify will be impossible, but we will only get one such notification.
-
-  SystemTheme system_theme() const { return system_theme_; }
-
-  bool use_overlay_scrollbar() const { return use_overlay_scrollbar_; }
-  void set_use_overlay_scrollbar(bool use_overlay_scrollbar) {
-    use_overlay_scrollbar_ = use_overlay_scrollbar;
-  }
+  // Returns whether we are in forced colors mode, controlled by system
+  // accessibility settings. Currently, Windows high contrast is the only system
+  // setting that triggers forced colors mode.
+  bool forced_colors() const { return forced_colors_; }
 
-  ColorProviderKey::ForcedColors forced_colors() const {
-    return forced_colors_;
-  }
-  void set_forced_colors(ColorProviderKey::ForcedColors forced_colors) {
-    forced_colors_ = forced_colors;
-  }
+  // Returns the user's current page colors.
+  PageColors page_colors() const { return page_colors_; }
 
+  // Returns OS-level preferred color scheme, or `kNoPreference` if not
+  // set/applicable.
   PreferredColorScheme preferred_color_scheme() const {
     return preferred_color_scheme_;
   }
-  void set_preferred_color_scheme(PreferredColorScheme preferred_color_scheme) {
-    preferred_color_scheme_ = preferred_color_scheme;
-  }
 
+  // Returns the OS-level user preferred contrast.
   PreferredContrast preferred_contrast() const { return preferred_contrast_; }
-  void set_preferred_contrast(PreferredContrast preferred_contrast) {
-    preferred_contrast_ = preferred_contrast;
-  }
 
+  // Returns the OS-level user preferred transparency.
   bool prefers_reduced_transparency() const {
     return prefers_reduced_transparency_;
   }
 
+  // Returns the OS-level inverted colors setting. (Classic invert NOT smart
+  // invert)
   bool inverted_colors() const { return inverted_colors_; }
 
-  std::optional<SkColor> user_color() const { return user_color_; }
+  const std::map<SystemThemeColor, SkColor>& system_colors() const {
+    return system_colors_;
+  }
+
+  std::optional<SkColor> GetSystemThemeColor(
+      SystemThemeColor theme_color) const;
+
+  bool HasDifferentSystemColors(
+      const std::map<SystemThemeColor, SkColor>& colors) const;
+
+  void set_forced_colors(bool forced_colors) { forced_colors_ = forced_colors; }
+  void set_page_colors(PageColors page_colors) { page_colors_ = page_colors; }
+  void set_preferred_color_scheme(PreferredColorScheme preferred_color_scheme) {
+    preferred_color_scheme_ = preferred_color_scheme;
+  }
+  void set_prefers_reduced_transparency(bool prefers_reduced_transparency) {
+    prefers_reduced_transparency_ = prefers_reduced_transparency;
+  }
+  void set_inverted_colors(bool inverted_colors) {
+    inverted_colors_ = inverted_colors;
+  }
+  void SetPreferredContrast(PreferredContrast preferred_contrast);
+  void set_system_colors(const std::map<SystemThemeColor, SkColor>& colors);
+  ui::SystemTheme system_theme() const { return system_theme_; }
+
+  // Set the user_color for ColorProviderKey.
   void set_user_color(std::optional<SkColor> user_color) {
     user_color_ = user_color;
   }
+  std::optional<SkColor> user_color() const { return user_color_; }
 
-  std::optional<ColorProviderKey::SchemeVariant> scheme_variant() const {
+  void set_scheme_variant(
+      std::optional<ui::ColorProviderKey::SchemeVariant> scheme_variant) {
+    scheme_variant_ = scheme_variant;
+  }
+  std::optional<ui::ColorProviderKey::SchemeVariant> scheme_variant() const {
     return scheme_variant_;
   }
 
@@ -531,28 +533,38 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
     caret_blink_interval_ = caret_blink_interval;
   }
 
- protected:
-  explicit NativeTheme(SystemTheme system_theme = SystemTheme::kDefault);
-  virtual ~NativeTheme();
+  void set_should_use_system_accent_color(bool should_use_system_accent_color) {
+    should_use_system_accent_color_ = should_use_system_accent_color;
+  }
+  bool should_use_system_accent_color() const {
+    return should_use_system_accent_color_;
+  }
 
-  // Whether dark mode is forced via command-line flag.
-  static bool IsForcedDarkMode();
+  bool use_overlay_scrollbar() const { return use_overlay_scrollbars_; }
+  void set_use_overlay_scrollbar(bool use_overlay_scrollbar) {
+    use_overlay_scrollbars_ = use_overlay_scrollbar;
+  }
+
+  // On certain platforms, currently only Mac, there is a unique visual for
+  // pressed states.
+  virtual SkColor GetSystemButtonPressedColor(SkColor base_color) const;
+
+  static float AdjustBorderWidthByZoom(float border_width, float zoom_level);
+
+  static float AdjustBorderRadiusByZoom(Part part,
+                                        float border_width,
+                                        float zoom_level);
 
   // Whether high contrast is forced via command-line flag.
   static bool IsForcedHighContrast();
 
-  // Paints the provided `part`/`state`. Subclasses must override this if they
-  // want visible output.
-  virtual void PaintImpl(cc::PaintCanvas* canvas,
-                         const ColorProvider* color_provider,
-                         Part part,
-                         State state,
-                         const gfx::Rect& rect,
-                         const ExtraParams& extra_params,
-                         bool forced_colors,
-                         bool dark_mode,
-                         PreferredContrast contrast,
-                         std::optional<SkColor> accent_color) const {}
+  // Whether dark mode is forced via command-line flag.
+  static bool IsForcedDarkMode();
+
+ protected:
+  explicit NativeTheme(
+      ui::SystemTheme system_theme = ui::SystemTheme::kDefault);
+  virtual ~NativeTheme();
 
   // Common implementation used by several subclasses.
   virtual void PaintMenuItemBackground(
@@ -562,9 +574,12 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
       const gfx::Rect& rect,
       const MenuItemExtraParams& extra_params) const;
 
+  // Calculates and returns the current user preferred contrast.
+  virtual PreferredContrast CalculatePreferredContrast() const;
+
   // Called when toolkit settings change. Updates affected variables. If
-  // anything changes or `force_notify` is set, notifies observers.
-  virtual void OnToolkitSettingsChanged(bool force_notify);
+  // anything changes, notifies observers.
+  virtual void OnToolkitSettingsChanged();
 
   // Instructs this theme instance to mirror various appearance settings to
   // `associated_web_instance` when they change.
@@ -574,36 +589,43 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeTheme {
   // instance's current settings. Returns whether anything was changed.
   bool UpdateWebInstance() const;
 
+  mutable std::map<SystemThemeColor, SkColor> system_colors_;
+
  private:
   // Updates web instance and notifies observers something has changed.
   void NotifyOnNativeThemeUpdatedImpl();
+  void NotifyOnPreferredContrastUpdatedImpl();
 
   // Updates variables affected by toolkit settings and returns whether anything
   // changed as a result.
   bool UpdateVariablesForToolkitSettings();
 
-  // Calculates and returns appropriate values based on flags and toolkit.
-  ColorProviderKey::ForcedColors CalculateForcedColors() const;
-  PreferredColorScheme CalculatePreferredColorScheme() const;
-  PreferredContrast CalculatePreferredContrast() const;
-
   base::CallbackListSubscription os_settings_changed_subscription_;
-  base::CallbackListSubscription update_delay_subscription_;
+
+  // Observers to notify when the native theme changes.
   base::ObserverList<NativeThemeObserver> native_theme_observers_;
-  SystemTheme system_theme_;
-  bool use_overlay_scrollbar_ = false;
-  ColorProviderKey::ForcedColors forced_colors_ =
-      ColorProviderKey::ForcedColors::kNone;
-  PreferredColorScheme preferred_color_scheme_ =
-      PreferredColorScheme::kNoPreference;
-  PreferredContrast preferred_contrast_ = PreferredContrast::kNoPreference;
+
+  // User's primary color. Included in the `ColorProvider::Key` as the basis of
+  // all generated colors.
+  std::optional<SkColor> user_color_;
+
+  // System color scheme variant. Used in `ColorProvider::Key` to specify the
+  // transforms of `user_color_` which generate colors.
+  std::optional<ui::ColorProviderKey::SchemeVariant> scheme_variant_;
+
+  // Determines whether generated colors should express the system's accent
+  // color if present.
+  bool should_use_system_accent_color_ = true;
+
+  const ui::SystemTheme system_theme_;
+  bool forced_colors_ = false;
+  PageColors page_colors_ = PageColors::kOff;
   bool prefers_reduced_transparency_ = false;
   bool inverted_colors_ = false;
-  std::optional<SkColor> user_color_;
-  std::optional<ColorProviderKey::SchemeVariant> scheme_variant_;
-  ColorProviderKey::UserColorSource preferred_color_source_ =
-      ColorProviderKey::UserColorSource::kAccent;
+  PreferredColorScheme preferred_color_scheme_ = PreferredColorScheme::kLight;
+  PreferredContrast preferred_contrast_ = PreferredContrast::kNoPreference;
   base::TimeDelta caret_blink_interval_;
+  bool use_overlay_scrollbars_ = false;
 
   raw_ptr<NativeTheme> associated_web_instance_ = nullptr;
 
diff --git a/ui/native_theme/native_theme_aura.cc b/ui/native_theme/native_theme_aura.cc
index 7fcf736c925e3..3fc0ce586f49e 100644
--- a/ui/native_theme/native_theme_aura.cc
+++ b/ui/native_theme/native_theme_aura.cc
@@ -7,6 +7,7 @@
 #include <optional>
 
 #include "base/check.h"
+#include "base/check_op.h"
 #include "base/feature_list.h"
 #include "base/logging.h"
 #include "base/no_destructor.h"
@@ -16,9 +17,11 @@
 #include "cc/paint/paint_flags.h"
 #include "third_party/skia/include/core/SkBlendMode.h"
 #include "third_party/skia/include/core/SkColor.h"
+#include "third_party/skia/include/core/SkPath.h"
 #include "third_party/skia/include/core/SkScalar.h"
 #include "ui/color/color_id.h"
 #include "ui/color/color_provider.h"
+#include "ui/gfx/color_palette.h"
 #include "ui/gfx/geometry/insets.h"
 #include "ui/gfx/geometry/insets_f.h"
 #include "ui/gfx/geometry/rect.h"
@@ -34,121 +37,74 @@ namespace ui {
 
 namespace {
 
-// The border is 2 pixels despite the stroke width being 1 so that the inner
-// pixel can match the center tile color. This prevents color interpolation
-// between the patches.
-constexpr gfx::Insets kOverlayScrollbarBorderInsets(2);
-
+// Constants for painting overlay scrollbars. Other properties needed outside
+// this painting code are defined in overlay_scrollbar_constants_aura.h.
+constexpr int kOverlayScrollbarMinimumLength = 32;
+// 2 pixel border with 1 pixel center patch. The border is 2 pixels despite the
+// stroke width being 1 so that the inner pixel can match the center tile
+// color. This prevents color interpolation between the patches.
+constexpr int kOverlayScrollbarBorderPatchWidth = 2;
+constexpr int kOverlayScrollbarCenterPatchSize = 1;
+
+// This radius let scrollbar arrows fit in the default rounded border of some
+// form controls. TODO(crbug.com/40285711): We should probably let blink pass
+// the actual border radii.
+const SkScalar kScrollbarArrowRadius = 1;
 // Killswitch for the changed behavior (only drawing rounded corner for form
 // controls). Should remove after M120 ships.
 BASE_FEATURE(kNewScrollbarArrowRadius, base::FEATURE_ENABLED_BY_DEFAULT);
 
 }  // namespace
 
-gfx::Insets NativeThemeAura::GetScrollbarSolidColorThumbInsets(
-    Part part) const {
-  if (use_overlay_scrollbar()) {
-    return {};
-  }
-
-  static constexpr int kThumbPadding = 2;
-  auto insets = gfx::Insets::VH(
-      // If there are no buttons then provide some padding so that the thumb
-      // doesn't touch the end of the track.
-      GetVerticalScrollbarButtonSize().IsEmpty() ? kThumbPadding : 0,
-      kThumbPadding);
-  if (part == kScrollbarHorizontalTrack) {
-    insets.Transpose();
-  }
-  return insets;
-}
-
-bool NativeThemeAura::SupportsNinePatch(Part part) const {
-  return use_overlay_scrollbar() &&
-         (part == kScrollbarHorizontalThumb || part == kScrollbarVerticalThumb);
-}
-
-gfx::Size NativeThemeAura::GetNinePatchCanvasSize(Part part) const {
-  CHECK(SupportsNinePatch(part));
-
-  static constexpr int kCenterPatchSize = 1;
-  return gfx::Size(kOverlayScrollbarBorderInsets.width() + kCenterPatchSize,
-                   kOverlayScrollbarBorderInsets.height() + kCenterPatchSize);
-}
-
-gfx::Rect NativeThemeAura::GetNinePatchAperture(Part part) const {
-  CHECK(SupportsNinePatch(part));
-
-  gfx::Rect aperture(GetNinePatchCanvasSize(part));
-  aperture.Inset(kOverlayScrollbarBorderInsets);
-  return aperture;
-}
+////////////////////////////////////////////////////////////////////////////////
+// NativeThemeAura:
 
 NativeThemeAura::NativeThemeAura(bool use_overlay_scrollbar) {
   set_use_overlay_scrollbar(use_overlay_scrollbar);
-}
-
-NativeThemeAura::NativeThemeAura(SystemTheme system_theme)
-    : NativeThemeBase(system_theme) {}
-
-NativeThemeAura::~NativeThemeAura() = default;
-
-gfx::Size NativeThemeAura::GetVerticalScrollbarButtonSize() const {
-  gfx::Size size = NativeThemeBase::GetVerticalScrollbarButtonSize();
-  if (use_overlay_scrollbar()) {
-    // NOTE: The overlay scrollbar thumb omits the stroke on the trailing
-    // "thickness" edge, so only including its width a single time here is
-    // intentional.
-    size.set_width(kOverlayScrollbarThumbWidthPressed +
-                   kOverlayScrollbarStrokeWidth);
+  if (use_overlay_scrollbar) {
+    scrollbar_width_ =
+        kOverlayScrollbarThumbWidthPressed + kOverlayScrollbarStrokeWidth;
   }
+  // We don't draw scrollbar buttons.
 #if BUILDFLAG(IS_CHROMEOS)
-  // CrOS does not draw scrollbar buttons. Be careful to leave the width valid,
-  // however, as that value is also used for the track width.
-  size.set_height(0);
+  set_scrollbar_button_length(0);
 #endif
-  return size;
 }
 
-gfx::Size NativeThemeAura::GetVerticalScrollbarThumbSize() const {
-  if (use_overlay_scrollbar()) {
-    return gfx::Size(GetVerticalScrollbarButtonSize().width(),
-                     32 + 2 * kOverlayScrollbarStrokeWidth);
-  }
-  return NativeThemeBase::GetVerticalScrollbarThumbSize();
-}
-
-std::optional<ColorId> NativeThemeAura::GetScrollbarThumbColorId(
-    State state,
-    const ScrollbarThumbExtraParams& extra_params) const {
-  if (!use_overlay_scrollbar()) {
-    return std::nullopt;
-  }
-  return (state == kHovered || state == kPressed)
-             ? kColorOverlayScrollbarFillHovered
-             : kColorOverlayScrollbarFill;
+NativeThemeAura::NativeThemeAura(SystemTheme system_theme)
+    : NativeThemeBase(system_theme) {
+  // We don't draw scrollbar buttons.
+#if BUILDFLAG(IS_CHROMEOS)
+  set_scrollbar_button_length(0);
+#endif
 }
 
-float NativeThemeAura::GetScrollbarPartContrastRatioForState(
-    State state) const {
-  return state == kPressed ? 1.3f : 1.8f;
-}
+NativeThemeAura::~NativeThemeAura() = default;
 
 void NativeThemeAura::PaintMenuPopupBackground(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
     const gfx::Size& size,
-    const MenuBackgroundExtraParams& extra_params) const {
-  CHECK(color_provider);
-  // TODO(crbug.com/40219248): Use `SkColor4f` everywhere.
-  const auto color =
+    const MenuBackgroundExtraParams& menu_background) const {
+  DCHECK(color_provider);
+  // TODO(crbug.com/40219248): Remove FromColor and make all SkColor4f.
+  SkColor4f color =
       SkColor4f::FromColor(color_provider->GetColor(kColorMenuBackground));
-  if (extra_params.corner_radius > 0) {
-    const SkScalar r = SkIntToScalar(extra_params.corner_radius);
+  if (menu_background.corner_radius > 0) {
     cc::PaintFlags flags;
+    flags.setStyle(cc::PaintFlags::kFill_Style);
     flags.setAntiAlias(true);
     flags.setColor(color);
-    canvas->drawRoundRect(gfx::RectToSkRect(gfx::Rect(size)), r, r, flags);
+
+    SkPath path;
+    SkRect rect = SkRect::MakeWH(SkIntToScalar(size.width()),
+                                 SkIntToScalar(size.height()));
+    SkScalar radius = SkIntToScalar(menu_background.corner_radius);
+    SkScalar radii[8] = {radius, radius, radius, radius,
+                         radius, radius, radius, radius};
+    path.addRoundRect(rect, radii);
+
+    canvas->drawPath(path, flags);
   } else {
     canvas->drawColor(color, SkBlendMode::kSrc);
   }
@@ -158,47 +114,111 @@ void NativeThemeAura::PaintArrowButton(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
     const gfx::Rect& rect,
-    Part part,
+    Part direction,
     State state,
     bool forced_colors,
     bool dark_mode,
     PreferredContrast contrast,
     const ScrollbarArrowExtraParams& extra_params) const {
-  const SkColor bg_color = GetScrollbarArrowBackgroundColor(
-      extra_params, state, dark_mode, contrast, color_provider);
-  cc::PaintFlags bg_flags;
-  bg_flags.setColor(bg_color);
+  SkColor bg_color =
+      GetControlColor(kScrollbarArrowBackground, dark_mode, color_provider);
+  // Aura-win uses slightly different arrow colors.
+  SkColor arrow_color = gfx::kPlaceholderColor;
+  switch (state) {
+    case kDisabled:
+      arrow_color = GetArrowColor(state, dark_mode, color_provider);
+      break;
+    case kHovered:
+      bg_color = GetControlColor(kScrollbarArrowBackgroundHovered, dark_mode,
+                                 color_provider);
+      arrow_color =
+          GetControlColor(kScrollbarArrowHovered, dark_mode, color_provider);
+      break;
+    case kNormal:
+      arrow_color = GetControlColor(kScrollbarArrow, dark_mode, color_provider);
+      break;
+    case kPressed:
+      bg_color = GetControlColor(kScrollbarArrowBackgroundPressed, dark_mode,
+                                 color_provider);
+      arrow_color =
+          GetControlColor(kScrollbarArrowPressed, dark_mode, color_provider);
+      break;
+    case kNumStates:
+      break;
+  }
+  if (extra_params.thumb_color.has_value() &&
+      extra_params.thumb_color.value() == gfx::kPlaceholderColor) {
+    // TODO(crbug.com/40278836): Remove this and the below checks for
+    // placeholderColor.
+    DLOG(ERROR) << "thumb_color with a placeholderColor value encountered";
+  }
+  if (extra_params.track_color.has_value() &&
+      extra_params.track_color.value() != gfx::kPlaceholderColor) {
+    bg_color = GetContrastingPressedOrHoveredColor(extra_params.track_color,
+                                                   /*bg_color=*/std::nullopt,
+                                                   state, direction)
+                   .value();
+  }
+  if (extra_params.thumb_color.has_value() &&
+      extra_params.thumb_color.value() != gfx::kPlaceholderColor) {
+    arrow_color = GetContrastingPressedOrHoveredColor(
+                      extra_params.thumb_color, bg_color, state, direction)
+                      .value();
+  }
+  DCHECK_NE(arrow_color, gfx::kPlaceholderColor);
+
+  cc::PaintFlags flags;
+  flags.setColor(bg_color);
 
   if (base::FeatureList::IsEnabled(kNewScrollbarArrowRadius) &&
       !extra_params.needs_rounded_corner) {
-    canvas->drawRect(gfx::RectToSkRect(rect), bg_flags);
+    canvas->drawIRect(gfx::RectToSkIRect(rect), flags);
   } else {
-    // This radius lets scrollbar arrows fit in the default rounded border of
-    // some form controls.
-    // TODO(crbug.com/40285711): We should probably let blink pass the actual
-    // border radii.
-    static constexpr SkScalar kUnscaledRadius = 1;
-    const SkScalar radius =
-        kUnscaledRadius * (extra_params.zoom ? extra_params.zoom : 1.0);
-    SkScalar ul = 0, ll = 0, ur = 0, lr = 0;
-    if (part == kScrollbarDownArrow) {
-      (extra_params.right_to_left ? ll : lr) = radius;
-    } else if (part == kScrollbarLeftArrow) {
-      ll = radius;
-    } else if (part == kScrollbarRightArrow) {
-      lr = radius;
-    } else if (part == kScrollbarUpArrow) {
-      (extra_params.right_to_left ? ul : ur) = radius;
+    // TODO(crbug.com/40285711): Also draw rounded corner for left and right
+    // buttons when needed.
+    SkScalar upper_left_radius = 0;
+    SkScalar lower_left_radius = 0;
+    SkScalar upper_right_radius = 0;
+    SkScalar lower_right_radius = 0;
+    float zoom = extra_params.zoom ? extra_params.zoom : 1.0;
+    if (direction == kScrollbarUpArrow) {
+      if (extra_params.right_to_left) {
+        upper_left_radius = kScrollbarArrowRadius * zoom;
+      } else {
+        upper_right_radius = kScrollbarArrowRadius * zoom;
+      }
+    } else if (direction == kScrollbarDownArrow) {
+      if (extra_params.right_to_left) {
+        lower_left_radius = kScrollbarArrowRadius * zoom;
+      } else {
+        lower_right_radius = kScrollbarArrowRadius * zoom;
+      }
     }
-    const gfx::RRectF rrect(gfx::RectF(rect), ul, ul, ur, ur, lr, lr, ll, ll);
-    bg_flags.setAntiAlias(true);
-    canvas->drawRRect(static_cast<SkRRect>(rrect), bg_flags);
+    DrawPartiallyRoundRect(canvas, rect, upper_left_radius, upper_right_radius,
+                           lower_right_radius, lower_left_radius, flags);
   }
 
-  PaintArrow(
-      canvas, rect, part, state,
-      GetScrollbarArrowForegroundColor(bg_color, extra_params, state, dark_mode,
-                                       contrast, color_provider));
+  PaintArrow(canvas, rect, direction, arrow_color);
+}
+
+void NativeThemeAura::PaintScrollbarTrack(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
+    Part part,
+    State state,
+    const ScrollbarTrackExtraParams& extra_params,
+    const gfx::Rect& rect,
+    bool forced_colors,
+    PreferredContrast contrast) const {
+  // Overlay Scrollbar should never paint a scrollbar track.
+  DCHECK(!use_overlay_scrollbar());
+  cc::PaintFlags flags;
+  const SkColor track_color =
+      extra_params.track_color.has_value()
+          ? extra_params.track_color.value()
+          : GetControlColor(kScrollbarTrack, {}, color_provider);
+  flags.setColor(track_color);
+  canvas->drawIRect(gfx::RectToSkIRect(rect), flags);
 }
 
 void NativeThemeAura::PaintScrollbarThumb(
@@ -208,6 +228,7 @@ void NativeThemeAura::PaintScrollbarThumb(
     State state,
     const gfx::Rect& rect,
     const ScrollbarThumbExtraParams& extra_params) const {
+  // Do not paint if state is disabled.
   if (state == kDisabled) {
     return;
   }
@@ -215,57 +236,91 @@ void NativeThemeAura::PaintScrollbarThumb(
   TRACE_EVENT0("blink", "NativeThemeAura::PaintScrollbarThumb");
 
   gfx::Rect fill_rect(rect);
-  fill_rect.Inset(GetScrollbarSolidColorThumbInsets(part));
+  cc::PaintFlags fill_flags;
+
   if (use_overlay_scrollbar()) {
-    // Paint a stroke.
+    if (state == NativeTheme::kDisabled) {
+      return;
+    }
+
+    const bool hovered = state != kNormal;
+
+    DCHECK(color_provider);
+    fill_flags.setColor(extra_params.thumb_color.value_or(
+        color_provider->GetColor(hovered ? kColorOverlayScrollbarFillHovered
+                                         : kColorOverlayScrollbarFill)));
+    const SkColor stroke_color =
+        color_provider->GetColor(hovered ? kColorOverlayScrollbarStrokeHovered
+                                         : kColorOverlayScrollbarStroke);
+
+    // In overlay mode, draw a stroke (border).
+    constexpr int kStrokeWidth = kOverlayScrollbarStrokeWidth;
+    cc::PaintFlags stroke_flags;
+    stroke_flags.setColor(stroke_color);
+    stroke_flags.setStyle(cc::PaintFlags::kStroke_Style);
+    stroke_flags.setStrokeWidth(kStrokeWidth);
+
     gfx::RectF stroke_rect(fill_rect);
+    gfx::InsetsF stroke_insets(kStrokeWidth / 2.f);
     // The edge to which the scrollbar is attached shouldn't have a border.
     gfx::Insets edge_adjust_insets;
     if (part == NativeTheme::kScrollbarHorizontalThumb) {
-      edge_adjust_insets.set_bottom(-kOverlayScrollbarStrokeWidth);
+      edge_adjust_insets.set_bottom(-kStrokeWidth);
     } else {
-      edge_adjust_insets.set_right(-kOverlayScrollbarStrokeWidth);
+      edge_adjust_insets.set_right(-kStrokeWidth);
     }
-    stroke_rect.Inset(gfx::InsetsF(kOverlayScrollbarStrokeWidth / 2.0f) +
-                      static_cast<gfx::InsetsF>(edge_adjust_insets));
-
-    cc::PaintFlags stroke_flags;
-    CHECK(color_provider);
-    stroke_flags.setColor(color_provider->GetColor(
-        state == kNormal ? kColorOverlayScrollbarStroke
-                         : kColorOverlayScrollbarStrokeHovered));
-    stroke_flags.setStyle(cc::PaintFlags::kStroke_Style);
-    stroke_flags.setStrokeWidth(kOverlayScrollbarStrokeWidth);
+    stroke_rect.Inset(stroke_insets + gfx::InsetsF(edge_adjust_insets));
     canvas->drawRect(gfx::RectFToSkRect(stroke_rect), stroke_flags);
 
-    // Inset all the edges so we don't fill in the stroke below. For a left
-    // vertical scrollbar, we will horizontally flip the canvas in
-    // `ScrollbarThemeOverlay::PaintThumb()`.
-    fill_rect.Inset(gfx::Insets(kOverlayScrollbarStrokeWidth) +
-                    edge_adjust_insets);
+    // Inset the all the edges edges so we fill-in the stroke below.
+    // For left vertical scrollbar, we will horizontally flip the canvas in
+    // ScrollbarThemeOverlay::paintThumb.
+    gfx::Insets fill_insets(kStrokeWidth);
+    fill_rect.Inset(fill_insets + edge_adjust_insets);
+  } else {
+    fill_rect.Inset(GetScrollbarSolidColorThumbInsets(part));
+    fill_flags.setColor(
+        GetScrollbarThumbColor(*color_provider, state, extra_params));
   }
 
-  cc::PaintFlags fill_flags;
-  fill_flags.setColor(
-      GetScrollbarThumbColor(color_provider, state, extra_params));
   canvas->drawIRect(gfx::RectToSkIRect(fill_rect), fill_flags);
 }
 
-void NativeThemeAura::PaintScrollbarTrack(
-    cc::PaintCanvas* canvas,
-    const ColorProvider* color_provider,
-    Part part,
+gfx::Insets NativeThemeAura::GetScrollbarSolidColorThumbInsets(
+    Part part) const {
+  if (use_overlay_scrollbar()) {
+    return gfx::Insets();
+  }
+  // If there are no scroll buttons then provide some inset so that the thumb
+  // doesn't touch the top of the track.
+  static constexpr int kThumbInset = 2;
+  const int extra_inset = scrollbar_button_length() == 0 ? kThumbInset : 0;
+  if (part == NativeTheme::kScrollbarVerticalThumb) {
+    return gfx::Insets::VH(extra_inset, kThumbInset);
+  }
+  CHECK_EQ(part, NativeTheme::kScrollbarHorizontalThumb);
+  return gfx::Insets::VH(kThumbInset, extra_inset);
+}
+
+SkColor NativeThemeAura::GetScrollbarThumbColor(
+    const ui::ColorProvider& color_provider,
     State state,
-    const ScrollbarTrackExtraParams& extra_params,
-    const gfx::Rect& rect,
-    bool forced_colors,
-    PreferredContrast contrast) const {
+    const ScrollbarThumbExtraParams& extra_params) const {
+  // Only non-overlay aura scrollbars use solid color thumb.
   CHECK(!use_overlay_scrollbar());
-
-  cc::PaintFlags flags;
-  flags.setColor(extra_params.track_color.value_or(
-      GetControlColor(kScrollbarTrack, {}, {}, color_provider)));
-  canvas->drawIRect(gfx::RectToSkIRect(rect), flags);
+  if (extra_params.thumb_color.has_value()) {
+    return GetContrastingPressedOrHoveredColor(
+               extra_params.thumb_color, extra_params.track_color, state,
+               /*part=*/Part::kScrollbarVerticalThumb)
+        .value();
+  }
+  ColorId color_id = kColorWebNativeControlScrollbarThumb;
+  if (state == NativeTheme::kHovered) {
+    color_id = kColorWebNativeControlScrollbarThumbHovered;
+  } else if (state == NativeTheme::kPressed) {
+    color_id = kColorWebNativeControlScrollbarThumbPressed;
+  }
+  return color_provider.GetColor(color_id);
 }
 
 void NativeThemeAura::PaintScrollbarCorner(
@@ -274,12 +329,87 @@ void NativeThemeAura::PaintScrollbarCorner(
     State state,
     const gfx::Rect& rect,
     const ScrollbarTrackExtraParams& extra_params) const {
-  CHECK(!use_overlay_scrollbar());
+  // Overlay Scrollbar should never paint a scrollbar corner.
+  DCHECK(!use_overlay_scrollbar());
+  const SkColor default_corner_color =
+      GetControlColor(kScrollbarCornerControlColorId, {}, color_provider);
 
   cc::PaintFlags flags;
-  flags.setColor(extra_params.track_color.value_or(
-      GetControlColor(kScrollbarCornerControlColorId, {}, {}, color_provider)));
+  flags.setColor(extra_params.track_color.value_or(default_corner_color));
   canvas->drawIRect(RectToSkIRect(rect), flags);
 }
 
+gfx::Size NativeThemeAura::GetPartSize(Part part,
+                                       State state,
+                                       const ExtraParams& extra) const {
+  if (use_overlay_scrollbar()) {
+    constexpr int minimum_length =
+        kOverlayScrollbarMinimumLength + 2 * kOverlayScrollbarStrokeWidth;
+
+    // Aura overlay scrollbars need a slight tweak from the base sizes.
+    switch (part) {
+      case kScrollbarHorizontalThumb:
+        return gfx::Size(minimum_length, scrollbar_width_);
+      case kScrollbarVerticalThumb:
+        return gfx::Size(scrollbar_width_, minimum_length);
+
+      default:
+        // TODO(bokan): We should probably make sure code using overlay
+        // scrollbars isn't asking for part sizes that don't exist.
+        // crbug.com/657159.
+        break;
+    }
+  }
+
+  return NativeThemeBase::GetPartSize(part, state, extra);
+}
+
+float NativeThemeAura::GetContrastRatioForState(State state, Part part) const {
+  CHECK(SupportedPartsForContrastingColor(part));
+  // Calculated by taking the contrast ratio for the base colors of the thumb.
+  static constexpr float kScrollbarThumbHoveredContrastRatio = 1.3f;
+  static constexpr float kScrollbarThumbPressedContrastRatio = 1.8f;
+  return state == kPressed ? kScrollbarThumbPressedContrastRatio
+                           : kScrollbarThumbHoveredContrastRatio;
+}
+
+void NativeThemeAura::DrawPartiallyRoundRect(cc::PaintCanvas* canvas,
+                                             const gfx::Rect& rect,
+                                             const SkScalar upper_left_radius,
+                                             const SkScalar upper_right_radius,
+                                             const SkScalar lower_right_radius,
+                                             const SkScalar lower_left_radius,
+                                             const cc::PaintFlags& flags) {
+  gfx::RRectF rounded_rect(
+      gfx::RectF(rect), upper_left_radius, upper_left_radius,
+      upper_right_radius, upper_right_radius, lower_right_radius,
+      lower_right_radius, lower_left_radius, lower_left_radius);
+
+  canvas->drawRRect(static_cast<SkRRect>(rounded_rect), flags);
+}
+
+bool NativeThemeAura::SupportsNinePatch(Part part) const {
+  if (!use_overlay_scrollbar()) {
+    return false;
+  }
+
+  return part == kScrollbarHorizontalThumb || part == kScrollbarVerticalThumb;
+}
+
+gfx::Size NativeThemeAura::GetNinePatchCanvasSize(Part part) const {
+  DCHECK(SupportsNinePatch(part));
+
+  return gfx::Size(
+      kOverlayScrollbarBorderPatchWidth * 2 + kOverlayScrollbarCenterPatchSize,
+      kOverlayScrollbarBorderPatchWidth * 2 + kOverlayScrollbarCenterPatchSize);
+}
+
+gfx::Rect NativeThemeAura::GetNinePatchAperture(Part part) const {
+  DCHECK(SupportsNinePatch(part));
+
+  return gfx::Rect(
+      kOverlayScrollbarBorderPatchWidth, kOverlayScrollbarBorderPatchWidth,
+      kOverlayScrollbarCenterPatchSize, kOverlayScrollbarCenterPatchSize);
+}
+
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_aura.h b/ui/native_theme/native_theme_aura.h
index 20b6e2d97bb6e..34a4519db176e 100644
--- a/ui/native_theme/native_theme_aura.h
+++ b/ui/native_theme/native_theme_aura.h
@@ -13,50 +13,35 @@ namespace ui {
 
 // Aura implementation of native theme support.
 class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeAura : public NativeThemeBase {
- public:
-  NativeThemeAura(const NativeThemeAura&) = delete;
-  NativeThemeAura& operator=(const NativeThemeAura&) = delete;
-
-  // NativeThemeBase:
-  gfx::Insets GetScrollbarSolidColorThumbInsets(Part part) const override;
-  bool SupportsNinePatch(Part part) const override;
-  gfx::Size GetNinePatchCanvasSize(Part part) const override;
-  gfx::Rect GetNinePatchAperture(Part part) const override;
-
  protected:
+  friend class NativeTheme;
+  friend class NativeThemeAuraTest;
+  friend class base::NoDestructor<NativeThemeAura>;
+
   explicit NativeThemeAura(bool use_overlay_scrollbar = false);
   explicit NativeThemeAura(SystemTheme system_theme);
+
+  NativeThemeAura(const NativeThemeAura&) = delete;
+  NativeThemeAura& operator=(const NativeThemeAura&) = delete;
+
   ~NativeThemeAura() override;
 
   // NativeThemeBase:
-  gfx::Size GetVerticalScrollbarButtonSize() const override;
-  gfx::Size GetVerticalScrollbarThumbSize() const override;
-  std::optional<ColorId> GetScrollbarThumbColorId(
-      State state,
-      const ScrollbarThumbExtraParams& extra_params) const override;
-  float GetScrollbarPartContrastRatioForState(State state) const override;
   void PaintMenuPopupBackground(
       cc::PaintCanvas* canvas,
       const ColorProvider* color_provider,
       const gfx::Size& size,
-      const MenuBackgroundExtraParams& extra_params) const override;
+      const MenuBackgroundExtraParams& menu_background) const override;
   void PaintArrowButton(
       cc::PaintCanvas* gc,
       const ColorProvider* color_provider,
       const gfx::Rect& rect,
-      Part part,
+      Part direction,
       State state,
       bool forced_colors,
       bool dark_mode,
       PreferredContrast contrast,
       const ScrollbarArrowExtraParams& extra_params) const override;
-  void PaintScrollbarThumb(
-      cc::PaintCanvas* canvas,
-      const ColorProvider* color_provider,
-      Part part,
-      State state,
-      const gfx::Rect& rect,
-      const ScrollbarThumbExtraParams& extra_params) const override;
   void PaintScrollbarTrack(cc::PaintCanvas* canvas,
                            const ColorProvider* color_provider,
                            Part part,
@@ -65,15 +50,40 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeAura : public NativeThemeBase {
                            const gfx::Rect& rect,
                            bool forced_colors,
                            PreferredContrast contrast) const override;
+  void PaintScrollbarThumb(
+      cc::PaintCanvas* canvas,
+      const ColorProvider* color_provider,
+      Part part,
+      State state,
+      const gfx::Rect& rect,
+      const ScrollbarThumbExtraParams& extra_params) const override;
+  gfx::Insets GetScrollbarSolidColorThumbInsets(Part part) const override;
+  SkColor GetScrollbarThumbColor(
+      const ui::ColorProvider& color_provider,
+      State state,
+      const ScrollbarThumbExtraParams& extra) const override;
   void PaintScrollbarCorner(
       cc::PaintCanvas* canvas,
       const ColorProvider* color_provider,
       State state,
       const gfx::Rect& rect,
       const ScrollbarTrackExtraParams& extra_params) const override;
+  gfx::Size GetPartSize(Part part,
+                        State state,
+                        const ExtraParams& extra) const override;
+  float GetContrastRatioForState(State state, Part part) const override;
+  bool SupportsNinePatch(Part part) const override;
+  gfx::Size GetNinePatchCanvasSize(Part part) const override;
+  gfx::Rect GetNinePatchAperture(Part part) const override;
 
  private:
-  friend class base::NoDestructor<NativeThemeAura>;
+  static void DrawPartiallyRoundRect(cc::PaintCanvas* canvas,
+                                     const gfx::Rect& rect,
+                                     const SkScalar upper_left_radius,
+                                     const SkScalar upper_right_radius,
+                                     const SkScalar lower_right_radius,
+                                     const SkScalar lower_left_radius,
+                                     const cc::PaintFlags& flags);
 };
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_aura_unittest.cc b/ui/native_theme/native_theme_aura_unittest.cc
new file mode 100644
index 0000000000000..1f5a9d73dbedb
--- /dev/null
+++ b/ui/native_theme/native_theme_aura_unittest.cc
@@ -0,0 +1,145 @@
+// Copyright 2016 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/native_theme/native_theme_aura.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/skia/include/core/SkPath.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/native_theme/native_theme.h"
+
+namespace ui {
+namespace {
+
+void VerifyPoint(SkPoint a, SkPoint b) {
+  EXPECT_EQ(a.x(), b.x());
+  EXPECT_EQ(a.y(), b.y());
+}
+
+void VerifyTriangle(SkPath actualPath, SkPoint p0, SkPoint p1, SkPoint p2) {
+  EXPECT_EQ(3, actualPath.countPoints());
+  VerifyPoint(p0, actualPath.getPoint(0));
+  VerifyPoint(p1, actualPath.getPoint(1));
+  VerifyPoint(p2, actualPath.getPoint(2));
+}
+
+}  // namespace
+
+class NativeThemeAuraTest : public testing::Test {
+ protected:
+  NativeThemeAuraTest() = default;
+
+  SkPath PathForArrow(const gfx::Rect& rect,
+                      NativeTheme::Part direction) const {
+    return theme_.PathForArrow(BoundingRectForArrow(rect), direction);
+  }
+
+  gfx::Rect BoundingRectForArrow(const gfx::Rect& rect) const {
+    return theme_.BoundingRectForArrow(rect);
+  }
+
+ private:
+  NativeThemeAura theme_;
+};
+
+TEST_F(NativeThemeAuraTest, VerticalArrows) {
+  SkPath path;
+
+  // Up arrow, sized for 1x.
+  path =
+      PathForArrow(gfx::Rect(100, 200, 17, 17), NativeTheme::kScrollbarUpArrow);
+  VerifyTriangle(path, SkPoint::Make(105, 211), SkPoint::Make(112, 211),
+                 SkPoint::Make(108.5, 207));
+
+  // 1.25x, should be larger.
+  path =
+      PathForArrow(gfx::Rect(50, 70, 21, 21), NativeTheme::kScrollbarUpArrow);
+  VerifyTriangle(path, SkPoint::Make(56, 84), SkPoint::Make(65, 84),
+                 SkPoint::Make(60.5, 79));
+
+  // Down arrow is just a flipped up arrow.
+  path =
+      PathForArrow(gfx::Rect(20, 80, 17, 17), NativeTheme::kScrollbarDownArrow);
+  VerifyTriangle(path, SkPoint::Make(25, 86), SkPoint::Make(32, 86),
+                 SkPoint::Make(28.5, 90));
+}
+
+TEST_F(NativeThemeAuraTest, HorizontalArrows) {
+  SkPath path;
+
+  // Right arrow, sized for 1x.
+  path = PathForArrow(gfx::Rect(100, 200, 17, 17),
+                      NativeTheme::kScrollbarRightArrow);
+  VerifyTriangle(path, SkPoint::Make(107, 205), SkPoint::Make(107, 212),
+                 SkPoint::Make(111, 208.5));
+
+  // Button size for 1.25x, should be larger.
+  path = PathForArrow(gfx::Rect(50, 70, 21, 21),
+                      NativeTheme::kScrollbarRightArrow);
+  VerifyTriangle(path, SkPoint::Make(58, 76), SkPoint::Make(58, 85),
+                 SkPoint::Make(63, 80.5));
+
+  // Left arrow is just a flipped right arrow.
+  path =
+      PathForArrow(gfx::Rect(20, 80, 17, 17), NativeTheme::kScrollbarLeftArrow);
+  VerifyTriangle(path, SkPoint::Make(30, 85), SkPoint::Make(30, 92),
+                 SkPoint::Make(26, 88.5));
+}
+
+TEST_F(NativeThemeAuraTest, ArrowForNonSquareButton) {
+  SkPath path =
+      PathForArrow(gfx::Rect(90, 80, 42, 37), NativeTheme::kScrollbarLeftArrow);
+  VerifyTriangle(path, SkPoint::Make(116, 89), SkPoint::Make(116, 109),
+                 SkPoint::Make(105, 99));
+}
+
+TEST_F(NativeThemeAuraTest, BoundingRectSquare) {
+  gfx::Rect bounding_rect = BoundingRectForArrow(gfx::Rect(42, 61, 21, 21));
+  EXPECT_EQ(48.f, bounding_rect.x());
+  EXPECT_EQ(67.f, bounding_rect.y());
+  EXPECT_EQ(9.f, bounding_rect.width());
+  EXPECT_EQ(bounding_rect.width(), bounding_rect.height());
+}
+
+TEST_F(NativeThemeAuraTest, BoundingRectSlightlyRectangular) {
+  // Stretched horzontally.
+  gfx::Rect bounding_rect = BoundingRectForArrow(gfx::Rect(42, 61, 25, 20));
+  EXPECT_EQ(49.f, bounding_rect.x());
+  EXPECT_EQ(66.f, bounding_rect.y());
+  EXPECT_EQ(11.f, bounding_rect.width());
+  EXPECT_EQ(bounding_rect.width(), bounding_rect.height());
+
+  // Stretched vertically.
+  bounding_rect = BoundingRectForArrow(gfx::Rect(42, 61, 14, 10));
+  EXPECT_EQ(46.f, bounding_rect.x());
+  EXPECT_EQ(63.f, bounding_rect.y());
+  EXPECT_EQ(6.f, bounding_rect.width());
+  EXPECT_EQ(bounding_rect.width(), bounding_rect.height());
+}
+
+TEST_F(NativeThemeAuraTest, BoundingRectVeryRectangular) {
+  // Stretched horzontally.
+  gfx::Rect bounding_rect = BoundingRectForArrow(gfx::Rect(42, 61, 30, 8));
+  EXPECT_EQ(53.f, bounding_rect.x());
+  EXPECT_EQ(61.f, bounding_rect.y());
+  EXPECT_EQ(8.f, bounding_rect.width());
+  EXPECT_EQ(bounding_rect.width(), bounding_rect.height());
+
+  // Stretched vertically.
+  bounding_rect = BoundingRectForArrow(gfx::Rect(42, 61, 6, 44));
+  EXPECT_EQ(42.f, bounding_rect.x());
+  EXPECT_EQ(80.f, bounding_rect.y());
+  EXPECT_EQ(6.f, bounding_rect.width());
+  EXPECT_EQ(bounding_rect.width(), bounding_rect.height());
+}
+
+TEST_F(NativeThemeAuraTest, BoundingRectSnappedToWholePixels) {
+  gfx::Rect bounding_rect = BoundingRectForArrow(gfx::Rect(0, 0, 9, 10));
+  EXPECT_EQ(3.f, bounding_rect.x());
+
+  bounding_rect = BoundingRectForArrow(gfx::Rect(0, 0, 10, 9));
+  EXPECT_EQ(3.f, bounding_rect.y());
+}
+
+}  // namespace ui
diff --git a/ui/native_theme/native_theme_base.cc b/ui/native_theme/native_theme_base.cc
index b7b7b25b7ab46..81a9320acd2e1 100644
--- a/ui/native_theme/native_theme_base.cc
+++ b/ui/native_theme/native_theme_base.cc
@@ -5,12 +5,12 @@
 #include "ui/native_theme/native_theme_base.h"
 
 #include <algorithm>
-#include <array>
 #include <optional>
 #include <utility>
 #include <variant>
 
 #include "base/check.h"
+#include "base/compiler_specific.h"
 #include "base/containers/fixed_flat_map.h"
 #include "base/containers/span.h"
 #include "base/notimplemented.h"
@@ -28,13 +28,13 @@
 #include "ui/color/color_id.h"
 #include "ui/color/color_provider.h"
 #include "ui/gfx/canvas.h"
+#include "ui/gfx/color_palette.h"
 #include "ui/gfx/color_utils.h"
 #include "ui/gfx/geometry/point_f.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/rect_f.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/geometry/skia_conversions.h"
-#include "ui/gfx/scoped_canvas.h"
 #include "ui/native_theme/features/native_theme_features.h"
 #include "ui/native_theme/native_theme.h"
 
@@ -42,370 +42,437 @@ namespace ui {
 
 namespace {
 
-static constexpr gfx::Size kCheckboxSize(13, 13);
-static constexpr int kSliderTrackThickness = 8;
-static constexpr int kSliderThumbThickness = 16;
-static constexpr float kBorderWidth = 1.0f;
-
-SkRect AlignSliderTrack(const gfx::Rect& slider_rect,
-                        const NativeTheme::SliderExtraParams& extra_params,
-                        bool is_value,
-                        float thickness) {
-  const gfx::RectF r(slider_rect);
-  const gfx::PointF center = r.CenterPoint();
-  const float half_track_thickness = thickness / 2;
-
-  if (extra_params.vertical) {
-    float top = r.y();
-    float bottom = r.bottom();
-    if (is_value) {
-      // Extend to ensure the thumb completely covers the end of the value rect.
-      // Because the thumb radius is greater than `half_track_thickness`,
-      // extending that much is guaranteed to be sufficient.
-      (extra_params.right_to_left ? top : bottom) =
-          top + extra_params.thumb_y + half_track_thickness;
-    }
-    return SkRect::MakeLTRB(
-        std::max(r.x(), center.x() - half_track_thickness), top,
-        std::min(r.right(), center.x() + half_track_thickness), bottom);
-  }
+// These are the default dimensions of radio buttons and checkboxes.
+const int kCheckboxAndRadioWidth = 13;
+const int kCheckboxAndRadioHeight = 13;
+
+// Color constant pairs for light/default and dark color-schemes below.
+constexpr SkColor kTrackColor[2] = {SkColorSetRGB(0xD3, 0xD3, 0xD3),
+                                    gfx::kPlaceholderColor};
+constexpr SkColor kArrowDisabledColor[2] = {SK_ColorBLACK, SK_ColorWHITE};
+
+// The "dash" is 8x2 px by default (the checkbox is 13x13 px).
+const SkScalar kIndeterminateInsetWidthRatio = (13 - 8) / 2.0f / 13;
+const SkScalar kIndeterminateInsetHeightRatio = (13 - 2) / 2.0f / 13;
+const SkScalar kBorderWidth = 1.f;
+const SkScalar kSliderTrackHeight = 8.f;
+const SkScalar kSliderThumbBorderWidth = 1.f;
+const SkScalar kSliderThumbBorderHoveredWidth = 1.f;
+// Default block size for progress is 16px and the track is 8px.
+const SkScalar kTrackBlockRatio = 8.0f / 16;
+const SkScalar kMenuListArrowStrokeWidth = 2.f;
+const int kSliderThumbSize = 16;
+
+// This value was created with the following steps:
+// 1. Take the SkColors returned by GetControlColor for kAccent and
+//    kHoveredAccent.
+// 2. use color_utils::SkColorToHSL to convert those colors to HSL.
+// 3. Take the difference of the luminance component of the HSL between those
+//    two colors.
+// 4. Round to the nearest two decimal points.
+//
+// This is used to emulate the changes in color used for hover and pressed
+// states when a custom accent-color is used to draw form controls. It just so
+// happens that the luminance difference is the same for hover and press, and it
+// also happens that GetDarkModeControlColor has very close values when you run
+// these steps, which makes it work well for forced color-scheme for contrast
+// with certain accent-colors.
+const double kAccentLuminanceAdjust = 0.11;
+
+// Get a color constant based on color-scheme
+// TODO(crbug.com/40242489): Move colors defined above to the color pipeline and
+// remove this function.
+SkColor GetColor(base::span<const SkColor, 2> colors, bool dark_mode) {
+  return colors[dark_mode ? 1 : 0];
+}
+
+SkColor AdjustLuminance(const SkColor& color, double luminance) {
+  color_utils::HSL hsl;
+  color_utils::SkColorToHSL(color, &hsl);
+  hsl.l = std::clamp(hsl.l + luminance, 0., 1.);
+  return color_utils::HSLToSkColor(hsl, SkColorGetA(color));
+}
 
-  float left = r.x();
-  float right = r.right();
-  if (is_value) {
-    (extra_params.right_to_left ? left : right) =
-        left + extra_params.thumb_x + half_track_thickness;
+SkColor CustomAccentColorForState(const SkColor& accent_color,
+                                  ui::NativeTheme::State state,
+                                  bool dark_mode) {
+  bool make_lighter = false;
+  switch (state) {
+    case ui::NativeTheme::kHovered:
+      make_lighter = dark_mode;
+      break;
+    case ui::NativeTheme::kPressed:
+      make_lighter = !dark_mode;
+      break;
+    default:
+      return accent_color;
   }
-  return SkRect::MakeLTRB(
-      left, std::max(r.y(), center.y() - half_track_thickness), right,
-      std::min(r.bottom(), center.y() + half_track_thickness));
+  return AdjustLuminance(accent_color,
+                         (make_lighter ? 1 : -1) * kAccentLuminanceAdjust);
 }
 
 }  // namespace
 
 gfx::Size NativeThemeBase::GetPartSize(Part part,
                                        State state,
-                                       const ExtraParams& extra_params) const {
-  if (part == kCheckbox || part == kRadio) {
-    return kCheckboxSize;
-  }
-  if (part == kSliderThumb) {
-    return gfx::Size(kSliderThumbThickness, kSliderThumbThickness);
-  }
-  if (part != kInnerSpinButton &&
-      (part < kScrollbarDownArrow || part > kScrollbarVerticalTrack)) {
-    return gfx::Size();  // No default size.
-  }
-  gfx::Size size =
-      (part == kScrollbarHorizontalThumb || part == kScrollbarVerticalThumb)
-          ? GetVerticalScrollbarThumbSize()
-          : GetVerticalScrollbarButtonSize();
-  if (part == kInnerSpinButton || part == kScrollbarHorizontalTrack ||
-      part == kScrollbarVerticalTrack) {
-    size.set_height(0);
-  }
-  if (part == kScrollbarLeftArrow || part == kScrollbarRightArrow ||
-      part == kScrollbarHorizontalThumb || part == kScrollbarHorizontalTrack) {
-    size.Transpose();
+                                       const ExtraParams& extra) const {
+  switch (part) {
+    // Please keep these in the order of NativeTheme::Part.
+    case kCheckbox:
+      return gfx::Size(kCheckboxAndRadioWidth, kCheckboxAndRadioHeight);
+    case kInnerSpinButton:
+      return gfx::Size(scrollbar_width_, 0);
+    case kMenuList:
+      return gfx::Size();  // No default size.
+    case kMenuPopupBackground:
+      return gfx::Size();  // No default size.
+    case kMenuItemBackground:
+    case kProgressBar:
+    case kPushButton:
+      return gfx::Size();  // No default size.
+    case kRadio:
+      return gfx::Size(kCheckboxAndRadioWidth, kCheckboxAndRadioHeight);
+    case kScrollbarDownArrow:
+    case kScrollbarUpArrow:
+      return gfx::Size(scrollbar_width_, scrollbar_button_length_);
+    case kScrollbarLeftArrow:
+    case kScrollbarRightArrow:
+      return gfx::Size(scrollbar_button_length_, scrollbar_width_);
+    case kScrollbarHorizontalThumb:
+      // This matches Firefox on Linux.
+      return gfx::Size(2 * scrollbar_width_, scrollbar_width_);
+    case kScrollbarVerticalThumb:
+      // This matches Firefox on Linux.
+      return gfx::Size(scrollbar_width_, 2 * scrollbar_width_);
+    case kScrollbarHorizontalTrack:
+      return gfx::Size(0, scrollbar_width_);
+    case kScrollbarVerticalTrack:
+      return gfx::Size(scrollbar_width_, 0);
+    case kScrollbarHorizontalGripper:
+    case kScrollbarVerticalGripper:
+      NOTIMPLEMENTED();
+      break;
+    case kSliderTrack:
+      return gfx::Size();  // No default size.
+    case kSliderThumb:
+      // These sizes match the sizes in Chromium Win.
+      return gfx::Size(kSliderThumbSize, kSliderThumbSize);
+    case kTabPanelBackground:
+      NOTIMPLEMENTED();
+      break;
+    case kTextField:
+      return gfx::Size();  // No default size.
+    case kTrackbarThumb:
+    case kTrackbarTrack:
+    case kWindowResizeGripper:
+      NOTIMPLEMENTED();
+      break;
+    default:
+      NOTREACHED() << "Unknown theme part: " << part;
   }
-  return size;
+  return gfx::Size();
 }
 
 float NativeThemeBase::GetBorderRadiusForPart(Part part,
                                               float width,
                                               float height) const {
-  if (part == kCheckbox || part == kPushButton || part == kTextField) {
-    return 2.0f;
-  }
-  if (part == kProgressBar || part == kSliderTrack) {
-    // In the common case, the thickness is small enough that this has the same
-    // effect as the radio/slider thumb code below.
-    return 40.0f;
+  switch (part) {
+    case kCheckbox:
+      return 2.f;
+    case kPushButton:
+    case kTextField:
+      return 2.f;
+    case kRadio:
+      return std::max(width, height) * 0.5;
+    case kProgressBar:
+    case kSliderTrack:
+      // default border radius for progress and range is 40px.
+      return 40.f;
+    case kSliderThumb:
+      return std::max(width, height) * 0.5;
+    default:
+      break;
   }
-  return (part == kRadio || part == kSliderThumb)
-             ? (std::max(width, height) * 0.5f)
-             : 0;
+  return 0;
 }
 
-SkColor NativeThemeBase::GetScrollbarThumbColor(
-    const ColorProvider* color_provider,
-    State state,
-    const ScrollbarThumbExtraParams& extra_params) const {
-  const SkColor bg_color =
-      GetContrastingColorForScrollbarPart(extra_params.track_color,
-                                          std::nullopt, state)
-          .value_or(GetControlColor(kScrollbarTrack, {}, {}, color_provider));
-  if (const std::optional<SkColor> color = GetContrastingColorForScrollbarPart(
-          extra_params.thumb_color, bg_color, state)) {
-    return color.value();
-  }
-  if (const std::optional<ColorId> id =
-          GetScrollbarThumbColorId(state, extra_params)) {
-    return color_provider->GetColor(id.value());
+void NativeThemeBase::Paint(cc::PaintCanvas* canvas,
+                            const ui::ColorProvider* color_provider,
+                            Part part,
+                            State state,
+                            const gfx::Rect& rect,
+                            const ExtraParams& extra,
+                            bool forced_colors,
+                            PreferredColorScheme color_scheme,
+                            PreferredContrast contrast,
+                            const std::optional<SkColor>& accent_color) const {
+  if (rect.IsEmpty()) {
+    return;
   }
-  static constexpr auto kScrollbarThumbColors =
-      std::to_array({kScrollbarThumb, kScrollbarThumbHovered, kScrollbarThumb,
-                     kScrollbarThumbPressed});
-  return GetControlColorForState(kScrollbarThumbColors, state, {}, {},
-                                 color_provider);
-}
 
-NativeThemeBase::~NativeThemeBase() = default;
+  // For `color_scheme`, `kNoPreference` means "use current".
+  const bool dark_mode =
+      color_scheme == PreferredColorScheme::kDark ||
+      (color_scheme == PreferredColorScheme::kNoPreference &&
+       preferred_color_scheme() == PreferredColorScheme::kDark);
+
+  canvas->save();
+  canvas->clipRect(gfx::RectToSkRect(rect));
+
+  // Form control accents shouldn't be drawn with any transparency.
+  std::optional<SkColor> accent_color_opaque;
+  if (accent_color) {
+    accent_color_opaque = SkColorSetA(accent_color.value(), SK_AlphaOPAQUE);
+  }
 
-void NativeThemeBase::PaintImpl(cc::PaintCanvas* canvas,
-                                const ColorProvider* color_provider,
-                                Part part,
-                                State state,
-                                const gfx::Rect& rect,
-                                const ExtraParams& extra_params,
-                                bool forced_colors,
-                                bool dark_mode,
-                                PreferredContrast contrast,
-                                std::optional<SkColor> accent_color) const {
   switch (part) {
+    // Please keep these in the order of NativeTheme::Part.
     case kCheckbox:
       PaintCheckbox(canvas, color_provider, state, rect,
-                    std::get<ButtonExtraParams>(extra_params), dark_mode,
-                    contrast, accent_color);
+                    std::get<ButtonExtraParams>(extra), dark_mode,
+                    accent_color_opaque);
       break;
 #if BUILDFLAG(IS_LINUX)
     case kFrameTopArea:
       PaintFrameTopArea(canvas, state, rect,
-                        std::get<FrameTopAreaExtraParams>(extra_params));
+                        std::get<FrameTopAreaExtraParams>(extra));
       break;
 #endif
     case kInnerSpinButton:
       PaintInnerSpinButton(canvas, color_provider, state, rect,
-                           std::get<InnerSpinButtonExtraParams>(extra_params),
+                           std::get<InnerSpinButtonExtraParams>(extra),
                            forced_colors, dark_mode, contrast);
       break;
     case kMenuList:
       PaintMenuList(canvas, color_provider, state, rect,
-                    std::get<MenuListExtraParams>(extra_params), dark_mode,
-                    contrast);
+                    std::get<MenuListExtraParams>(extra), dark_mode);
       break;
     case kMenuPopupBackground:
-      PaintMenuPopupBackground(
-          canvas, color_provider, rect.size(),
-          std::get<MenuBackgroundExtraParams>(extra_params));
+      PaintMenuPopupBackground(canvas, color_provider, rect.size(),
+                               std::get<MenuBackgroundExtraParams>(extra));
       break;
     case kMenuPopupSeparator:
       PaintMenuSeparator(canvas, color_provider, state, rect,
-                         std::get<MenuSeparatorExtraParams>(extra_params));
+                         std::get<MenuSeparatorExtraParams>(extra));
       break;
     case kMenuItemBackground:
       PaintMenuItemBackground(canvas, color_provider, state, rect,
-                              std::get<MenuItemExtraParams>(extra_params));
+                              std::get<MenuItemExtraParams>(extra));
       break;
     case kProgressBar:
       PaintProgressBar(canvas, color_provider, state, rect,
-                       std::get<ProgressBarExtraParams>(extra_params),
-                       dark_mode, contrast, accent_color);
+                       std::get<ProgressBarExtraParams>(extra), dark_mode,
+                       contrast, accent_color_opaque);
       break;
     case kPushButton:
       PaintButton(canvas, color_provider, state, rect,
-                  std::get<ButtonExtraParams>(extra_params), dark_mode,
-                  contrast);
+                  std::get<ButtonExtraParams>(extra), dark_mode);
       break;
     case kRadio:
       PaintRadio(canvas, color_provider, state, rect,
-                 std::get<ButtonExtraParams>(extra_params), dark_mode, contrast,
-                 accent_color);
+                 std::get<ButtonExtraParams>(extra), dark_mode,
+                 accent_color_opaque);
       break;
     case kScrollbarDownArrow:
     case kScrollbarUpArrow:
     case kScrollbarLeftArrow:
     case kScrollbarRightArrow:
-      if (!GetVerticalScrollbarButtonSize().IsEmpty()) {
+      if (scrollbar_button_length_ > 0) {
         PaintArrowButton(canvas, color_provider, rect, part, state,
                          forced_colors, dark_mode, contrast,
-                         std::get<ScrollbarArrowExtraParams>(extra_params));
+                         std::get<ScrollbarArrowExtraParams>(extra));
       }
       break;
     case kScrollbarHorizontalThumb:
     case kScrollbarVerticalThumb:
       PaintScrollbarThumb(canvas, color_provider, part, state, rect,
-                          std::get<ScrollbarThumbExtraParams>(extra_params));
+                          std::get<ScrollbarThumbExtraParams>(extra));
       break;
     case kScrollbarHorizontalTrack:
     case kScrollbarVerticalTrack:
       PaintScrollbarTrack(canvas, color_provider, part, state,
-                          std::get<ScrollbarTrackExtraParams>(extra_params),
-                          rect, forced_colors, contrast);
+                          std::get<ScrollbarTrackExtraParams>(extra), rect,
+                          forced_colors, contrast);
       break;
     case kScrollbarHorizontalGripper:
     case kScrollbarVerticalGripper:
-      // Paints nothing in this or any subclass.
+      // Invoked by views scrollbar code, don't care about for non-win
+      // implementations, so no NOTIMPLEMENTED.
       break;
     case kScrollbarCorner:
       PaintScrollbarCorner(canvas, color_provider, state, rect,
-                           std::get<ScrollbarTrackExtraParams>(extra_params));
+                           std::get<ScrollbarTrackExtraParams>(extra));
       break;
     case kSliderTrack:
       PaintSliderTrack(canvas, color_provider, state, rect,
-                       std::get<SliderExtraParams>(extra_params), dark_mode,
-                       contrast, accent_color);
+                       std::get<SliderExtraParams>(extra), dark_mode, contrast,
+                       accent_color_opaque);
       break;
     case kSliderThumb:
       PaintSliderThumb(canvas, color_provider, state, rect,
-                       std::get<SliderExtraParams>(extra_params), dark_mode,
-                       contrast, accent_color);
+                       std::get<SliderExtraParams>(extra), dark_mode,
+                       accent_color_opaque);
+      break;
+    case kTabPanelBackground:
+      NOTIMPLEMENTED();
       break;
     case kTextField:
       PaintTextField(canvas, color_provider, state, rect,
-                     std::get<TextFieldExtraParams>(extra_params), dark_mode,
-                     contrast);
+                     std::get<TextFieldExtraParams>(extra), dark_mode);
       break;
-    case kTabPanelBackground:
     case kTrackbarThumb:
     case kTrackbarTrack:
     case kWindowResizeGripper:
       NOTIMPLEMENTED();
       break;
     default:
-      NOTREACHED();
+      NOTREACHED() << "Unknown theme part: " << part;
   }
+
+  canvas->restore();
 }
 
-gfx::Size NativeThemeBase::GetVerticalScrollbarButtonSize() const {
-  return gfx::Size(15, 14);
+bool NativeThemeBase::SupportsNinePatch(Part part) const {
+  return false;
 }
 
-gfx::Size NativeThemeBase::GetVerticalScrollbarThumbSize() const {
-  const int thickness = GetVerticalScrollbarButtonSize().width();
-  return gfx::Size(thickness, thickness * 2);
+gfx::Size NativeThemeBase::GetNinePatchCanvasSize(Part part) const {
+  NOTREACHED() << "NativeThemeBase doesn't support nine-patch resources.";
 }
 
-gfx::RectF NativeThemeBase::GetArrowRect(const gfx::Rect& rect,
-                                         Part part,
-                                         State state) const {
-  // Note: Using initializer_list form forces returning by copy, not ref.
-  const auto [min_side, max_side] = std::minmax({rect.width(), rect.height()});
-  const int side_length_inset = (max_side + 3) / 4;
-  const int side_length = std::min(min_side, max_side - side_length_inset * 2);
-  // When there are an odd number of pixels, put the extra on the top/left.
-  return gfx::RectF(gfx::Rect(rect.x() + (rect.width() - side_length + 1) / 2,
-                              rect.y() + (rect.height() - side_length + 1) / 2,
-                              side_length, side_length));
+gfx::Rect NativeThemeBase::GetNinePatchAperture(Part part) const {
+  NOTREACHED() << "NativeThemeBase doesn't support nine-patch resources.";
 }
 
-SkColor NativeThemeBase::GetControlColor(
-    ControlColorId color_id,
+NativeThemeBase::~NativeThemeBase() = default;
+
+void NativeThemeBase::PaintArrowButton(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
+    const gfx::Rect& rect,
+    Part direction,
+    State state,
+    bool forced_colors,
     bool dark_mode,
     PreferredContrast contrast,
-    const ColorProvider* color_provider) const {
-  static constexpr auto kColorMap = base::MakeFixedFlatMap<ControlColorId,
-                                                           ColorId>(
-      {{kBorder, kColorWebNativeControlBorder},
-       {kDisabledBorder, kColorWebNativeControlBorderDisabled},
-       {kHoveredBorder, kColorWebNativeControlBorderHovered},
-       {kPressedBorder, kColorWebNativeControlBorderPressed},
-       {kAccent, kColorWebNativeControlAccent},
-       {kDisabledAccent, kColorWebNativeControlAccentDisabled},
-       {kHoveredAccent, kColorWebNativeControlAccentHovered},
-       {kPressedAccent, kColorWebNativeControlAccentPressed},
-       {kCheckboxBackground, kColorWebNativeControlCheckboxBackground},
-       {kDisabledCheckboxBackground,
-        kColorWebNativeControlCheckboxBackgroundDisabled},
-       {kFill, kColorWebNativeControlFill},
-       {kDisabledFill, kColorWebNativeControlFillDisabled},
-       {kHoveredFill, kColorWebNativeControlFillHovered},
-       {kPressedFill, kColorWebNativeControlFillPressed},
-       {kLightenLayer, kColorWebNativeControlLightenLayer},
-       {kProgressValue, kColorWebNativeControlProgressValue},
-       {kSlider, kColorWebNativeControlSlider},
-       {kDisabledSlider, kColorWebNativeControlSliderDisabled},
-       {kHoveredSlider, kColorWebNativeControlSliderHovered},
-       {kPressedSlider, kColorWebNativeControlSliderPressed},
-       {kSliderBorder, kColorWebNativeControlSliderBorder},
-       {kHoveredSliderBorder, kColorWebNativeControlSliderBorderHovered},
-       {kPressedSliderBorder, kColorWebNativeControlSliderBorderPressed},
-       {kAutoCompleteBackground, kColorWebNativeControlAutoCompleteBackground},
-       {kScrollbarArrowBackground, kColorWebNativeControlScrollbarTrack},
-       {kScrollbarArrowBackgroundDisabled,
-        kColorWebNativeControlScrollbarArrowBackgroundDisabled},
-       {kScrollbarArrowBackgroundHovered,
-        kColorWebNativeControlScrollbarArrowBackgroundHovered},
-       {kScrollbarArrowBackgroundPressed,
-        kColorWebNativeControlScrollbarArrowBackgroundPressed},
-       {kScrollbarArrow, kColorWebNativeControlScrollbarArrowForeground},
-       {kScrollbarArrowDisabled,
-        kColorWebNativeControlScrollbarArrowForegroundDisabled},
-       {kScrollbarArrowHovered, kColorWebNativeControlScrollbarArrowForeground},
-       {kScrollbarArrowPressed,
-        kColorWebNativeControlScrollbarArrowForegroundPressed},
-       {kScrollbarCornerControlColorId, kColorWebNativeControlScrollbarCorner},
-       {kScrollbarTrack, kColorWebNativeControlScrollbarTrack},
-       {kScrollbarThumb, kColorWebNativeControlScrollbarThumb},
-       {kScrollbarThumbHovered, kColorWebNativeControlScrollbarThumbHovered},
-       {kScrollbarThumbPressed, kColorWebNativeControlScrollbarThumbPressed},
-       {kButtonBorder, kColorWebNativeControlButtonBorder},
-       {kButtonDisabledBorder, kColorWebNativeControlButtonBorderDisabled},
-       {kButtonHoveredBorder, kColorWebNativeControlButtonBorderHovered},
-       {kButtonPressedBorder, kColorWebNativeControlButtonBorderPressed},
-       {kButtonFill, kColorWebNativeControlButtonFill},
-       {kButtonDisabledFill, kColorWebNativeControlButtonFillDisabled},
-       {kButtonHoveredFill, kColorWebNativeControlButtonFillHovered},
-       {kButtonPressedFill, kColorWebNativeControlButtonFillPressed}});
-  CHECK(color_provider);
-  return color_provider->GetColor(kColorMap.at(color_id));
+    const ScrollbarArrowExtraParams& extra_params) const {
+  NOTIMPLEMENTED();
 }
 
-std::optional<ColorId> NativeThemeBase::GetScrollbarThumbColorId(
-    State state,
-    const ScrollbarThumbExtraParams& extra_params) const {
-  return std::nullopt;
+void NativeThemeBase::PaintArrow(cc::PaintCanvas* gc,
+                                 const gfx::Rect& rect,
+                                 Part direction,
+                                 SkColor color) const {
+  cc::PaintFlags flags;
+  flags.setColor(color);
+
+  SkPath path = PathForArrow(BoundingRectForArrow(rect), direction);
+
+  gc->drawPath(path, flags);
 }
 
-float NativeThemeBase::GetScrollbarPartContrastRatioForState(
-    State state) const {
-  return 2.15f;
+SkPath NativeThemeBase::PathForArrow(const gfx::Rect& bounding_rect,
+                                     Part direction) const {
+  const gfx::PointF center = gfx::RectF(bounding_rect).CenterPoint();
+  SkPath path;
+  SkMatrix transform;
+  transform.setIdentity();
+  if (direction == kScrollbarUpArrow || direction == kScrollbarDownArrow) {
+    int arrow_altitude = bounding_rect.height() / 2 + 1;
+    path.moveTo(bounding_rect.x(), bounding_rect.bottom());
+    path.rLineTo(bounding_rect.width(), 0);
+    path.rLineTo(-bounding_rect.width() / 2.0f, -arrow_altitude);
+    path.close();
+    path.offset(0, -arrow_altitude / 2 + 1);
+    if (direction == kScrollbarDownArrow) {
+      transform.setScale(1, -1, center.x(), center.y());
+    }
+  } else {
+    int arrow_altitude = bounding_rect.width() / 2 + 1;
+    path.moveTo(bounding_rect.x(), bounding_rect.y());
+    path.rLineTo(0, bounding_rect.height());
+    path.rLineTo(arrow_altitude, -bounding_rect.height() / 2.0f);
+    path.close();
+    path.offset(arrow_altitude / 2, 0);
+    if (direction == kScrollbarLeftArrow) {
+      transform.setScale(-1, 1, center.x(), center.y());
+    }
+  }
+  path.transform(transform);
+
+  return path;
 }
 
-void NativeThemeBase::PaintFrameTopArea(
-    cc::PaintCanvas* canvas,
+std::optional<SkColor> NativeThemeBase::GetContrastingPressedOrHoveredColor(
+    std::optional<SkColor> fg_color,
+    std::optional<SkColor> bg_color,
     State state,
-    const gfx::Rect& rect,
-    const FrameTopAreaExtraParams& extra_params) const {
-  cc::PaintFlags flags;
-  flags.setColor(extra_params.default_background_color);
-  canvas->drawRect(gfx::RectToSkRect(rect), flags);
+    Part part) const {
+  CHECK(SupportedPartsForContrastingColor(part));
+  if (!fg_color.has_value() ||
+      (state != NativeTheme::kPressed && state != NativeTheme::kHovered) ||
+      SkColorGetA(fg_color.value()) == SK_AlphaTRANSPARENT) {
+    return fg_color;
+  }
+  const float contrast_ratio = GetContrastRatioForState(state, part);
+  SkColor resulting_color =
+      color_utils::BlendForMinContrast(
+          fg_color.value(), SkColorSetA(fg_color.value(), SK_AlphaOPAQUE),
+          /*high_contrast_foreground=*/std::nullopt, contrast_ratio)
+          .color;
+  if (bg_color.has_value()) {
+    // Guaranteeing contrast with the background is prioritized over having
+    // contrast with the original part color. Making a second pass with the
+    // transforming function might make the final color not contrast as much
+    // with the original color but the result is better than using a function
+    // like `PickGoogleColorTwoBackgrounds` which tries to guarantee contrast
+    // to both (original and background) colors simultaneously, and ends up
+    // creating contrast changes that are too harsh.
+    resulting_color =
+        color_utils::BlendForMinContrast(
+            resulting_color, SkColorSetA(bg_color.value(), SK_AlphaOPAQUE),
+            /*high_contrast_foreground=*/std::nullopt,
+            color_utils::kMinimumVisibleContrastRatio)
+            .color;
+  }
+  return resulting_color;
 }
 
-void NativeThemeBase::PaintMenuPopupBackground(
-    cc::PaintCanvas* canvas,
-    const ColorProvider* color_provider,
-    const gfx::Size& size,
-    const MenuBackgroundExtraParams& extra_params) const {
-  CHECK(color_provider);
-  // TODO(crbug.com/40219248): Remove FromColor and make all SkColor4f.
-  canvas->drawColor(
-      SkColor4f::FromColor(color_provider->GetColor(kColorMenuBackground)),
-      SkBlendMode::kSrc);
+float NativeThemeBase::GetContrastRatioForState(State state, Part part) const {
+  CHECK(SupportedPartsForContrastingColor(part));
+  static constexpr float kArrowContrastRatio = 2.15f;
+  return kArrowContrastRatio;
 }
 
-void NativeThemeBase::PaintMenuSeparator(
-    cc::PaintCanvas* canvas,
-    const ColorProvider* color_provider,
-    State state,
-    const gfx::Rect& rect,
-    const MenuSeparatorExtraParams& extra_params) const {
-  CHECK(color_provider);
-  cc::PaintFlags flags;
-  flags.setColor(color_provider->GetColor(extra_params.color_id));
-  canvas->drawRect(gfx::RectToSkRect(*extra_params.paint_rect), flags);
+bool NativeThemeBase::SupportedPartsForContrastingColor(Part part) const {
+  return part == Part::kScrollbarLeftArrow ||
+         part == Part::kScrollbarRightArrow ||
+         part == Part::kScrollbarUpArrow || part == Part::kScrollbarDownArrow ||
+         part == Part::kScrollbarVerticalThumb ||
+         part == Part::kScrollbarHorizontalThumb;
 }
 
-void NativeThemeBase::PaintArrowButton(
+gfx::Rect NativeThemeBase::BoundingRectForArrow(const gfx::Rect& rect) const {
+  const std::pair<int, int> rect_sides =
+      std::minmax(rect.width(), rect.height());
+  const int side_length_inset = 2 * std::ceil(rect_sides.second / 4.f);
+  const int side_length =
+      std::min(rect_sides.first, rect_sides.second - side_length_inset);
+  // When there are an odd number of pixels, put the extra on the top/left.
+  return gfx::Rect(rect.x() + (rect.width() - side_length + 1) / 2,
+                   rect.y() + (rect.height() - side_length + 1) / 2,
+                   side_length, side_length);
+}
+
+void NativeThemeBase::PaintScrollbarTrack(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
-    const gfx::Rect& rect,
     Part part,
     State state,
+    const ScrollbarTrackExtraParams& extra_params,
+    const gfx::Rect& rect,
     bool forced_colors,
-    bool dark_mode,
-    PreferredContrast contrast,
-    const ScrollbarArrowExtraParams& extra_params) const {
+    PreferredContrast contrast) const {
   NOTIMPLEMENTED();
 }
 
@@ -419,271 +486,270 @@ void NativeThemeBase::PaintScrollbarThumb(
   NOTIMPLEMENTED();
 }
 
-void NativeThemeBase::PaintScrollbarTrack(
+void NativeThemeBase::PaintScrollbarCorner(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
-    Part part,
     State state,
-    const ScrollbarTrackExtraParams& extra_params,
     const gfx::Rect& rect,
-    bool forced_colors,
-    PreferredContrast contrast) const {
+    const ScrollbarTrackExtraParams& extra_params) const {
   NOTIMPLEMENTED();
 }
 
-void NativeThemeBase::PaintScrollbarCorner(
+void NativeThemeBase::PaintCheckbox(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
     State state,
     const gfx::Rect& rect,
-    const ScrollbarTrackExtraParams& extra_params) const {
-  NOTIMPLEMENTED();
-}
-
-SkColor NativeThemeBase::GetControlColorForState(
-    base::span<const ControlColorId, 4> colors,
-    State state,
-    bool dark_mode,
-    PreferredContrast contrast,
-    const ColorProvider* color_provider) const {
-  return GetControlColor(colors[state], dark_mode, contrast, color_provider);
-}
-
-SkColor NativeThemeBase::GetScrollbarArrowBackgroundColor(
-    const ScrollbarArrowExtraParams& extra_params,
-    State state,
-    bool dark_mode,
-    PreferredContrast contrast,
-    const ColorProvider* color_provider) const {
-  static constexpr auto kScrollbarArrowBackgroundColors = std::to_array(
-      {kScrollbarArrowBackgroundDisabled, kScrollbarArrowBackgroundHovered,
-       kScrollbarArrowBackground, kScrollbarArrowBackgroundPressed});
-  return GetContrastingColorForScrollbarPart(extra_params.track_color,
-                                             std::nullopt, state)
-      .value_or(GetControlColorForState(kScrollbarArrowBackgroundColors, state,
-                                        dark_mode, contrast, color_provider));
-}
-
-SkColor NativeThemeBase::GetScrollbarArrowForegroundColor(
-    SkColor bg_color,
-    const ScrollbarArrowExtraParams& extra_params,
-    State state,
+    const ButtonExtraParams& button,
     bool dark_mode,
-    PreferredContrast contrast,
-    const ColorProvider* color_provider) const {
-  static constexpr auto kScrollbarArrowColors =
-      std::to_array({kScrollbarArrowDisabled, kScrollbarArrowHovered,
-                     kScrollbarArrow, kScrollbarArrowPressed});
-  return GetContrastingColorForScrollbarPart(extra_params.thumb_color, bg_color,
-                                             state)
-      .value_or(GetControlColorForState(kScrollbarArrowColors, state, dark_mode,
-                                        contrast, color_provider));
-}
+    const std::optional<SkColor>& accent_color) const {
+  const float border_radius =
+      GetBorderRadiusForPart(kCheckbox, rect.width(), rect.height());
 
-void NativeThemeBase::PaintLightenLayer(cc::PaintCanvas* canvas,
-                                        const ColorProvider* color_provider,
-                                        const SkRect& skrect,
-                                        State state,
-                                        float border_radius,
-                                        bool dark_mode,
-                                        PreferredContrast contrast) const {
-  if (state != kDisabled) {
-    return;
-  }
-  cc::PaintFlags flags;
-  flags.setAntiAlias(true);
-  flags.setColor(
-      GetControlColor(kLightenLayer, dark_mode, contrast, color_provider));
-  canvas->drawRoundRect(skrect, border_radius, border_radius, flags);
-}
+  SkRect skrect =
+      PaintCheckboxRadioCommon(canvas, color_provider, state, rect, button,
+                               true, border_radius, dark_mode, accent_color);
 
-void NativeThemeBase::PaintArrow(cc::PaintCanvas* canvas,
-                                 const gfx::Rect& rect,
-                                 Part part,
-                                 State state,
-                                 SkColor color) const {
-  cc::PaintFlags flags;
-  flags.setColor(color);
-  canvas->drawPath(PathForArrow(GetArrowRect(rect, part, state), part), flags);
-}
+  if (!skrect.isEmpty()) {
+    cc::PaintFlags flags;
+    flags.setAntiAlias(true);
 
-// static
-SkPath NativeThemeBase::PathForArrow(const gfx::RectF& rect, Part part) {
-  SkPath path;
-  if (part == kScrollbarUpArrow || part == kScrollbarDownArrow) {
-    // Draw up-pointing arrow.
-    const int arrow_height = base::ClampRound(rect.height()) / 2 + 1;
-    path.moveTo(rect.x(), rect.bottom() - arrow_height / 2 + 1);
-    path.rLineTo(rect.width(), 0);
-    path.rLineTo(-rect.width() / 2.0f, -arrow_height);
-  } else {
-    // Draw right-pointing arrow.
-    const int arrow_width = base::ClampRound(rect.width()) / 2 + 1;
-    path.moveTo(rect.x() + arrow_width / 2, rect.y());
-    path.rLineTo(0, rect.height());
-    path.rLineTo(arrow_width, -rect.height() / 2.0f);
-  }
-  path.close();
-
-  // Mirror the above path for down/left.
-  if (part == kScrollbarDownArrow || part == kScrollbarLeftArrow) {
-    SkMatrix transform;
-    const gfx::PointF center = rect.CenterPoint();
-    const bool vert = part == kScrollbarDownArrow;
-    transform.setScale(vert ? 1 : -1, vert ? -1 : 1, center.x(), center.y());
-    path.transform(transform);
+    if (button.indeterminate || button.checked) {
+      // Draw the accent background.
+      flags.setStyle(cc::PaintFlags::kFill_Style);
+      if (accent_color && state != kDisabled) {
+        flags.setColor(
+            CustomAccentColorForState(*accent_color, state, dark_mode));
+      } else {
+        flags.setColor(
+            ControlsAccentColorForState(state, dark_mode, color_provider));
+      }
+      canvas->drawRoundRect(skrect, border_radius, border_radius, flags);
+
+      if (button.indeterminate) {
+        // Draw the dash.
+        flags.setColor(
+            ControlsBackgroundColorForState(state, dark_mode, color_provider));
+        skrect.inset(skrect.width() * kIndeterminateInsetWidthRatio,
+                     skrect.height() * kIndeterminateInsetHeightRatio);
+        canvas->drawRoundRect(skrect, border_radius, border_radius, flags);
+      } else if (button.checked) {
+        // Draw the checkmark.
+        SkPath check;
+        check.moveTo(skrect.x() + skrect.width() * 0.2, skrect.centerY());
+        check.rLineTo(skrect.width() * 0.2, skrect.height() * 0.2);
+        check.lineTo(skrect.right() - skrect.width() * 0.2,
+                     skrect.y() + skrect.height() * 0.2);
+        flags.setStyle(cc::PaintFlags::kStroke_Style);
+        flags.setStrokeWidth(SkFloatToScalar(skrect.height() * 0.16));
+        SkColor checkmark_color =
+            ControlsBackgroundColorForState(state, dark_mode, color_provider);
+        flags.setColor(checkmark_color);
+        canvas->drawPath(check, flags);
+      }
+    }
   }
-
-  return path;
 }
 
-SkColor NativeThemeBase::GetAccentOrControlColorForState(
-    std::optional<SkColor> accent_color,
-    base::span<const ControlColorId, 4> colors,
+// Draws the common elements of checkboxes and radio buttons.
+// Returns the rectangle within which any additional decorations should be
+// drawn, or empty if none.
+SkRect NativeThemeBase::PaintCheckboxRadioCommon(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
     State state,
+    const gfx::Rect& rect,
+    const ButtonExtraParams& button,
+    bool is_checkbox,
+    const SkScalar border_radius,
     bool dark_mode,
-    PreferredContrast contrast,
-    const ColorProvider* color_provider) const {
-  if (state == kDisabled || !accent_color.has_value()) {
-    return GetControlColorForState(colors, state, dark_mode, contrast,
-                                   color_provider);
-  }
+    const std::optional<SkColor>& accent_color) const {
+  SkRect skrect = gfx::RectToSkRect(rect);
 
-  if (state == kNormal) {
-    return accent_color.value();
+  // Use the largest square that fits inside the provided rectangle.
+  // No other browser seems to support non-square widget, so accidentally
+  // having non-square sizes is common (eg. amazon and webkit dev tools).
+  if (skrect.width() != skrect.height()) {
+    SkScalar size = std::min(skrect.width(), skrect.height());
+    skrect.inset((skrect.width() - size) / 2, (skrect.height() - size) / 2);
   }
 
-  // Approximates the lightness difference between `kAccent` and
-  // `kHoveredAccent`.
-  static constexpr double kLightnessAdjust = 0.11;
-  double l_adjust = (state == kPressed) ? kLightnessAdjust : -kLightnessAdjust;
-  if (dark_mode) {
-    l_adjust = -l_adjust;
-  }
-
-  color_utils::HSL hsl;
-  color_utils::SkColorToHSL(accent_color.value(), &hsl);
-  hsl.l = std::clamp(hsl.l + l_adjust, 0.0, 1.0);
-  return color_utils::HSLToSkColor(hsl, SkColorGetA(accent_color.value()));
-}
-
-std::optional<SkColor> NativeThemeBase::GetContrastingColorForScrollbarPart(
-    std::optional<SkColor> fg_color,
-    std::optional<SkColor> bg_color,
-    State state) const {
-  if (!fg_color.has_value() || (state != kHovered && state != kPressed) ||
-      SkColorGetA(fg_color.value()) == SK_AlphaTRANSPARENT) {
-    return fg_color;
-  }
-  const SkColor resulting_color =
-      color_utils::BlendForMinContrast(
-          fg_color.value(), SkColorSetA(fg_color.value(), SK_AlphaOPAQUE),
-          std::nullopt, GetScrollbarPartContrastRatioForState(state))
-          .color;
-  if (!bg_color.has_value()) {
-    return resulting_color;
-  }
-  // Guaranteeing contrast with the background is prioritized over having
-  // contrast with the original part color. Making a second pass with the
-  // transforming function might make the final color not contrast as much with
-  // the original color, but the result is better than using
-  // `PickGoogleColorTwoBackgrounds()`, which tries to guarantee contrast with
-  // both (original and background) colors simultaneously, and ends up creating
-  // contrast changes that are too harsh.
-  return color_utils::BlendForMinContrast(
-             resulting_color, SkColorSetA(bg_color.value(), SK_AlphaOPAQUE),
-             std::nullopt, color_utils::kMinimumVisibleContrastRatio)
-      .color;
-}
-
-void NativeThemeBase::PaintCheckbox(cc::PaintCanvas* canvas,
-                                    const ColorProvider* color_provider,
-                                    State state,
-                                    const gfx::Rect& rect,
-                                    const ButtonExtraParams& extra_params,
-                                    bool dark_mode,
-                                    PreferredContrast contrast,
-                                    std::optional<SkColor> accent_color) const {
-  // Paint the background and border.
-  const float radius =
-      GetBorderRadiusForPart(kCheckbox, rect.width(), rect.height());
-  const SkRect skrect = PaintCheckboxRadioCommon(
-      canvas, color_provider, state, rect, extra_params, true, radius,
-      dark_mode, contrast, accent_color);
-  if (skrect.isEmpty()) {
-    return;
+  // If the rectangle is too small then paint only a rectangle. We don't want
+  // to have to worry about '- 1' and '+ 1' calculations below having overflow
+  // or underflow.
+  if (skrect.width() <= 2) {
+    cc::PaintFlags flags;
+    if (accent_color && state != kDisabled) {
+      flags.setColor(
+          CustomAccentColorForState(*accent_color, state, dark_mode));
+    } else {
+      flags.setColor(GetControlColor(kBorder, dark_mode, color_provider));
+    }
+    flags.setStyle(cc::PaintFlags::kFill_Style);
+    canvas->drawRect(skrect, flags);
+    // Too small to draw anything more.
+    return SkRect::MakeEmpty();
   }
 
   cc::PaintFlags flags;
   flags.setAntiAlias(true);
-  if (extra_params.indeterminate || extra_params.checked) {
-    // Paint an accent-colored background.
-    flags.setColor(GetAccentOrControlColorForState(accent_color, kAccentColors,
-                                                   state, dark_mode, contrast,
-                                                   color_provider));
-    canvas->drawRoundRect(skrect, radius, radius, flags);
-  }
-  flags.setColor(GetControlColorForState(kCheckboxBackgroundColors, state,
-                                         dark_mode, contrast, color_provider));
-  if (extra_params.indeterminate) {
-    // Paint the dash.
-    static constexpr gfx::Size kDashSize(8, 2);
-    static constexpr float kXInset =
-        (kCheckboxSize.width() - kDashSize.width()) / 2.0f;
-    static constexpr float kYInset =
-        (kCheckboxSize.height() - kDashSize.height()) / 2.0f;
-    canvas->drawRoundRect(
-        skrect.makeInset(kXInset * skrect.width() / kCheckboxSize.width(),
-                         kYInset * skrect.height() / kCheckboxSize.height()),
-        radius, radius, flags);
-  } else if (extra_params.checked) {
-    // Paint the checkmark.
-    SkPath check;
-    check.moveTo(skrect.x() + skrect.width() * 0.2f, skrect.centerY());
-    check.rLineTo(skrect.width() * 0.2f, skrect.height() * 0.2f);
-    check.lineTo(skrect.right() - skrect.width() * 0.2f,
-                 skrect.y() + skrect.height() * 0.2f);
+
+  // Paint the background (is not visible behind the rounded corners).
+  // Note we need to shrink the rect for background a little bit so we don't
+  // see artifacts introduced by antialiasing between the border and the
+  // background near the rounded corners of checkbox.
+  const auto background_rect =
+      skrect.makeInset(kBorderWidth * 0.2f, kBorderWidth * 0.2f);
+  PaintLightenLayer(canvas, color_provider, background_rect, state,
+                    border_radius, dark_mode);
+  flags.setColor(
+      ControlsBackgroundColorForState(state, dark_mode, color_provider));
+  flags.setStyle(cc::PaintFlags::kFill_Style);
+  canvas->drawRoundRect(background_rect, border_radius, border_radius, flags);
+
+  // For checkbox the border is drawn only when it is unchecked.
+  // For radio the border is always drawn.
+  if (!is_checkbox || (!button.checked && !button.indeterminate)) {
+    // Shrink half border width so the final pixels of the border will be
+    // within the rectangle.
+    const auto border_rect =
+        skrect.makeInset(kBorderWidth / 2, kBorderWidth / 2);
+
+    SkColor border_color;
+    if (button.checked) {
+      if (accent_color && state != kDisabled) {
+        border_color =
+            CustomAccentColorForState(*accent_color, state, dark_mode);
+      } else {
+        border_color =
+            ControlsAccentColorForState(state, dark_mode, color_provider);
+      }
+    } else {
+      border_color =
+          ControlsBorderColorForState(state, dark_mode, color_provider);
+    }
+    flags.setColor(border_color);
     flags.setStyle(cc::PaintFlags::kStroke_Style);
-    flags.setStrokeWidth(skrect.height() * 0.16f);
-    canvas->drawPath(check, flags);
+    flags.setStrokeWidth(kBorderWidth);
+    canvas->drawRoundRect(border_rect, border_radius, border_radius, flags);
   }
+  // Return the rectangle for drawing any additional decorations.
+  return skrect;
 }
 
-void NativeThemeBase::PaintInnerSpinButton(
+void NativeThemeBase::PaintRadio(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
     State state,
-    gfx::Rect rect,
-    const InnerSpinButtonExtraParams& extra_params,
-    bool forced_colors,
+    const gfx::Rect& rect,
+    const ButtonExtraParams& button,
     bool dark_mode,
-    PreferredContrast contrast) const {
-  if (extra_params.read_only) {
-    state = kDisabled;
+    const std::optional<SkColor>& accent_color) const {
+  // Most of a radio button is the same as a checkbox, except the the rounded
+  // square is a circle (i.e. border radius >= 100%).
+  const float border_radius =
+      GetBorderRadiusForPart(kRadio, rect.width(), rect.height());
+  SkRect skrect =
+      PaintCheckboxRadioCommon(canvas, color_provider, state, rect, button,
+                               false, border_radius, dark_mode, accent_color);
+  if (!skrect.isEmpty() && button.checked) {
+    // Draw the dot.
+    cc::PaintFlags flags;
+    flags.setAntiAlias(true);
+    flags.setStyle(cc::PaintFlags::kFill_Style);
+    if (accent_color && state != kDisabled) {
+      flags.setColor(
+          CustomAccentColorForState(*accent_color, state, dark_mode));
+    } else {
+      flags.setColor(
+          ControlsAccentColorForState(state, dark_mode, color_provider));
+    }
+
+    skrect.inset(skrect.width() * 0.2, skrect.height() * 0.2);
+    // Use drawRoundedRect instead of drawOval to be completely consistent
+    // with the border in PaintCheckboxRadioNewCommon.
+    canvas->drawRoundRect(skrect, border_radius, border_radius, flags);
   }
+}
 
-  State increase_state = state;
-  State decrease_state = state;
-  (extra_params.spin_up ? decrease_state : increase_state) =
-      (state == kDisabled) ? kDisabled : kNormal;
+void NativeThemeBase::PaintButton(cc::PaintCanvas* canvas,
+                                  const ColorProvider* color_provider,
+                                  State state,
+                                  const gfx::Rect& rect,
+                                  const ButtonExtraParams& button,
+                                  bool dark_mode) const {
+  cc::PaintFlags flags;
+  SkRect skrect = gfx::RectToSkRect(rect);
+  float border_width = AdjustBorderWidthByZoom(kBorderWidth, button.zoom);
 
-  const ScrollbarArrowExtraParams arrow = {.zoom = 1.0f};
-  if (extra_params.spin_arrows_direction == SpinArrowsDirection::kUpDown) {
-    rect.set_height(rect.height() / 2);
-    PaintArrowButton(canvas, color_provider, rect, kScrollbarUpArrow,
-                     increase_state, forced_colors, dark_mode, contrast, arrow);
+  flags.setAntiAlias(true);
+  flags.setStyle(cc::PaintFlags::kFill_Style);
 
-    rect.set_y(rect.bottom());
-    PaintArrowButton(canvas, color_provider, rect, kScrollbarDownArrow,
-                     decrease_state, forced_colors, dark_mode, contrast, arrow);
-  } else {
-    rect.set_width(rect.width() / 2);
-    PaintArrowButton(canvas, color_provider, rect, kScrollbarLeftArrow,
-                     decrease_state, forced_colors, dark_mode, contrast, arrow);
+  // If the button is too small, fallback to drawing a single, solid color.
+  if (rect.width() < 5 || rect.height() < 5) {
+    flags.setColor(ButtonFillColorForState(state, dark_mode, color_provider));
+    canvas->drawRect(skrect, flags);
+    return;
+  }
 
-    rect.set_x(rect.right());
-    PaintArrowButton(canvas, color_provider, rect, kScrollbarRightArrow,
-                     increase_state, forced_colors, dark_mode, contrast, arrow);
+  float border_radius =
+      GetBorderRadiusForPart(kPushButton, rect.width(), rect.height());
+  border_radius =
+      AdjustBorderRadiusByZoom(kPushButton, border_radius, button.zoom);
+  // Paint the background (is not visible behind the rounded corners).
+  skrect.inset(border_width / 2, border_width / 2);
+  PaintLightenLayer(canvas, color_provider, skrect, state, border_radius,
+                    dark_mode);
+  flags.setColor(ButtonFillColorForState(state, dark_mode, color_provider));
+  canvas->drawRoundRect(skrect, border_radius, border_radius, flags);
+
+  // Paint the border: 1px solid.
+  if (button.has_border) {
+    flags.setStyle(cc::PaintFlags::kStroke_Style);
+    flags.setStrokeWidth(border_width);
+    flags.setColor(ButtonBorderColorForState(state, dark_mode, color_provider));
+    canvas->drawRoundRect(skrect, border_radius, border_radius, flags);
+  }
+}
+
+void NativeThemeBase::PaintTextField(cc::PaintCanvas* canvas,
+                                     const ColorProvider* color_provider,
+                                     State state,
+                                     const gfx::Rect& rect,
+                                     const TextFieldExtraParams& text,
+                                     bool dark_mode) const {
+  SkRect bounds = gfx::RectToSkRect(rect);
+  float border_radius =
+      GetBorderRadiusForPart(kTextField, rect.width(), rect.height());
+  border_radius =
+      AdjustBorderRadiusByZoom(kTextField, border_radius, text.zoom);
+  float border_width = AdjustBorderWidthByZoom(kBorderWidth, text.zoom);
+
+  // Paint the background (is not visible behind the rounded corners).
+  bounds.inset(border_width / 2, border_width / 2);
+  cc::PaintFlags fill_flags;
+  fill_flags.setStyle(cc::PaintFlags::kFill_Style);
+  if (text.background_color != 0) {
+    PaintLightenLayer(canvas, color_provider, bounds, state, border_radius,
+                      dark_mode);
+    SkColor text_field_background_color =
+        ControlsBackgroundColorForState(state, dark_mode, color_provider);
+    if (text.auto_complete_active && state != kDisabled) {
+      text_field_background_color =
+          GetControlColor(kAutoCompleteBackground, dark_mode, color_provider);
+    }
+    fill_flags.setColor(text_field_background_color);
+    canvas->drawRoundRect(bounds, border_radius, border_radius, fill_flags);
+  }
+
+  // Paint the border: 1px solid.
+  if (text.has_border) {
+    cc::PaintFlags stroke_flags;
+    stroke_flags.setColor(
+        ControlsBorderColorForState(state, dark_mode, color_provider));
+    stroke_flags.setStyle(cc::PaintFlags::kStroke_Style);
+    stroke_flags.setStrokeWidth(border_width);
+    canvas->drawRoundRect(bounds, border_radius, border_radius, stroke_flags);
   }
 }
 
@@ -691,450 +757,641 @@ void NativeThemeBase::PaintMenuList(cc::PaintCanvas* canvas,
                                     const ColorProvider* color_provider,
                                     State state,
                                     const gfx::Rect& rect,
-                                    const MenuListExtraParams& extra_params,
-                                    bool dark_mode,
-                                    PreferredContrast contrast) const {
-  // If a border radius is specified, Blink will paint the background and the
-  // border.
-  // TODO(pkasting): The comment above seems untrue;
-  // `ThemePainterDefault::PaintMenuList()` always returns false, so I believe
-  // Blink never paints the CSS border/background?
-  if (!extra_params.has_border_radius) {
-    TextFieldExtraParams params;
-    params.background_color = extra_params.background_color;
-    params.has_border = extra_params.has_border;
-    params.zoom = extra_params.zoom;
-    PaintTextField(canvas, color_provider, state, rect, params, dark_mode,
-                   contrast);
+                                    const MenuListExtraParams& menu_list,
+                                    bool dark_mode) const {
+  // If a border radius is specified paint the background and the border of
+  // the menulist, otherwise let the non-theming code paint the background
+  // and the border of the control. The arrow (menulist button) is always
+  // painted by the theming code.
+  if (!menu_list.has_border_radius) {
+    TextFieldExtraParams text_field;
+    text_field.background_color = menu_list.background_color;
+    text_field.has_border = menu_list.has_border;
+    text_field.zoom = menu_list.zoom;
+    PaintTextField(canvas, color_provider, state, rect, text_field, dark_mode);
   }
 
+  // Paint the arrow.
+  cc::PaintFlags flags;
+  flags.setColor(menu_list.arrow_color);
+  flags.setAntiAlias(true);
+  flags.setStyle(cc::PaintFlags::kStroke_Style);
+  flags.setStrokeWidth(kMenuListArrowStrokeWidth);
+
   // The arrow base is twice the arrow height, giving 45 degree sides.
   static constexpr float kAspectRatio = 2.0f;
 
-  SkPath path;
-  if (extra_params.arrow_direction == ArrowDirection::kDown) {
-    int intended_width = extra_params.arrow_size;
-    int intended_height = base::ClampFloor(intended_width / kAspectRatio);
-
-    // `extra_params.arrow_x` is the left edge, but `extra_params.arrow_y` is
-    // the vertical center.
-    // TODO(pkasting): This leads to complication and bugs; change
-    // `ThemePainterDefault::SetupMenuListArrow()` to pass the arrow center
-    // point and fix `NativeTheme` implementations accordingly.
-    gfx::Rect arrow(extra_params.arrow_x,
-                    extra_params.arrow_y - (intended_height / 2),
-                    intended_width, intended_height);
-
-    // Fit the arrow within the paint rect.
+  if (menu_list.arrow_direction == ui::NativeTheme::ArrowDirection::kDown) {
+    int arrow_width = menu_list.arrow_size;
+    int arrow_height = base::ClampFloor(arrow_width / kAspectRatio);
+    gfx::Rect arrow(menu_list.arrow_x, menu_list.arrow_y - (arrow_height / 2),
+                    arrow_width, arrow_height);
     arrow.Intersect(rect);
-    if (arrow.width() != intended_width || arrow.height() != intended_height) {
+
+    if (arrow_width != arrow.width() || arrow_height != arrow.height()) {
       // Shrink the arrow so it's not clipped. Pick the dimension that was
       // clipped "more" (keeping in mind that each px of height is worth
       // `kAspectRatio` px of width) and compute the other dimension based on
       // that.
-      const int height_clip = (intended_height - arrow.height()) * kAspectRatio;
-      const int width_clip = intended_width - arrow.width();
+      int height_clip = (arrow_height - arrow.height()) * kAspectRatio;
+      int width_clip = arrow_width - arrow.width();
       if (height_clip > width_clip) {
         arrow.set_width(arrow.height() * kAspectRatio);
       } else {
         arrow.set_height(arrow.width() / kAspectRatio);
       }
-      arrow.set_origin(
-          {extra_params.arrow_x + (intended_width - arrow.width()) / 2,
-           extra_params.arrow_y - arrow.height() / 2});
+      arrow.set_origin({menu_list.arrow_x + (arrow_width - arrow.width()) / 2,
+                        menu_list.arrow_y - arrow.height() / 2});
     }
 
+    SkPath path;
     path.moveTo(arrow.x(), arrow.y());
-    path.lineTo(arrow.x() + arrow.width() / 2, arrow.bottom());
-    path.lineTo(arrow.right(), arrow.y());
+    path.lineTo(arrow.x() + arrow.width() / 2, arrow.y() + arrow.height());
+    path.lineTo(arrow.x() + arrow.width(), arrow.y());
+    canvas->drawPath(path, flags);
   } else {
-    // Arrow direction is either left or right.
-    int intended_height = extra_params.arrow_size;
-    int intended_width = base::ClampFloor(intended_height / kAspectRatio);
-
-    // `extra_params.arrow_x` is the horizontal center, but
-    // `extra_params.arrow_y` is the top edge.
-    // TODO(pkasting): This leads to complication and bugs; change
-    // `ThemePainterDefault::SetupMenuListArrow()` to pass the arrow center
-    // point and fix `NativeTheme` implementations accordingly.
-    gfx::Rect arrow(extra_params.arrow_x - (intended_width / 2),
-                    extra_params.arrow_y, intended_width, intended_height);
-
-    // Fit the arrow within the paint rect.
+    // Arrow direction is either left or right
+    int arrow_height = menu_list.arrow_size;
+    int arrow_width = base::ClampFloor(arrow_height / kAspectRatio);
+    gfx::Rect arrow(menu_list.arrow_x - (arrow_width / 2), menu_list.arrow_y,
+                    arrow_width, arrow_height);
     arrow.Intersect(rect);
-    if (arrow.width() != intended_width || arrow.height() != intended_height) {
+
+    if (arrow_width != arrow.width() || arrow_height != arrow.height()) {
       // Shrink the arrow so it's not clipped. Pick the dimension that was
       // clipped "more" (keeping in mind that each px of width is worth
       // `kAspectRatio` px of height) and compute the other dimension based on
       // that.
-      const int height_clip = intended_height - arrow.height();
-      const int width_clip = (intended_width - arrow.width()) * kAspectRatio;
+      int height_clip = arrow_height - arrow.height();
+      int width_clip = (arrow_width - arrow.width()) * kAspectRatio;
       if (height_clip > width_clip) {
         arrow.set_width(arrow.height() / kAspectRatio);
       } else {
         arrow.set_height(arrow.width() * kAspectRatio);
       }
       arrow.set_origin(
-          {extra_params.arrow_x - arrow.width() / 2,
-           extra_params.arrow_y + (intended_height - arrow.height()) / 2});
+          {menu_list.arrow_x - arrow.width() / 2,
+           menu_list.arrow_y + (arrow_height - arrow.height()) / 2});
     }
 
-    if (extra_params.arrow_direction == ArrowDirection::kLeft) {
-      path.moveTo(arrow.right(), arrow.y());
+    SkPath path;
+    if (menu_list.arrow_direction == ui::NativeTheme::ArrowDirection::kLeft) {
+      path.moveTo(arrow.x() + arrow.width(), arrow.y());
       path.lineTo(arrow.x(), arrow.y() + arrow.height() / 2);
-      path.lineTo(arrow.right(), arrow.bottom());
+      path.lineTo(arrow.x() + arrow.width(), arrow.y() + arrow.height());
     } else {
+      // Arrow direction is right
       path.moveTo(arrow.x(), arrow.y());
-      path.lineTo(arrow.right(), arrow.y() + arrow.height() / 2);
-      path.lineTo(arrow.x(), arrow.bottom());
+      path.lineTo(arrow.x() + arrow.width(), arrow.y() + arrow.height() / 2);
+      path.lineTo(arrow.x(), arrow.y() + arrow.height());
     }
+    canvas->drawPath(path, flags);
   }
-  // NOTE: Do not close the path; we want a "v" shape, not a triangle.
+}
 
+void NativeThemeBase::PaintMenuPopupBackground(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
+    const gfx::Size& size,
+    const MenuBackgroundExtraParams& menu_background) const {
+  CHECK(color_provider);
+  // TODO(crbug.com/40219248): Remove FromColor and make all SkColor4f.
+  canvas->drawColor(
+      SkColor4f::FromColor(color_provider->GetColor(kColorMenuBackground)),
+      SkBlendMode::kSrc);
+}
+
+void NativeThemeBase::PaintMenuSeparator(
+    cc::PaintCanvas* canvas,
+    const ui::ColorProvider* color_provider,
+    State state,
+    const gfx::Rect& rect,
+    const MenuSeparatorExtraParams& menu_separator) const {
+  DCHECK(color_provider);
   cc::PaintFlags flags;
-  flags.setColor(extra_params.arrow_color);
-  flags.setAntiAlias(true);
-  flags.setStyle(cc::PaintFlags::kStroke_Style);
-  flags.setStrokeWidth(2.0f);
-  canvas->drawPath(path, flags);
+  flags.setColor(color_provider->GetColor(menu_separator.color_id));
+  canvas->drawRect(gfx::RectToSkRect(*menu_separator.paint_rect), flags);
 }
 
-void NativeThemeBase::PaintProgressBar(
+void NativeThemeBase::PaintSliderTrack(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
     State state,
     const gfx::Rect& rect,
-    const ProgressBarExtraParams& extra_params,
+    const SliderExtraParams& slider,
     bool dark_mode,
     PreferredContrast contrast,
-    std::optional<SkColor> accent_color) const {
-  CHECK(!rect.IsEmpty());
-
-  const SliderExtraParams slider = {.vertical = !extra_params.is_horizontal};
-  // Sliders in a larger area keep the same thickness while progress bars scale,
-  // but using the slider sizes in a ratio here means that when both are drawn
-  // in a default-sized space (i.e. thickness = `kSliderThumbThickness`), both
-  // will be the same thickness.
-  const float thickness = (slider.vertical ? rect.width() : rect.height()) *
-                          static_cast<float>(kSliderTrackThickness) /
-                          kSliderThumbThickness;
-  const SkRect track_rect = AlignSliderTrack(rect, slider, false, thickness);
-  const float radius = GetBorderRadiusForPart(kProgressBar, track_rect.width(),
-                                              track_rect.height());
-
-  // Paint the track.
+    const std::optional<SkColor>& accent_color) const {
+  // Paint the entire slider track.
   cc::PaintFlags flags;
   flags.setAntiAlias(true);
-  flags.setColor(GetControlColorForState(kFillColors, state, dark_mode,
-                                         contrast, color_provider));
-  canvas->drawRoundRect(track_rect, radius, radius, flags);
-
-  // Paint the progress value bar.
-  int value_height = extra_params.value_rect_height;
-  int value_width = extra_params.value_rect_width;
-  int& value_length = slider.vertical ? value_height : value_width;
-  if (value_length > 0) {
-    value_length = std::max(value_length, 2);
+  flags.setColor(ControlsFillColorForState(state, dark_mode, color_provider));
+  const float track_height = kSliderTrackHeight * slider.zoom;
+  SkRect track_rect = AlignSliderTrack(rect, slider, false, track_height);
+  float border_width = AdjustBorderWidthByZoom(kBorderWidth, slider.zoom);
+  // Shrink the track by 1 pixel so the thumb can completely cover the track
+  // on both ends.
+  if (slider.vertical) {
+    track_rect.inset(0, 1);
+  } else {
+    track_rect.inset(1, 0);
   }
-  const SkRect value_rect = AlignSliderTrack(
-      gfx::Rect(extra_params.value_rect_x, extra_params.value_rect_y,
-                value_width, value_height),
-      slider, false, thickness);
-  flags.setColor(GetAccentOrControlColorForState(
-      accent_color, kAccentColors, state, dark_mode, contrast, color_provider));
-  if (extra_params.determinate) {
-    canvas->clipRRect(SkRRect::MakeRectXY(track_rect, radius, radius), true);
-    canvas->drawRect(value_rect, flags);
+  float border_radius =
+      GetBorderRadiusForPart(kSliderTrack, rect.width(), rect.height());
+  canvas->drawRoundRect(track_rect, border_radius, border_radius, flags);
+
+  // Set the clip to the extent of the value bar.
+  SkRect value_rect = AlignSliderTrack(rect, slider, true, track_height);
+  canvas->save();
+  canvas->clipRect(value_rect, SkClipOp::kIntersect, true);
+
+  // Draw the full value bar, clipped to its extent.
+  if (accent_color && state != kDisabled) {
+    flags.setColor(CustomAccentColorForState(*accent_color, state, dark_mode));
   } else {
-    canvas->drawRoundRect(value_rect, radius, radius, flags);
+    flags.setColor(
+        ControlsSliderColorForState(state, dark_mode, color_provider));
   }
+  SkRRect rounded_rect;
+  rounded_rect.setRectXY(track_rect, border_radius, border_radius);
+  canvas->drawRRect(rounded_rect, flags);
+  canvas->restore();
 
   // Paint the border.
-  const float border_width =
-      AdjustBorderWidthByZoom(kBorderWidth, extra_params.zoom);
   flags.setStyle(cc::PaintFlags::kStroke_Style);
   flags.setStrokeWidth(border_width);
-  flags.setColor(GetControlColorForState(kSliderBorderColors, state, dark_mode,
-                                         contrast, color_provider));
-  canvas->drawRoundRect(
-      track_rect.makeInset(border_width / 2, border_width / 2), radius, radius,
-      flags);
+  SkColor border_color =
+      ControlsBorderColorForState(state, dark_mode, color_provider);
+  if (contrast != PreferredContrast::kMore && state != kDisabled &&
+      !dark_mode) {
+    border_color = SkColorSetA(border_color, 0x80);
+  }
+  flags.setColor(border_color);
+  track_rect.inset(border_width / 2, border_width / 2);
+  canvas->drawRoundRect(track_rect, border_radius, border_radius, flags);
 }
 
-void NativeThemeBase::PaintButton(cc::PaintCanvas* canvas,
-                                  const ColorProvider* color_provider,
-                                  State state,
-                                  const gfx::Rect& rect,
-                                  const ButtonExtraParams& extra_params,
-                                  bool dark_mode,
-                                  PreferredContrast contrast) const {
-  SkRect skrect = gfx::RectToSkRect(rect);
+void NativeThemeBase::PaintSliderThumb(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
+    State state,
+    const gfx::Rect& rect,
+    const SliderExtraParams& slider,
+    bool dark_mode,
+    const std::optional<SkColor>& accent_color) const {
+  const float radius =
+      GetBorderRadiusForPart(kSliderThumb, rect.width(), rect.height());
+  SkRect thumb_rect = gfx::RectToSkRect(rect);
+
   cc::PaintFlags flags;
   flags.setAntiAlias(true);
-  static constexpr auto kButtonFillColors =
-      std::to_array({kButtonDisabledFill, kButtonHoveredFill, kButtonFill,
-                     kButtonPressedFill});
-  flags.setColor(GetControlColorForState(kButtonFillColors, state, dark_mode,
-                                         contrast, color_provider));
-
-  // If the button is too small, fallback to drawing a solid color rect.
-  if (rect.width() < 5 || rect.height() < 5) {
-    canvas->drawRect(skrect, flags);
-    return;
+  SkScalar border_width = kSliderThumbBorderWidth;
+  if (state == kHovered || state == kPressed) {
+    border_width = kSliderThumbBorderHoveredWidth;
   }
 
-  const float border_width =
-      AdjustBorderWidthByZoom(kBorderWidth, extra_params.zoom);
-  skrect.inset(border_width / 2, border_width / 2);
-  const float radius = AdjustBorderRadiusByZoom(
-      kPushButton,
-      GetBorderRadiusForPart(kPushButton, skrect.width(), skrect.height()),
-      extra_params.zoom);
-
-  // Paint the background.
-  PaintLightenLayer(canvas, color_provider, skrect, state, radius, dark_mode,
-                    contrast);
-  canvas->drawRoundRect(skrect, radius, radius, flags);
-
-  // Paint the border.
-  if (extra_params.has_border) {
-    flags.setStyle(cc::PaintFlags::kStroke_Style);
-    flags.setStrokeWidth(border_width);
-    flags.setColor(GetControlColorForState(
-        kButtonBorderColors, state, dark_mode, contrast, color_provider));
-    canvas->drawRoundRect(skrect, radius, radius, flags);
+  // Paint the background (is not visible behind the rounded corners).
+  thumb_rect.inset(border_width / 2, border_width / 2);
+  if (accent_color && state != kDisabled) {
+    flags.setColor(CustomAccentColorForState(*accent_color, state, dark_mode));
+  } else {
+    flags.setColor(
+        ControlsSliderColorForState(state, dark_mode, color_provider));
   }
+  flags.setStyle(cc::PaintFlags::kFill_Style);
+  canvas->drawRoundRect(thumb_rect, radius, radius, flags);
 }
 
-void NativeThemeBase::PaintRadio(cc::PaintCanvas* canvas,
-                                 const ColorProvider* color_provider,
-                                 State state,
-                                 const gfx::Rect& rect,
-                                 const ButtonExtraParams& extra_params,
-                                 bool dark_mode,
-                                 PreferredContrast contrast,
-                                 std::optional<SkColor> accent_color) const {
-  // Paint the background and border.
-  const float radius =
-      GetBorderRadiusForPart(kRadio, rect.width(), rect.height());
-  const SkRect skrect = PaintCheckboxRadioCommon(
-      canvas, color_provider, state, rect, extra_params, false, radius,
-      dark_mode, contrast, accent_color);
-  if (skrect.isEmpty() || !extra_params.checked) {
-    return;
+void NativeThemeBase::PaintInnerSpinButton(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
+    State state,
+    const gfx::Rect& rect,
+    const InnerSpinButtonExtraParams& spin_button,
+    bool forced_colors,
+    bool dark_mode,
+    PreferredContrast contrast) const {
+  if (spin_button.read_only) {
+    state = kDisabled;
   }
 
-  // Paint the dot.
-  cc::PaintFlags flags;
-  flags.setAntiAlias(true);
-  flags.setColor(GetAccentOrControlColorForState(
-      accent_color, kAccentColors, state, dark_mode, contrast, color_provider));
-  canvas->drawRoundRect(
-      skrect.makeInset(skrect.width() * 0.2, skrect.height() * 0.2), radius,
-      radius, flags);
+  State north_state = state;
+  State south_state = state;
+  if (spin_button.spin_up) {
+    south_state = south_state != kDisabled ? kNormal : kDisabled;
+  } else {
+    north_state = north_state != kDisabled ? kNormal : kDisabled;
+  }
+
+  gfx::Rect half = rect;
+  ScrollbarArrowExtraParams arrow = ScrollbarArrowExtraParams();
+  arrow.zoom = 1.0;
+  if (spin_button.spin_arrows_direction ==
+      ui::NativeTheme::SpinArrowsDirection::kUpDown) {
+    half.set_height(rect.height() / 2);
+    PaintArrowButton(canvas, color_provider, half, kScrollbarUpArrow,
+                     north_state, forced_colors, dark_mode, contrast, arrow);
+
+    half.set_y(rect.y() + rect.height() / 2);
+    PaintArrowButton(canvas, color_provider, half, kScrollbarDownArrow,
+                     south_state, forced_colors, dark_mode, contrast, arrow);
+  } else {
+    half.set_width(rect.width() / 2);
+    PaintArrowButton(canvas, color_provider, half, kScrollbarLeftArrow,
+                     south_state, forced_colors, dark_mode, contrast, arrow);
+
+    half.set_x(rect.x() + rect.width() / 2);
+    PaintArrowButton(canvas, color_provider, half, kScrollbarRightArrow,
+                     north_state, forced_colors, dark_mode, contrast, arrow);
+  }
 }
 
-void NativeThemeBase::PaintSliderTrack(
+void NativeThemeBase::PaintProgressBar(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
     State state,
     const gfx::Rect& rect,
-    const SliderExtraParams& extra_params,
+    const ProgressBarExtraParams& progress_bar,
     bool dark_mode,
     PreferredContrast contrast,
-    std::optional<SkColor> accent_color) const {
-  const float track_height = kSliderTrackThickness * extra_params.zoom;
-  SkRect track_rect = AlignSliderTrack(rect, extra_params, false, track_height);
-  const float radius = GetBorderRadiusForPart(kSliderTrack, track_rect.width(),
-                                              track_rect.height());
-  // Shrink the track by 1 pixel on each end so the thumb can completely
-  // cover.
-  if (extra_params.vertical) {
-    track_rect.inset(0, 1);
-  } else {
-    track_rect.inset(1, 0);
-  }
-
+    const std::optional<SkColor>& accent_color) const {
+  DCHECK(!rect.IsEmpty());
   // Paint the track.
   cc::PaintFlags flags;
   flags.setAntiAlias(true);
-  flags.setColor(GetControlColorForState(kFillColors, state, dark_mode,
-                                         contrast, color_provider));
-  canvas->drawRoundRect(track_rect, radius, radius, flags);
-
-  {
-    // Paint the value bar, clipped to its extent.
-    gfx::Canvas gfx_canvas(canvas, 1.0f);
-    gfx::ScopedCanvas scoped_canvas(&gfx_canvas);
-    canvas->clipRect(AlignSliderTrack(rect, extra_params, true, track_height),
-                     true);
-    flags.setColor(GetAccentOrControlColorForState(accent_color, kSliderColors,
-                                                   state, dark_mode, contrast,
-                                                   color_provider));
-    canvas->drawRoundRect(track_rect, radius, radius, flags);
+  flags.setStyle(cc::PaintFlags::kFill_Style);
+  flags.setColor(GetControlColor(kFill, dark_mode, color_provider));
+  SliderExtraParams slider;
+  float track_block_thickness = rect.height();
+  if (progress_bar.is_horizontal) {
+    slider.vertical = false;
+    track_block_thickness = rect.height() * kTrackBlockRatio;
+  } else {
+    slider.vertical = true;
+    track_block_thickness = rect.width() * kTrackBlockRatio;
+  }
+  SkRect track_rect =
+      AlignSliderTrack(rect, slider, false, track_block_thickness);
+  float border_radius =
+      GetBorderRadiusForPart(kProgressBar, rect.width(), rect.height());
+  canvas->drawRoundRect(track_rect, border_radius, border_radius, flags);
+
+  // Clip the track to create rounded corners for the value bar.
+  SkRRect rounded_rect;
+  rounded_rect.setRectXY(track_rect, border_radius, border_radius);
+  canvas->clipRRect(rounded_rect, SkClipOp::kIntersect, true);
+
+  // Paint the progress value bar.
+  const SkScalar kMinimumProgressInlineValue = 2;
+  SkScalar adjusted_height = progress_bar.value_rect_height;
+  SkScalar adjusted_width = progress_bar.value_rect_width;
+  // If adjusted thickness is not zero, make sure it is equal or larger than
+  // kMinimumProgressInlineValue.
+  if (slider.vertical) {
+    if (adjusted_height > 0) {
+      adjusted_height = std::max(kMinimumProgressInlineValue, adjusted_height);
+    }
+  } else {
+    if (adjusted_width > 0) {
+      adjusted_width = std::max(kMinimumProgressInlineValue, adjusted_width);
+    }
+  }
+  gfx::Rect original_value_rect(progress_bar.value_rect_x,
+                                progress_bar.value_rect_y, adjusted_width,
+                                adjusted_height);
+  SkRect value_rect = AlignSliderTrack(original_value_rect, slider, false,
+                                       track_block_thickness);
+  if (accent_color) {
+    flags.setColor(*accent_color);
+  } else {
+    flags.setColor(GetControlColor(kAccent, dark_mode, color_provider));
+  }
+  if (progress_bar.determinate) {
+    canvas->drawRect(value_rect, flags);
+  } else {
+    canvas->drawRoundRect(value_rect, border_radius, border_radius, flags);
   }
 
   // Paint the border.
+  float border_width = AdjustBorderWidthByZoom(kBorderWidth, progress_bar.zoom);
   flags.setStyle(cc::PaintFlags::kStroke_Style);
-  const float border_width =
-      AdjustBorderWidthByZoom(kBorderWidth, extra_params.zoom);
   flags.setStrokeWidth(border_width);
-  flags.setColor(GetControlColorForState(kSliderBorderColors, state, dark_mode,
-                                         contrast, color_provider));
-  canvas->drawRoundRect(
-      track_rect.makeInset(border_width / 2, border_width / 2), radius, radius,
-      flags);
+  SkColor border_color = GetControlColor(kBorder, dark_mode, color_provider);
+  if (contrast != PreferredContrast::kMore && !dark_mode) {
+    border_color = SkColorSetA(border_color, 0x80);
+  }
+  flags.setColor(border_color);
+  track_rect.inset(border_width / 2, border_width / 2);
+  canvas->drawRoundRect(track_rect, border_radius, border_radius, flags);
 }
 
-void NativeThemeBase::PaintSliderThumb(
+void NativeThemeBase::PaintFrameTopArea(
     cc::PaintCanvas* canvas,
-    const ColorProvider* color_provider,
     State state,
     const gfx::Rect& rect,
-    const SliderExtraParams& extra_params,
-    bool dark_mode,
-    PreferredContrast contrast,
-    std::optional<SkColor> accent_color) const {
-  const SkRect thumb_rect = gfx::RectToSkRect(rect);
-  const float radius = GetBorderRadiusForPart(kSliderThumb, thumb_rect.width(),
-                                              thumb_rect.height());
+    const FrameTopAreaExtraParams& frame_top_area) const {
   cc::PaintFlags flags;
-  flags.setAntiAlias(true);
-  flags.setColor(GetAccentOrControlColorForState(
-      accent_color, kSliderColors, state, dark_mode, contrast, color_provider));
-  // TODO(pkasting): This inset appears to be a historical accident; consider
-  // removing it and rebaselining the slider appearance.
-  canvas->drawRoundRect(thumb_rect.makeInset(0.5f, 0.5f), radius, radius,
-                        flags);
+  flags.setColor(frame_top_area.default_background_color);
+  canvas->drawRect(gfx::RectToSkRect(rect), flags);
 }
 
-void NativeThemeBase::PaintTextField(cc::PaintCanvas* canvas,
-                                     const ColorProvider* color_provider,
-                                     State state,
-                                     const gfx::Rect& rect,
-                                     const TextFieldExtraParams& extra_params,
-                                     bool dark_mode,
-                                     PreferredContrast contrast) const {
-  SkRect bounds = gfx::RectToSkRect(rect);
-  const float border_width =
-      AdjustBorderWidthByZoom(kBorderWidth, extra_params.zoom);
-  bounds.inset(border_width / 2, border_width / 2);
-  const float radius = AdjustBorderRadiusByZoom(
-      kTextField,
-      GetBorderRadiusForPart(kTextField, bounds.width(), bounds.height()),
-      extra_params.zoom);
-
-  // Paint the background.
-  const bool paint_autocomplete_background =
-      extra_params.auto_complete_active && state != kDisabled;
-  if (paint_autocomplete_background ||
-      SkColorGetA(extra_params.background_color)) {
-    PaintLightenLayer(canvas, color_provider, bounds, state, radius, dark_mode,
-                      contrast);
-    cc::PaintFlags bg_flags;
-    // TODO(crbug.com/446078854): The current background color seems wrong; it
-    // was done in
-    // https://crrev.com/c/1792578/5..7/ui/native_theme/native_theme_aura.cc
-    // ...due to feedback that the previous version of that patch, which used
-    // CSS to add a white hover effect, was causing interop problems.
-    // Unfortunately the new version discarded the passed-in background color
-    // entirely, likely due to oversight, and affected far more than just the
-    // hover state.
-    //
-    // The disabled branch here contains what pkasting thinks is the correct
-    // code; however, this may have significant visual effect and possible web
-    // compat ramifications, and may need to be discussed with Blink forms/a11y
-    // folks. This might require Blink-side changes and/or WPT updates in
-    // addition to simple rebaselines.
-    SkColor default_bg_color;
-    if constexpr (false) {
-      // Proposed behavior
-      default_bg_color = GetAccentOrControlColorForState(
-          extra_params.background_color,
-          kFillColors /* Doesn't matter, won't be used */,
-          // Not certain of the correct disabled state behavior
-          (state == kDisabled) ? kNormal : state, dark_mode, contrast,
-          color_provider);
-    } else {
-      // Status quo behavior
-      default_bg_color =
-          GetControlColorForState(kCheckboxBackgroundColors, state, dark_mode,
-                                  contrast, color_provider);
-    }
-    bg_flags.setColor(paint_autocomplete_background
-                          ? GetControlColor(kAutoCompleteBackground, dark_mode,
-                                            contrast, color_provider)
-                          : default_bg_color);
-    canvas->drawRoundRect(bounds, radius, radius, bg_flags);
+void NativeThemeBase::AdjustCheckboxRadioRectForPadding(SkRect* rect) const {
+  // By default we only take 1px from right and bottom for the drop shadow.
+  rect->setLTRB(static_cast<int>(rect->x()), static_cast<int>(rect->y()),
+                static_cast<int>(rect->right()) - 1,
+                static_cast<int>(rect->bottom()) - 1);
+}
+
+SkColor NativeThemeBase::SaturateAndBrighten(SkScalar* hsv,
+                                             SkScalar saturate_amount,
+                                             SkScalar brighten_amount) const {
+  SkScalar color[3];
+  color[0] = hsv[0];
+  color[1] = std::clamp(UNSAFE_TODO(hsv[1]) + saturate_amount, SkScalar{0},
+                        SK_Scalar1);
+  color[2] = std::clamp(UNSAFE_TODO(hsv[2]) + brighten_amount, SkScalar{0},
+                        SK_Scalar1);
+  return SkHSVToColor(color);
+}
+
+SkColor NativeThemeBase::GetArrowColor(
+    State state,
+    bool dark_mode,
+    const ColorProvider* color_provider) const {
+  if (state != kDisabled) {
+    return GetColor(kArrowDisabledColor, dark_mode);
   }
 
-  // Paint the border.
-  if (extra_params.has_border) {
-    cc::PaintFlags border_flags;
-    border_flags.setColor(GetControlColorForState(
-        kBorderColors, state, dark_mode, contrast, color_provider));
-    border_flags.setStyle(cc::PaintFlags::kStroke_Style);
-    border_flags.setStrokeWidth(border_width);
-    canvas->drawRoundRect(bounds, radius, radius, border_flags);
+  SkScalar track_hsv[3];
+  SkColorToHSV(GetColor(kTrackColor, dark_mode), track_hsv);
+
+  SkScalar thumb_hsv[3];
+  SkColorToHSV(
+      GetControlColor(kScrollbarThumbInactive, dark_mode, color_provider),
+      thumb_hsv);
+  return OutlineColor(track_hsv, thumb_hsv);
+}
+
+SkColor NativeThemeBase::OutlineColor(SkScalar* hsv1, SkScalar* hsv2) const {
+  // GTK Theme engines have way too much control over the layout of
+  // the scrollbar. We might be able to more closely approximate its
+  // look-and-feel, if we sent whole images instead of just colors
+  // from the browser to the renderer. But even then, some themes
+  // would just break.
+  //
+  // So, instead, we don't even try to 100% replicate the look of
+  // the native scrollbar. We render our own version, but we make
+  // sure to pick colors that blend in nicely with the system GTK
+  // theme. In most cases, we can just sample a couple of pixels
+  // from the system scrollbar and use those colors to draw our
+  // scrollbar.
+  //
+  // This works fine for the track color and the overall thumb
+  // color. But it fails spectacularly for the outline color used
+  // around the thumb piece.  Not all themes have a clearly defined
+  // outline. For some of them it is partially transparent, and for
+  // others the thickness is very unpredictable.
+  //
+  // So, instead of trying to approximate the system theme, we
+  // instead try to compute a reasonable looking choice based on the
+  // known color of the track and the thumb piece. This is difficult
+  // when trying to deal both with high- and low-contrast themes,
+  // and both with positive and inverted themes.
+  //
+  // The following code has been tested to look OK with all of the
+  // default GTK themes.
+  SkScalar min_diff = std::clamp(
+      (UNSAFE_TODO(hsv1[1]) + UNSAFE_TODO(hsv2[1])) * 1.2f, 0.28f, 0.5f);
+  SkScalar diff = std::clamp(
+      fabsf(UNSAFE_TODO(hsv1[2]) - UNSAFE_TODO(hsv2[2])) / 2, min_diff, 0.5f);
+
+  if (UNSAFE_TODO(hsv1[2]) + UNSAFE_TODO(hsv2[2]) > 1.0) {
+    diff = -diff;
   }
+
+  return SaturateAndBrighten(hsv2, -0.2f, diff);
 }
 
-SkRect NativeThemeBase::PaintCheckboxRadioCommon(
-    cc::PaintCanvas* canvas,
-    const ColorProvider* color_provider,
+SkColor NativeThemeBase::ControlsAccentColorForState(
     State state,
-    const gfx::Rect& rect,
-    const ButtonExtraParams& extra_params,
-    bool is_checkbox,
-    float border_radius,
     bool dark_mode,
-    PreferredContrast contrast,
-    std::optional<SkColor> accent_color) const {
-  // Use the largest square that fits inside the provided rectangle. This
-  // matches other browsers.
-  gfx::RectF rect_f(rect);
-  const float min_side = std::min(rect_f.width(), rect_f.height());
-  rect_f.ClampToCenteredSize({min_side, min_side});
-  const SkRect skrect = gfx::RectFToSkRect(rect_f);
-  const SkColor border_color =
-      extra_params.checked
-          ? GetAccentOrControlColorForState(accent_color, kAccentColors, state,
-                                            dark_mode, contrast, color_provider)
-          : GetControlColorForState(kBorderColors, state, dark_mode, contrast,
-                                    color_provider);
-
-  // If the square is too small then paint only a square.
-  cc::PaintFlags flags;
-  if (skrect.width() <= 2) {
-    flags.setColor(border_color);
-    canvas->drawRect(skrect, flags);
-    return {};  // Don't draw anything more.
+    const ColorProvider* color_provider) const {
+  ControlColorId color_id;
+  if (state == kHovered) {
+    color_id = kHoveredAccent;
+  } else if (state == kPressed) {
+    color_id = kPressedAccent;
+  } else if (state == kDisabled) {
+    color_id = kDisabledAccent;
+  } else {
+    color_id = kAccent;
   }
+  return GetControlColor(color_id, dark_mode, color_provider);
+}
 
-  // Paint the background.
-  // Shrink the rect slightly to avoid antialiasing artifacts with the border.
-  const auto background_rect =
-      skrect.makeInset(kBorderWidth * 0.2f, kBorderWidth * 0.2f);
-  PaintLightenLayer(canvas, color_provider, background_rect, state,
-                    border_radius, dark_mode, contrast);
-  flags.setAntiAlias(true);
-  flags.setColor(GetControlColorForState(kCheckboxBackgroundColors, state,
-                                         dark_mode, contrast, color_provider));
-  canvas->drawRoundRect(background_rect, border_radius, border_radius, flags);
+SkColor NativeThemeBase::ControlsSliderColorForState(
+    State state,
+    bool dark_mode,
+    const ColorProvider* color_provider) const {
+  ControlColorId color_id;
+  if (state == kHovered) {
+    color_id = kHoveredSlider;
+  } else if (state == kPressed) {
+    color_id = kPressedSlider;
+  } else if (state == kDisabled) {
+    color_id = kDisabledSlider;
+  } else {
+    color_id = kSlider;
+  }
+  return GetControlColor(color_id, dark_mode, color_provider);
+}
 
-  // Paint the border.
-  // Indeterminate and checked checkboxes do not draw a border; they will draw
-  // an accent-colored background instead on the caller side.
-  if (!is_checkbox || (!extra_params.checked && !extra_params.indeterminate)) {
-    flags.setColor(border_color);
-    flags.setStyle(cc::PaintFlags::kStroke_Style);
-    flags.setStrokeWidth(kBorderWidth);
-    canvas->drawRoundRect(skrect.makeInset(kBorderWidth / 2, kBorderWidth / 2),
-                          border_radius, border_radius, flags);
+SkColor NativeThemeBase::ControlsBorderColorForState(
+    State state,
+    bool dark_mode,
+    const ColorProvider* color_provider) const {
+  ControlColorId color_id;
+  if (state == kHovered) {
+    color_id = kHoveredBorder;
+  } else if (state == kPressed) {
+    color_id = kPressedBorder;
+  } else if (state == kDisabled) {
+    color_id = kDisabledBorder;
+  } else {
+    color_id = kBorder;
   }
+  return GetControlColor(color_id, dark_mode, color_provider);
+}
 
-  // Let the caller draw any additional decorations.
-  return skrect;
+SkColor NativeThemeBase::ButtonBorderColorForState(
+    State state,
+    bool dark_mode,
+    const ColorProvider* color_provider) const {
+  ControlColorId color_id;
+  if (state == kHovered) {
+    color_id = kButtonHoveredBorder;
+  } else if (state == kPressed) {
+    color_id = kButtonPressedBorder;
+  } else if (state == kDisabled) {
+    color_id = kButtonDisabledBorder;
+  } else {
+    color_id = kButtonBorder;
+  }
+  return GetControlColor(color_id, dark_mode, color_provider);
+}
+
+SkColor NativeThemeBase::ControlsFillColorForState(
+    State state,
+    bool dark_mode,
+    const ColorProvider* color_provider) const {
+  ControlColorId color_id;
+  if (state == kHovered) {
+    color_id = kHoveredFill;
+  } else if (state == kPressed) {
+    color_id = kPressedFill;
+  } else if (state == kDisabled) {
+    color_id = kDisabledFill;
+  } else {
+    color_id = kFill;
+  }
+  return GetControlColor(color_id, dark_mode, color_provider);
+}
+
+SkColor NativeThemeBase::ButtonFillColorForState(
+    State state,
+    bool dark_mode,
+    const ColorProvider* color_provider) const {
+  ControlColorId color_id;
+  if (state == kHovered) {
+    color_id = kButtonHoveredFill;
+  } else if (state == kPressed) {
+    color_id = kButtonPressedFill;
+  } else if (state == kDisabled) {
+    color_id = kButtonDisabledFill;
+  } else {
+    color_id = kButtonFill;
+  }
+  return GetControlColor(color_id, dark_mode, color_provider);
+}
+
+SkColor NativeThemeBase::ControlsBackgroundColorForState(
+    State state,
+    bool dark_mode,
+    const ColorProvider* color_provider) const {
+  ControlColorId color_id;
+  if (state == kDisabled) {
+    color_id = kDisabledBackground;
+  } else {
+    color_id = kBackground;
+  }
+  return GetControlColor(color_id, dark_mode, color_provider);
+}
+
+SkColor NativeThemeBase::GetControlColor(
+    ControlColorId color_id,
+    bool dark_mode,
+    const ColorProvider* color_provider) const {
+  static constexpr auto kColorMap = base::MakeFixedFlatMap<ControlColorId,
+                                                           ColorId>(
+      {{kBorder, kColorWebNativeControlBorder},
+       {kDisabledBorder, kColorWebNativeControlBorderDisabled},
+       {kHoveredBorder, kColorWebNativeControlBorderHovered},
+       {kPressedBorder, kColorWebNativeControlBorderPressed},
+       {kAccent, kColorWebNativeControlAccent},
+       {kDisabledAccent, kColorWebNativeControlAccentDisabled},
+       {kHoveredAccent, kColorWebNativeControlAccentHovered},
+       {kPressedAccent, kColorWebNativeControlAccentPressed},
+       {kBackground, kColorWebNativeControlBackground},
+       {kDisabledBackground, kColorWebNativeControlBackgroundDisabled},
+       {kFill, kColorWebNativeControlFill},
+       {kDisabledFill, kColorWebNativeControlFillDisabled},
+       {kHoveredFill, kColorWebNativeControlFillHovered},
+       {kPressedFill, kColorWebNativeControlFillPressed},
+       {kLightenLayer, kColorWebNativeControlLightenLayer},
+       {kProgressValue, kColorWebNativeControlProgressValue},
+       {kSlider, kColorWebNativeControlSlider},
+       {kDisabledSlider, kColorWebNativeControlSliderDisabled},
+       {kHoveredSlider, kColorWebNativeControlSliderHovered},
+       {kPressedSlider, kColorWebNativeControlSliderPressed},
+       {kAutoCompleteBackground, kColorWebNativeControlAutoCompleteBackground},
+       {kScrollbarArrowBackground, kColorWebNativeControlScrollbarTrack},
+       {kScrollbarArrowBackgroundHovered,
+        kColorWebNativeControlScrollbarArrowBackgroundHovered},
+       {kScrollbarArrowBackgroundPressed,
+        kColorWebNativeControlScrollbarArrowBackgroundPressed},
+       {kScrollbarArrow, kColorWebNativeControlScrollbarArrowForeground},
+       {kScrollbarArrowHovered, kColorWebNativeControlScrollbarArrowForeground},
+       {kScrollbarArrowPressed,
+        kColorWebNativeControlScrollbarArrowForegroundPressed},
+       {kScrollbarCornerControlColorId, kColorWebNativeControlScrollbarCorner},
+       {kScrollbarTrack, kColorWebNativeControlScrollbarTrack},
+       {kScrollbarThumb, kColorWebNativeControlScrollbarThumb},
+       {kScrollbarThumbHovered, kColorWebNativeControlScrollbarThumbHovered},
+       {kScrollbarThumbInactive, kColorWebNativeControlScrollbarThumbInactive},
+       {kScrollbarThumbPressed, kColorWebNativeControlScrollbarThumbPressed},
+       {kButtonBorder, kColorWebNativeControlButtonBorder},
+       {kButtonDisabledBorder, kColorWebNativeControlButtonBorderDisabled},
+       {kButtonHoveredBorder, kColorWebNativeControlButtonBorderHovered},
+       {kButtonPressedBorder, kColorWebNativeControlButtonBorderPressed},
+       {kButtonFill, kColorWebNativeControlButtonFill},
+       {kButtonDisabledFill, kColorWebNativeControlButtonFillDisabled},
+       {kButtonHoveredFill, kColorWebNativeControlButtonFillHovered},
+       {kButtonPressedFill, kColorWebNativeControlButtonFillPressed}});
+  CHECK(color_provider);
+  return color_provider->GetColor(kColorMap.at(color_id));
+}
+
+void NativeThemeBase::PaintLightenLayer(cc::PaintCanvas* canvas,
+                                        const ColorProvider* color_provider,
+                                        SkRect skrect,
+                                        State state,
+                                        SkScalar border_radius,
+                                        bool dark_mode) const {
+  if (state == kDisabled) {
+    cc::PaintFlags flags;
+    flags.setAntiAlias(true);
+    flags.setStyle(cc::PaintFlags::kFill_Style);
+    // Draw the lighten layer to lighten the background so the translucent
+    // disabled color works regardless of what it's over.
+    flags.setColor(GetControlColor(kLightenLayer, dark_mode, color_provider));
+    canvas->drawRoundRect(skrect, border_radius, border_radius, flags);
+  }
+}
+
+SkRect NativeThemeBase::AlignSliderTrack(
+    const gfx::Rect& slider_rect,
+    const NativeTheme::SliderExtraParams& slider,
+    bool is_value,
+    float track_block_thickness) const {
+  const float kAlignment = track_block_thickness / 2;
+  const float mid_x = slider_rect.x() + slider_rect.width() / 2.0f;
+  const float mid_y = slider_rect.y() + slider_rect.height() / 2.0f;
+  SkRect aligned_rect;
+
+  if (slider.vertical) {
+    const float top = is_value && slider.right_to_left
+                          ? slider_rect.y() + slider.thumb_y + kAlignment
+                          : slider_rect.y();
+    const float bottom = is_value && !slider.right_to_left
+                             ? slider_rect.y() + slider.thumb_y + kAlignment
+                             : slider_rect.bottom();
+    aligned_rect.setLTRB(
+        std::max(float(slider_rect.x()), mid_x - kAlignment), top,
+        std::min(float(slider_rect.right()), mid_x + kAlignment), bottom);
+  } else {
+    const float right = is_value && !slider.right_to_left
+                            ? slider_rect.x() + slider.thumb_x + kAlignment
+                            : slider_rect.right();
+    const float left = is_value && slider.right_to_left
+                           ? slider_rect.x() + slider.thumb_x + kAlignment
+                           : slider_rect.x();
+
+    aligned_rect.setLTRB(
+        left, std::max(float(slider_rect.y()), mid_y - kAlignment), right,
+        std::min(float(slider_rect.bottom()), mid_y + kAlignment));
+  }
+
+  return aligned_rect;
 }
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_base.h b/ui/native_theme/native_theme_base.h
index ab07b3ad003c6..7e560fae2d760 100644
--- a/ui/native_theme/native_theme_base.h
+++ b/ui/native_theme/native_theme_base.h
@@ -5,17 +5,14 @@
 #ifndef UI_NATIVE_THEME_NATIVE_THEME_BASE_H_
 #define UI_NATIVE_THEME_NATIVE_THEME_BASE_H_
 
-#include <array>
 #include <optional>
 
 #include "base/component_export.h"
-#include "base/containers/span.h"
+#include "cc/paint/paint_flags.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/core/SkPath.h"
 #include "third_party/skia/include/core/SkRect.h"
-#include "ui/color/color_id.h"
 #include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/geometry/rect_f.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/native_theme/native_theme.h"
 
@@ -33,19 +30,30 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeBase : public NativeTheme {
   NativeThemeBase(const NativeThemeBase&) = delete;
   NativeThemeBase& operator=(const NativeThemeBase&) = delete;
 
-  // NativeTheme:
+  // NativeTheme implementation:
   gfx::Size GetPartSize(Part part,
                         State state,
-                        const ExtraParams& extra_params) const override;
+                        const ExtraParams& extra) const override;
   float GetBorderRadiusForPart(Part part,
                                float width,
                                float height) const override;
-  SkColor GetScrollbarThumbColor(
-      const ColorProvider* color_provider,
-      State state,
-      const ScrollbarThumbExtraParams& extra_params) const override;
+  void Paint(cc::PaintCanvas* canvas,
+             const ui::ColorProvider* color_provider,
+             Part part,
+             State state,
+             const gfx::Rect& rect,
+             const ExtraParams& extra,
+             bool forced_colors,
+             PreferredColorScheme color_scheme,
+             PreferredContrast contrast,
+             const std::optional<SkColor>& accent_color) const override;
+
+  bool SupportsNinePatch(Part part) const override;
+  gfx::Size GetNinePatchCanvasSize(Part part) const override;
+  gfx::Rect GetNinePatchAperture(Part part) const override;
 
  protected:
+  // Colors for form controls refresh.
   enum ControlColorId {
     kBorder,
     kDisabledBorder,
@@ -55,8 +63,8 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeBase : public NativeTheme {
     kDisabledAccent,
     kHoveredAccent,
     kPressedAccent,
-    kCheckboxBackground,
-    kDisabledCheckboxBackground,
+    kBackground,
+    kDisabledBackground,
     kFill,
     kDisabledFill,
     kHoveredFill,
@@ -67,16 +75,11 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeBase : public NativeTheme {
     kDisabledSlider,
     kHoveredSlider,
     kPressedSlider,
-    kSliderBorder,
-    kHoveredSliderBorder,
-    kPressedSliderBorder,
     kAutoCompleteBackground,
     kScrollbarArrowBackground,
-    kScrollbarArrowBackgroundDisabled,
     kScrollbarArrowBackgroundHovered,
     kScrollbarArrowBackgroundPressed,
     kScrollbarArrow,
-    kScrollbarArrowDisabled,
     kScrollbarArrowHovered,
     kScrollbarArrowPressed,
     // TODO(crbug.com/40242489): kScrollbarCorner overlaps with
@@ -87,6 +90,7 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeBase : public NativeTheme {
     kScrollbarThumb,
     kScrollbarThumbHovered,
     kScrollbarThumbPressed,
+    kScrollbarThumbInactive,
     kButtonBorder,
     kButtonDisabledBorder,
     kButtonHoveredBorder,
@@ -97,105 +101,39 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeBase : public NativeTheme {
     kButtonPressedFill
   };
 
-  static constexpr auto kButtonBorderColors =
-      std::to_array({kButtonDisabledBorder, kButtonHoveredBorder, kButtonBorder,
-                     kButtonPressedBorder});
-
   using NativeTheme::NativeTheme;
   ~NativeThemeBase() override;
 
-  // NativeTheme:
-  void PaintImpl(cc::PaintCanvas* canvas,
-                 const ColorProvider* color_provider,
-                 Part part,
-                 State state,
-                 const gfx::Rect& rect,
-                 const ExtraParams& extra_params,
-                 bool forced_colors,
-                 bool dark_mode,
-                 PreferredContrast contrast,
-                 std::optional<SkColor> accent_color) const override;
-
-  // Returns the size of a vertical scrollbar button. Horizontal scrollbars
-  // transpose this value.
-  //
-  // NOTE: The width here is also assumed to be the track width, so should be
-  // nonzero even if buttons should not be drawn.
-  virtual gfx::Size GetVerticalScrollbarButtonSize() const;
-
-  // Returns the size of a vertical scrollbar thumb. Horizontal scrollbars
-  // transpose this value.
-  virtual gfx::Size GetVerticalScrollbarThumbSize() const;
-
-  // Returns the scrollbar arrow rect, given an arrow button rect of `rect`.
-  virtual gfx::RectF GetArrowRect(const gfx::Rect& rect,
-                                  Part part,
-                                  State state) const;
-
-  virtual SkColor GetControlColor(ControlColorId color_id,
-                                  bool dark_mode,
-                                  PreferredContrast contrast,
-                                  const ColorProvider* color_provider) const;
-
-  // Returns any custom color ID to use based on `state` and `extra_params`. If
-  // this returns null, the default thumb color for the state will be used.
-  virtual std::optional<ColorId> GetScrollbarThumbColorId(
-      State state,
-      const ScrollbarThumbExtraParams& extra_params) const;
-
-  // Returns the amount a hovered or pressed scrollbar part should contrast with
-  // the normal version of that part. Used when there is a custom scrollbar part
-  // color to try and mimic the default behavior.
-  virtual float GetScrollbarPartContrastRatioForState(State state) const;
-
-  virtual void PaintFrameTopArea(
-      cc::PaintCanvas* canvas,
-      State state,
-      const gfx::Rect& rect,
-      const FrameTopAreaExtraParams& extra_params) const;
-
-  virtual void PaintMenuPopupBackground(
-      cc::PaintCanvas* canvas,
-      const ColorProvider* color_provider,
-      const gfx::Size& size,
-      const MenuBackgroundExtraParams& extra_params) const;
-
-  virtual void PaintMenuSeparator(
-      cc::PaintCanvas* canvas,
-      const ColorProvider* color_provider,
-      State state,
-      const gfx::Rect& rect,
-      const MenuSeparatorExtraParams& extra_params) const;
-
-  // Paints arrow buttons for scrollbars and inner spin buttons.
+  // Draw the arrow. Used by scrollbar and inner spin button.
   virtual void PaintArrowButton(
-      cc::PaintCanvas* canvas,
+      cc::PaintCanvas* gc,
       const ColorProvider* color_provider,
       const gfx::Rect& rect,
-      Part part,
+      Part direction,
       State state,
       bool forced_colors,
       bool dark_mode,
       PreferredContrast contrast,
       const ScrollbarArrowExtraParams& extra_params) const;
-
-  virtual void PaintScrollbarThumb(
+  // Paint the scrollbar track. Done before the thumb so that it can contain
+  // alpha.
+  virtual void PaintScrollbarTrack(
       cc::PaintCanvas* canvas,
       const ColorProvider* color_provider,
       Part part,
       State state,
+      const ScrollbarTrackExtraParams& extra_params,
       const gfx::Rect& rect,
-      const ScrollbarThumbExtraParams& extra_params) const;
-
-  virtual void PaintScrollbarTrack(
+      bool forced_colors,
+      PreferredContrast contrast) const;
+  // Draw the scrollbar thumb over the track.
+  virtual void PaintScrollbarThumb(
       cc::PaintCanvas* canvas,
       const ColorProvider* color_provider,
       Part part,
       State state,
-      const ScrollbarTrackExtraParams& extra_params,
       const gfx::Rect& rect,
-      bool forced_colors,
-      PreferredContrast contrast) const;
+      const ScrollbarThumbExtraParams& extra_params) const;
 
   virtual void PaintScrollbarCorner(
       cc::PaintCanvas* canvas,
@@ -204,177 +142,209 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeBase : public NativeTheme {
       const gfx::Rect& rect,
       const ScrollbarTrackExtraParams& extra_params) const;
 
-  // Selects a color from `colors` based on `state`, then returns the physical
-  // color. `colors` must be in the same order as the actual `State` enum.
-  SkColor GetControlColorForState(base::span<const ControlColorId, 4> colors,
-                                  State state,
-                                  bool dark_mode,
-                                  PreferredContrast contrast,
-                                  const ColorProvider* color_provider) const;
-
-  SkColor GetScrollbarArrowBackgroundColor(
-      const ScrollbarArrowExtraParams& extra_params,
-      State state,
-      bool dark_mode,
-      PreferredContrast contrast,
-      const ColorProvider* color_provider) const;
-
-  SkColor GetScrollbarArrowForegroundColor(
-      SkColor bg_color,
-      const ScrollbarArrowExtraParams& extra_params,
-      State state,
-      bool dark_mode,
-      PreferredContrast contrast,
-      const ColorProvider* color_provider) const;
-
-  // For disabled controls, lightens the background so the translucent disabled
-  // color works regardless of what it's over.
-  void PaintLightenLayer(cc::PaintCanvas* canvas,
-                         const ColorProvider* color_provider,
-                         const SkRect& skrect,
-                         State state,
-                         float border_radius,
-                         bool dark_mode,
-                         PreferredContrast contrast) const;
-
-  // Paints arrows for scrollbars and inner spin buttons.
-  void PaintArrow(cc::PaintCanvas* canvas,
-                  const gfx::Rect& rect,
-                  Part part,
-                  State state,
-                  SkColor color) const;
-
- private:
-  friend class NativeThemeBaseTest;
-
-  static constexpr auto kBorderColors =
-      std::to_array({kDisabledBorder, kHoveredBorder, kBorder, kPressedBorder});
-  static constexpr auto kAccentColors =
-      std::to_array({kDisabledAccent, kHoveredAccent, kAccent, kPressedAccent});
-  static constexpr auto kCheckboxBackgroundColors =
-      std::to_array({kDisabledCheckboxBackground, kCheckboxBackground,
-                     kCheckboxBackground, kCheckboxBackground});
-  static constexpr auto kFillColors =
-      std::to_array({kDisabledFill, kHoveredFill, kFill, kPressedFill});
-  static constexpr auto kSliderColors =
-      std::to_array({kDisabledSlider, kHoveredSlider, kSlider, kPressedSlider});
-  static constexpr auto kSliderBorderColors =
-      std::to_array({kDisabledBorder, kHoveredSliderBorder, kSliderBorder,
-                     kPressedSliderBorder});
-
-  static SkPath PathForArrow(const gfx::RectF& rect, Part part);
-
-  // Like `GetControlColorForState()`; however, if `accent_color` is non-null
-  // and `state` is not `kDisabled`, overrides the default colors with computed
-  // ones based on `accent_color`.
-  SkColor GetAccentOrControlColorForState(
-      std::optional<SkColor> accent_color,
-      base::span<const ControlColorId, 4> colors,
-      State state,
-      bool dark_mode,
-      PreferredContrast contrast,
-      const ColorProvider* color_provider) const;
-
-  // Adjusts custom scrollbar button/thumb colors to meet contrast minima. When
-  // `state` is hovered or pressed, `color` (if present) will be adjusted to
-  // contrast with the normal state. If `bg_color` is present, also attempts to
-  // ensure `color` maintains visible contrast with it.
-  std::optional<SkColor> GetContrastingColorForScrollbarPart(
-      std::optional<SkColor> color,
-      std::optional<SkColor> bg_color,
-      State state) const;
-
   void PaintCheckbox(cc::PaintCanvas* canvas,
                      const ColorProvider* color_provider,
                      State state,
                      const gfx::Rect& rect,
-                     const ButtonExtraParams& extra_params,
+                     const ButtonExtraParams& button,
                      bool dark_mode,
-                     PreferredContrast contrast,
-                     std::optional<SkColor> accent_color) const;
-
-  void PaintInnerSpinButton(cc::PaintCanvas* canvas,
-                            const ColorProvider* color_provider,
-                            State state,
-                            gfx::Rect rect,
-                            const InnerSpinButtonExtraParams& extra_params,
-                            bool forced_colors,
-                            bool dark_mode,
-                            PreferredContrast contrast) const;
+                     const std::optional<SkColor>& accent_color) const;
+
+  void PaintRadio(cc::PaintCanvas* canvas,
+                  const ColorProvider* color_provider,
+                  State state,
+                  const gfx::Rect& rect,
+                  const ButtonExtraParams& button,
+                  bool dark_mode,
+                  const std::optional<SkColor>& accent_color) const;
+
+  void PaintButton(cc::PaintCanvas* canvas,
+                   const ColorProvider* color_provider,
+                   State state,
+                   const gfx::Rect& rect,
+                   const ButtonExtraParams& button,
+                   bool dark_mode) const;
+
+  void PaintTextField(cc::PaintCanvas* canvas,
+                      const ColorProvider* color_provider,
+                      State state,
+                      const gfx::Rect& rect,
+                      const TextFieldExtraParams& text,
+                      bool dark_mode) const;
 
   void PaintMenuList(cc::PaintCanvas* canvas,
                      const ColorProvider* color_provider,
                      State state,
                      const gfx::Rect& rect,
-                     const MenuListExtraParams& extra_params,
-                     bool dark_mode,
-                     PreferredContrast contrast) const;
+                     const MenuListExtraParams& menu_list,
+                     bool dark_mode) const;
 
-  void PaintProgressBar(cc::PaintCanvas* canvas,
+  virtual void PaintMenuPopupBackground(
+      cc::PaintCanvas* canvas,
+      const ColorProvider* color_provider,
+      const gfx::Size& size,
+      const MenuBackgroundExtraParams& menu_background) const;
+
+  virtual void PaintMenuSeparator(
+      cc::PaintCanvas* canvas,
+      const ColorProvider* color_provider,
+      State state,
+      const gfx::Rect& rect,
+      const MenuSeparatorExtraParams& menu_separator) const;
+
+  void PaintSliderTrack(cc::PaintCanvas* canvas,
                         const ColorProvider* color_provider,
                         State state,
                         const gfx::Rect& rect,
-                        const ProgressBarExtraParams& extra_params,
+                        const SliderExtraParams& slider,
                         bool dark_mode,
                         PreferredContrast contrast,
-                        std::optional<SkColor> accent_color) const;
-
-  void PaintButton(cc::PaintCanvas* canvas,
-                   const ColorProvider* color_provider,
-                   State state,
-                   const gfx::Rect& rect,
-                   const ButtonExtraParams& extra_params,
-                   bool dark_mode,
-                   PreferredContrast contrast) const;
-
-  void PaintRadio(cc::PaintCanvas* canvas,
-                  const ColorProvider* color_provider,
-                  State state,
-                  const gfx::Rect& rect,
-                  const ButtonExtraParams& extra_params,
-                  bool dark_mode,
-                  PreferredContrast contrast,
-                  std::optional<SkColor> accent_color) const;
+                        const std::optional<SkColor>& accent_color) const;
 
-  void PaintSliderTrack(cc::PaintCanvas* canvas,
+  void PaintSliderThumb(cc::PaintCanvas* canvas,
                         const ColorProvider* color_provider,
                         State state,
                         const gfx::Rect& rect,
-                        const SliderExtraParams& extra_params,
+                        const SliderExtraParams& slider,
                         bool dark_mode,
-                        PreferredContrast contrast,
-                        std::optional<SkColor> accent_color) const;
+                        const std::optional<SkColor>& accent_color) const;
 
-  void PaintSliderThumb(cc::PaintCanvas* canvas,
+  virtual void PaintInnerSpinButton(
+      cc::PaintCanvas* canvas,
+      const ColorProvider* color_provider,
+      State state,
+      const gfx::Rect& rect,
+      const InnerSpinButtonExtraParams& spin_button,
+      bool forced_colors,
+      bool dark_mode,
+      PreferredContrast contrast) const;
+
+  void PaintProgressBar(cc::PaintCanvas* canvas,
                         const ColorProvider* color_provider,
                         State state,
                         const gfx::Rect& rect,
-                        const SliderExtraParams& extra_params,
+                        const ProgressBarExtraParams& progress_bar,
                         bool dark_mode,
                         PreferredContrast contrast,
-                        std::optional<SkColor> accent_color) const;
+                        const std::optional<SkColor>& accent_color) const;
 
-  void PaintTextField(cc::PaintCanvas* canvas,
-                      const ColorProvider* color_provider,
-                      State state,
-                      const gfx::Rect& rect,
-                      const TextFieldExtraParams& extra_params,
-                      bool dark_mode,
-                      PreferredContrast contrast) const;
-
-  // Draws the common elements of checkboxes and radio buttons. Returns the
-  // rectangle within which any additional decorations should be drawn, or empty
-  // if none.
-  SkRect PaintCheckboxRadioCommon(cc::PaintCanvas* canvas,
-                                  const ColorProvider* color_provider,
-                                  State state,
-                                  const gfx::Rect& rect,
-                                  const ButtonExtraParams& extra_params,
-                                  bool is_checkbox,
-                                  float border_radius,
+  virtual void PaintFrameTopArea(
+      cc::PaintCanvas* canvas,
+      State state,
+      const gfx::Rect& rect,
+      const FrameTopAreaExtraParams& frame_top_area) const;
+
+  virtual void PaintLightenLayer(cc::PaintCanvas* canvas,
+                                 const ColorProvider* color_provider,
+                                 SkRect skrect,
+                                 State state,
+                                 SkScalar border_radius,
+                                 bool dark_mode) const;
+
+  // Shrinks checkbox/radio button rect, if necessary, to make room for padding
+  // and drop shadow.
+  // TODO(mohsen): This is needed because checkboxes/radio buttons on Android
+  // have different padding from those on desktop Chrome. Get rid of this when
+  // crbug.com/530746 is resolved.
+  virtual void AdjustCheckboxRadioRectForPadding(SkRect* rect) const;
+
+  void set_scrollbar_button_length(int length) {
+    scrollbar_button_length_ = length;
+  }
+  int scrollbar_button_length() const { return scrollbar_button_length_; }
+
+  SkColor SaturateAndBrighten(SkScalar* hsv,
+                              SkScalar saturate_amount,
+                              SkScalar brighten_amount) const;
+
+  // Paints the arrow used on the scrollbar and spinner.
+  void PaintArrow(cc::PaintCanvas* canvas,
+                  const gfx::Rect& rect,
+                  Part direction,
+                  SkColor color) const;
+  SkPath PathForArrow(const gfx::Rect& bounding_rect, Part direction) const;
+
+  // Returns the color used to draw the arrow.
+  SkColor GetArrowColor(State state,
+                        bool dark_mode,
+                        const ColorProvider* color_provider) const;
+  virtual SkColor GetControlColor(ControlColorId color_id,
+                                  bool dark_mode,
+                                  const ColorProvider* color_provider) const;
+
+  // Adjust the colors set in `extra_params` for scrollbar buttons and thumb
+  // when the parts are hovered or pressed. The function returns a darker or
+  // lighter version of `fg_color` and ensures that it has enough contrast with
+  // `bg_color` (if present) to still be visible. Dark colors will become
+  // lighter, and light colors will become lighter; whether a color is dark is
+  // determined by `color_utils::IsDark()`. When there are no CSS colors, both
+  // `fg_color` and `bg_color` are `std::nullopt` and the function returns
+  // `std::nullopt`.
+  std::optional<SkColor> GetContrastingPressedOrHoveredColor(
+      std::optional<SkColor> color,
+      std::optional<SkColor> bg_color,
+      State state,
+      Part part) const;
+
+  SkColor ControlsAccentColorForState(
+      State state,
+      bool dark_mode,
+      const ColorProvider* color_provider) const;
+  SkColor ControlsSliderColorForState(
+      State state,
+      bool dark_mode,
+      const ColorProvider* color_provider) const;
+  SkColor ButtonBorderColorForState(State state,
+                                    bool dark_mode,
+                                    const ColorProvider* color_provider) const;
+  SkColor ButtonFillColorForState(State state,
                                   bool dark_mode,
-                                  PreferredContrast contrast,
-                                  std::optional<SkColor> accent_color) const;
+                                  const ColorProvider* color_provider) const;
+  SkColor ControlsBorderColorForState(
+      State state,
+      bool dark_mode,
+      const ColorProvider* color_provider) const;
+  SkColor ControlsFillColorForState(State state,
+                                    bool dark_mode,
+                                    const ColorProvider* color_provider) const;
+  virtual float GetContrastRatioForState(State state, Part part) const;
+  // Only scrollbar parts that change colors when hovered are supported.
+  bool SupportedPartsForContrastingColor(Part part) const;
+  int scrollbar_width_ = 15;
+
+ private:
+  friend class NativeThemeAuraTest;
+  friend class NativeThemeBaseTest;
+
+  gfx::Rect BoundingRectForArrow(const gfx::Rect& rect) const;
+
+  SkColor OutlineColor(SkScalar* hsv1, SkScalar* hsv2) const;
+
+  // Paint the common parts of the checkboxes and radio buttons.
+  // border_radius specifies how rounded the corners should be.
+  SkRect PaintCheckboxRadioCommon(
+      cc::PaintCanvas* canvas,
+      const ColorProvider* color_provider,
+      State state,
+      const gfx::Rect& rect,
+      const ButtonExtraParams& button,
+      bool is_checkbox,
+      const SkScalar border_radius,
+      bool dark_mode,
+      const std::optional<SkColor>& accent_color) const;
+
+  SkColor ControlsBackgroundColorForState(
+      State state,
+      bool dark_mode,
+      const ColorProvider* color_provider) const;
+
+  SkRect AlignSliderTrack(const gfx::Rect& slider_rect,
+                          const NativeTheme::SliderExtraParams& slider,
+                          bool is_value,
+                          float track_height) const;
+
+  // The length of the arrow buttons, 0 means no buttons are drawn.
+  int scrollbar_button_length_ = 14;
 };
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_base_unittest.cc b/ui/native_theme/native_theme_base_unittest.cc
index 59213985f3ca3..c142c69a1d3ce 100644
--- a/ui/native_theme/native_theme_base_unittest.cc
+++ b/ui/native_theme/native_theme_base_unittest.cc
@@ -4,155 +4,49 @@
 
 #include "ui/native_theme/native_theme_base.h"
 
-#include <stddef.h>
-#include <stdint.h>
-
 #include <array>
 #include <optional>
-#include <utility>
 
-#include "base/containers/span.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/skia/include/core/SkColor.h"
-#include "third_party/skia/include/core/SkPath.h"
-#include "third_party/skia/include/core/SkPoint.h"
 #include "ui/gfx/color_utils.h"
-#include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/geometry/rect_f.h"
 #include "ui/native_theme/native_theme.h"
 
 namespace ui {
-namespace {
-
-void VerifyTriangle(SkPath path, base::span<const SkPoint> expected_points) {
-  ASSERT_EQ(static_cast<size_t>(path.countPoints()), expected_points.size());
-  for (int i = 0; const SkPoint& expected_point : expected_points) {
-    const SkPoint actual_point = path.getPoint(i++);
-    // TODO(pkasting): Move `cc::PaintOpHelper::ToString(const SkPoint&)` to a
-    // more general location and use `EXPECT_EQ(actual_point, expected_point)`.
-    EXPECT_EQ(actual_point.x(), expected_point.x());
-    EXPECT_EQ(actual_point.y(), expected_point.y());
-  }
-}
-
-}  // namespace
-
-class NativeThemeBaseTest : public ::testing::Test {
- protected:
-  gfx::RectF GetArrowRect(const gfx::Rect& rect) const {
-    return theme_.GetArrowRect(rect, NativeTheme::kScrollbarDownArrow,
-                               NativeTheme::kNormal);
-  }
-
-  SkPath PathForArrow(const gfx::Rect& rect, NativeTheme::Part part) const {
-    return NativeThemeBase::PathForArrow(GetArrowRect(rect), part);
-  }
 
-  float GetScrollbarPartContrastRatio() const {
-    return theme_.GetScrollbarPartContrastRatioForState(
-        NativeTheme::State::kHovered);
-  }
-
-  SkColor GetContrastingColorForScrollbarPart(
-      std::optional<SkColor> color,
-      std::optional<SkColor> bg_color) const {
-    return theme_
-        .GetContrastingColorForScrollbarPart(
-            std::move(color), std::move(bg_color), NativeTheme::State::kHovered)
+class NativeThemeBaseTest : public NativeThemeBase, public testing::Test {
+ public:
+  SkColor GetContrastingPressedOrHoveredColor(
+      SkColor fg,
+      std::optional<SkColor> bg = std::nullopt) {
+    return NativeThemeBase::GetContrastingPressedOrHoveredColor(
+               fg, bg, /*state=*/NativeTheme::State::kHovered,
+               /*part=*/Part::kScrollbarVerticalThumb)
         .value();
   }
-
- private:
-  NativeThemeBase theme_;
+  float GetBaseContrastRatio() {
+    return NativeThemeBase::GetContrastRatioForState(
+        /*state=*/NativeTheme::State::kHovered,
+        /*part=*/Part::kScrollbarVerticalThumb);
+  }
 };
 
-TEST_F(NativeThemeBaseTest, BoundingRectSquare) {
-  EXPECT_EQ(GetArrowRect(gfx::Rect(42, 61, 21, 21)), gfx::RectF(48, 67, 9, 9));
-}
-
-TEST_F(NativeThemeBaseTest, BoundingRectSlightlyRectangular) {
-  // Stretched horizontally.
-  EXPECT_EQ(GetArrowRect(gfx::Rect(42, 61, 25, 20)),
-            gfx::RectF(49, 66, 11, 11));
-
-  // Stretched vertically.
-  EXPECT_EQ(GetArrowRect(gfx::Rect(42, 61, 14, 10)), gfx::RectF(46, 63, 6, 6));
-}
-
-TEST_F(NativeThemeBaseTest, BoundingRectVeryRectangular) {
-  // Stretched horizontally.
-  EXPECT_EQ(GetArrowRect(gfx::Rect(42, 61, 30, 8)), gfx::RectF(53, 61, 8, 8));
-
-  // Stretched vertically.
-  EXPECT_EQ(GetArrowRect(gfx::Rect(42, 61, 6, 44)), gfx::RectF(42, 80, 6, 6));
-}
-
-TEST_F(NativeThemeBaseTest, BoundingRectSnappedToWholePixels) {
-  EXPECT_EQ(GetArrowRect(gfx::Rect(0, 0, 9, 10)).x(), 3);
-  EXPECT_EQ(GetArrowRect(gfx::Rect(0, 0, 10, 9)).y(), 3);
-}
-
-TEST_F(NativeThemeBaseTest, VerticalArrows) {
-  // Up arrow, sized for 1x.
-  VerifyTriangle(
-      PathForArrow(gfx::Rect(100, 200, 17, 17), NativeTheme::kScrollbarUpArrow),
-      {SkPoint::Make(105, 211), SkPoint::Make(112, 211),
-       SkPoint::Make(108.5, 207)});
-
-  // 1.25x, should be larger.
-  VerifyTriangle(
-      PathForArrow(gfx::Rect(50, 70, 21, 21), NativeTheme::kScrollbarUpArrow),
-      {SkPoint::Make(56, 84), SkPoint::Make(65, 84), SkPoint::Make(60.5, 79)});
-
-  // Down arrow is just a flipped up arrow.
-  VerifyTriangle(
-      PathForArrow(gfx::Rect(20, 80, 17, 17), NativeTheme::kScrollbarDownArrow),
-      {SkPoint::Make(25, 86), SkPoint::Make(32, 86), SkPoint::Make(28.5, 90)});
-}
-
-TEST_F(NativeThemeBaseTest, HorizontalArrows) {
-  // Right arrow, sized for 1x.
-  VerifyTriangle(PathForArrow(gfx::Rect(100, 200, 17, 17),
-                              NativeTheme::kScrollbarRightArrow),
-                 {SkPoint::Make(107, 205), SkPoint::Make(107, 212),
-                  SkPoint::Make(111, 208.5)});
-
-  // Button size for 1.25x, should be larger.
-  VerifyTriangle(
-      PathForArrow(gfx::Rect(50, 70, 21, 21),
-                   NativeTheme::kScrollbarRightArrow),
-      {SkPoint::Make(58, 76), SkPoint::Make(58, 85), SkPoint::Make(63, 80.5)});
-
-  // Left arrow is just a flipped right arrow.
-  VerifyTriangle(
-      PathForArrow(gfx::Rect(20, 80, 17, 17), NativeTheme::kScrollbarLeftArrow),
-      {SkPoint::Make(30, 85), SkPoint::Make(30, 92), SkPoint::Make(26, 88.5)});
-}
-
-TEST_F(NativeThemeBaseTest, ArrowForNonSquareButton) {
-  VerifyTriangle(
-      PathForArrow(gfx::Rect(90, 80, 42, 37), NativeTheme::kScrollbarLeftArrow),
-      {SkPoint::Make(116, 89), SkPoint::Make(116, 109),
-       SkPoint::Make(105, 99)});
-}
-
-// Checks that `GetContrastingColorForScrollbarPart()` doesn't modify
-// fully-transparent colors.
-TEST_F(NativeThemeBaseTest, GetContrastingColorTransparent) {
-  static constexpr auto kOpaqueColor = SkColorSetRGB(0xBA, 0x74, 0x74);
-  static constexpr auto kTransparentColor = SkColorSetA(kOpaqueColor, 0x00);
-  EXPECT_EQ(kTransparentColor, GetContrastingColorForScrollbarPart(
-                                   kTransparentColor, kOpaqueColor));
+// Check that `GetContrastingPressedOrHoveredColor` doesn't modify fully
+// transparent colors.
+TEST_F(NativeThemeBaseTest, GetContrastingPressedOrHoveredTransparent) {
+  const SkColor transparent_color = SkColorSetARGB(0x00, 0xBA, 0x74, 0x74);
+  EXPECT_EQ(transparent_color,
+            GetContrastingPressedOrHoveredColor(transparent_color));
 }
 
-// Checks that `GetContrastingColorForScrollbarPart` can adapt to a whole range
-// of luminosity for the colors to modify.
-TEST_F(NativeThemeBaseTest, GetContrastingColorLuminosity) {
+// Tests that the `GetContrastingPressedOrHoveredColor` can adapt to a whole
+// range of luminosity for the colors to modify.
+TEST_F(NativeThemeBaseTest, GetContrastingPressedOrHoveredColor) {
   for (unsigned i = 0; i < 255; i++) {
     const SkColor color = SkColorSetRGB(i, i, i);
     const float luminance = color_utils::GetRelativeLuminance(color);
     const float adjusted_luminance = color_utils::GetRelativeLuminance(
-        GetContrastingColorForScrollbarPart(color, std::nullopt));
+        GetContrastingPressedOrHoveredColor(color));
     if (color_utils::IsDark(color)) {
       EXPECT_GT(adjusted_luminance, luminance);
     } else {
@@ -161,25 +55,25 @@ TEST_F(NativeThemeBaseTest, GetContrastingColorLuminosity) {
   }
 }
 
-// Checks that the returned color never loses contrast against the background
+// Tests that the returned color never loses contrast against the background
 // color.
-TEST_F(NativeThemeBaseTest, GetContrastingColorBackgroundContrast) {
-  for (size_t c = 0; c < 24; c += 8) {
+TEST_F(NativeThemeBaseTest,
+       GetContrastingPressedOrHoveredColorBackgroundContrast) {
+  for (int c = 0; c < 24; c += 8) {
     // Test with Green, Blue and Red.
-    const SkColor bg_color =
-        SkColorSetA(SkColor(uint32_t{0x80} << c), SK_AlphaOPAQUE);
-    for (uint32_t i = 0; i < 255; ++i) {
-      const SkColor adjusted_color = GetContrastingColorForScrollbarPart(
-          SkColorSetA(SkColor(i << c), SK_AlphaOPAQUE), bg_color);
+    const SkColor bg_color = SkColorSetA(SkColor(0x80 << (c)), SK_AlphaOPAQUE);
+    for (U8CPU i = 0; i < 255; i++) {
+      const SkColor adjusted_color = GetContrastingPressedOrHoveredColor(
+          SkColorSetA(SkColor(i << (c)), SK_AlphaOPAQUE), bg_color);
       EXPECT_GT(color_utils::GetContrastRatio(bg_color, adjusted_color),
-                GetScrollbarPartContrastRatio());
+                GetBaseContrastRatio());
     }
   }
 }
 
 // Checks that grayscale colors never lose contrast with the background when it
 // is different shades of gray.
-TEST_F(NativeThemeBaseTest, GetContrastingColorGrayScales) {
+TEST_F(NativeThemeBaseTest, GetContrastingPressedOrHoveredColorGrayScales) {
   static constexpr auto kColors =
       std::to_array({SK_ColorWHITE, SK_ColorLTGRAY, SK_ColorGRAY,
                      SK_ColorDKGRAY, SK_ColorBLACK});
@@ -187,8 +81,8 @@ TEST_F(NativeThemeBaseTest, GetContrastingColorGrayScales) {
     for (const auto background : kColors) {
       const float background_contrast_ratio = color_utils::GetContrastRatio(
           background,
-          GetContrastingColorForScrollbarPart(foreground, background));
-      const float base_contrast_ratio = GetScrollbarPartContrastRatio();
+          GetContrastingPressedOrHoveredColor(foreground, background));
+      const float base_contrast_ratio = GetBaseContrastRatio();
       EXPECT_GE(background_contrast_ratio, base_contrast_ratio);
     }
   }
@@ -196,15 +90,15 @@ TEST_F(NativeThemeBaseTest, GetContrastingColorGrayScales) {
 
 // Checks that transparent foreground colors don't lose contrast against the
 // background when altered.
-TEST_F(NativeThemeBaseTest, GetContrastingColorTransparencies) {
+TEST_F(NativeThemeBaseTest, GetContrastingPressedOrHoveredTransparencies) {
   for (const auto background : {SK_ColorBLACK, SK_ColorWHITE}) {
     for (auto foreground : {SK_ColorRED, SK_ColorGREEN, SK_ColorBLUE}) {
-      for (int i = 1; i < 4; ++i) {
+      for (int i = 1; i < 4; i++) {
         foreground = SkColorSetA(foreground, SK_AlphaOPAQUE * i / 4);
         const float background_contrast_ratio = color_utils::GetContrastRatio(
             background,
-            GetContrastingColorForScrollbarPart(foreground, background));
-        const float base_contrast_ratio = GetScrollbarPartContrastRatio();
+            GetContrastingPressedOrHoveredColor(foreground, background));
+        const float base_contrast_ratio = GetBaseContrastRatio();
         EXPECT_GE(background_contrast_ratio, base_contrast_ratio);
       }
     }
diff --git a/ui/native_theme/native_theme_constants_fluent.h b/ui/native_theme/native_theme_constants_fluent.h
new file mode 100644
index 0000000000000..6c75326bc5aa5
--- /dev/null
+++ b/ui/native_theme/native_theme_constants_fluent.h
@@ -0,0 +1,70 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_NATIVE_THEME_NATIVE_THEME_CONSTANTS_FLUENT_H_
+#define UI_NATIVE_THEME_NATIVE_THEME_CONSTANTS_FLUENT_H_
+
+namespace ui {
+
+constexpr int kFluentScrollbarThumbThickness = 9;
+
+// A sufficiently large value ensures the most round curve for the corners of
+// the scrollbar thumb and overlay buttons.
+constexpr int kFluentScrollbarPartsRadius = 999;
+
+// The value specifies the minimum length the scrollbar thumb can have*.
+// We choose 17px for compatibility reasons with the default scrollbar on the
+// Windows platform.
+//
+// *Please note that when the scrollbar height for the vertical scrollbar
+// (or width for horizontal) is less than [1], the thumb does get smaller
+// until it disappears when the scrollbar size is less than [2].
+//
+// [1] 2 * kFluentScrollbarButtonSideLength + kFluentScrollbarMinimalThumbLength
+// [2] 2 * kFluentScrollbarButtonSideLength + 1
+constexpr int kFluentScrollbarMinimalThumbLength = 17;
+
+// The value represents button height for the vertical scrollbar and width for
+// the horizontal. Another side for the corresponding orientation is the same as
+// the track thickness.
+constexpr int kFluentScrollbarButtonSideLength = 18;
+
+// Arrow rect side length. The height and width of the rect are equal.
+constexpr int kFluentScrollbarArrowRectLength = 9;
+
+// Arrow rect side length when the button is pressed. The height and width of
+// the rect are equal.
+constexpr int kFluentScrollbarPressedArrowRectLength = 8;
+
+// Use this length only when the font that contains arrow icons is not present
+// on the device and the default arrows are painted using SkPath. Since the
+// scrollbar thickness is an even number, we shift the odd rect from the
+// button's center. Also, we can avoid the usage of anti-aliasing, which tends
+// to produce visual defects on specific scales.
+constexpr int kFluentScrollbarPressedArrowRectFallbackLength = 7;
+
+// Offset the arrow icon by this amount off-center, away from the thumb.
+constexpr int kFluentScrollbarArrowOffset = 1;
+
+// The outline width used to paint track and buttons in High Contrast mode.
+constexpr float kFluentScrollbarTrackOutlineWidth = 1.0f;
+
+// The font that supports the drawing of Fluent scrollbar arrow icons.
+// Currently, it's only available on Windows 11 by default.
+constexpr char kFluentScrollbarFont[] = "Segoe Fluent Icons";
+
+// Fluent scrollbar arrow code points.
+constexpr char kFluentScrollbarUpArrow[] = "\uEDDB";
+constexpr char kFluentScrollbarDownArrow[] = "\uEDDC";
+constexpr char kFluentScrollbarLeftArrow[] = "\uEDD9";
+constexpr char kFluentScrollbarRightArrow[] = "\uEDDA";
+
+// Track and button inset to be applied at the time of painting overlay
+// scrollbars. This will yield a 1dp border around the track that is
+// transparent yet interactive.
+constexpr int kFluentPaintedScrollbarTrackInset = 1;
+
+}  // namespace ui
+
+#endif  // UI_NATIVE_THEME_NATIVE_THEME_CONSTANTS_FLUENT_H_
diff --git a/ui/native_theme/native_theme_fluent.cc b/ui/native_theme/native_theme_fluent.cc
index 405a660571933..9de48c1b99da0 100644
--- a/ui/native_theme/native_theme_fluent.cc
+++ b/ui/native_theme/native_theme_fluent.cc
@@ -6,19 +6,18 @@
 
 #include <algorithm>
 #include <cmath>
-#include <optional>
 
 #include "base/check_op.h"
-#include "base/containers/fixed_flat_map.h"
+#include "base/no_destructor.h"
+#include "base/notreached.h"
 #include "base/numerics/safe_conversions.h"
-#include "base/strings/cstring_view.h"
 #include "cc/paint/paint_canvas.h"
 #include "cc/paint/paint_flags.h"
 #include "skia/ext/font_utils.h"
-#include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/core/SkFont.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
 #include "third_party/skia/include/core/SkFontStyle.h"
+#include "third_party/skia/include/core/SkPath.h"
 #include "third_party/skia/include/core/SkRRect.h"
 #include "third_party/skia/include/core/SkRect.h"
 #include "third_party/skia/include/core/SkRefCnt.h"
@@ -28,218 +27,88 @@
 #include "ui/color/color_provider.h"
 #include "ui/gfx/geometry/insets.h"
 #include "ui/gfx/geometry/insets_f.h"
-#include "ui/gfx/geometry/outsets.h"
 #include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/rect_conversions.h"
 #include "ui/gfx/geometry/rect_f.h"
 #include "ui/gfx/geometry/rrect_f.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/geometry/size_f.h"
 #include "ui/gfx/geometry/skia_conversions.h"
-#include "ui/gfx/geometry/vector2d_f.h"
 #include "ui/native_theme/features/native_theme_features.h"
+#include "ui/native_theme/native_theme_constants_fluent.h"
 
 namespace ui {
 
-namespace {
-
-// A sufficiently large value ensures the most round curve for the corners of
-// the scrollbar thumb and overlay buttons.
-constexpr int kScrollbarPartsRadius = 999;
-
-// The outline width used to paint track and buttons in High Contrast mode.
-constexpr float kScrollbarTrackOutlineWidth = 1.0f;
-
-}  // namespace
-
-int NativeThemeFluent::GetPaintedScrollbarTrackInset() const {
-  return 1;
-}
-
-bool NativeThemeFluent::GetArrowIconsAvailable() const {
-  return !!GetArrowIconTypeface();
-}
-
-void NativeThemeFluent::SetArrowIconsAvailableForTesting(bool available) {
-  typeface_ = available ? skia::DefaultTypeface() : nullptr;
-}
-
 NativeThemeFluent::NativeThemeFluent() {
   set_use_overlay_scrollbar(IsFluentOverlayScrollbarEnabled());
+  scrollbar_width_ = kScrollbarThickness;
 }
 
 NativeThemeFluent::~NativeThemeFluent() = default;
 
-gfx::Size NativeThemeFluent::GetVerticalScrollbarButtonSize() const {
-  return gfx::Size(kScrollbarThickness, kScrollbarButtonSideLength);
-}
-
-gfx::Size NativeThemeFluent::GetVerticalScrollbarThumbSize() const {
-  return gfx::Size(9, 17);
-}
-
-gfx::RectF NativeThemeFluent::GetArrowRect(const gfx::Rect& rect,
-                                           Part part,
-                                           State state) const {
-  const bool arrow_icons_available = GetArrowIconsAvailable();
-  int unscaled_arrow_side = 9;
-  if (state == kPressed) {
-    unscaled_arrow_side = arrow_icons_available ? 8 : 7;
-  }
-
-  // Note: Using initializer_list form forces returning by copy, not ref.
-  const auto [min_rect_side, max_rect_side] =
-      std::minmax({rect.width(), rect.height()});
-  const float scale_factor =
-      max_rect_side / static_cast<float>(kScrollbarButtonSideLength);
-  int arrow_side = base::ClampCeil(unscaled_arrow_side * scale_factor);
-
-  gfx::RectF arrow_rect(rect);
-  if (arrow_icons_available) {
-    arrow_rect.ClampToCenteredSize(
-        static_cast<gfx::SizeF>(gfx::Size(arrow_side, arrow_side)));
-  } else {
-    // Add 1px to the side length if the difference between smaller button rect
-    // and arrow side length is odd to keep the arrow rect in the center as well
-    // as use int coordinates. This avoids anti-aliasing.
-    arrow_side += (min_rect_side - arrow_side) % 2;
-    arrow_rect.ClampToCenteredSize(
-        static_cast<gfx::SizeF>(gfx::Size(arrow_side, arrow_side)));
-    arrow_rect.set_origin(
-        {std::floor(arrow_rect.x()), std::floor(arrow_rect.y())});
-  }
-
-  // The end result is a centered arrow rect within the button rect with the
-  // applied offset.
-  const int unscaled_offset =
-      (part == kScrollbarUpArrow || part == kScrollbarLeftArrow) ? -1 : 1;
-  gfx::Vector2dF offset(std::round(unscaled_offset * scale_factor), 0);
-  if (part == kScrollbarUpArrow || part == kScrollbarDownArrow) {
-    offset.Transpose();
-  }
-  return arrow_rect + offset;
-}
-
-std::optional<ColorId> NativeThemeFluent::GetScrollbarThumbColorId(
-    State state,
-    const ScrollbarThumbExtraParams& extra_params) const {
-  return (extra_params.is_thumb_minimal_mode && state != kHovered &&
-          state != kPressed)
-             ? std::make_optional(
-                   kColorWebNativeControlScrollbarThumbOverlayMinimalMode)
-             : std::nullopt;
-}
-
-float NativeThemeFluent::GetScrollbarPartContrastRatioForState(
-    State state) const {
-  return 1.8f;
-}
-
 void NativeThemeFluent::PaintArrowButton(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
     const gfx::Rect& rect,
-    Part part,
+    Part direction,
     State state,
     bool forced_colors,
     bool dark_mode,
     PreferredContrast contrast,
     const ScrollbarArrowExtraParams& extra_params) const {
-  const auto paint_button = [this, canvas, part](const gfx::RectF& paint_rect,
-                                                 cc::PaintFlags paint_flags) {
-    if (!use_overlay_scrollbar()) {
-      canvas->drawRect(gfx::RectFToSkRect(paint_rect), paint_flags);
-      return;
-    }
-
-    SkScalar ul = 0, ll = 0, ur = 0, lr = 0;
-    if (part == kScrollbarUpArrow) {
-      ul = kScrollbarPartsRadius;
-      ur = kScrollbarPartsRadius;
-    } else if (part == kScrollbarDownArrow) {
-      ll = kScrollbarPartsRadius;
-      lr = kScrollbarPartsRadius;
-    } else if (part == kScrollbarLeftArrow) {
-      ul = kScrollbarPartsRadius;
-      ll = kScrollbarPartsRadius;
-    } else if (part == kScrollbarRightArrow) {
-      ur = kScrollbarPartsRadius;
-      lr = kScrollbarPartsRadius;
-    }
-    const gfx::RRectF rrect(paint_rect, ul, ul, ur, ur, lr, lr, ll, ll);
-    paint_flags.setAntiAlias(true);
-    canvas->drawRRect(static_cast<SkRRect>(rrect), paint_flags);
-  };
+  PaintButton(canvas, color_provider, rect, direction, forced_colors, contrast,
+              extra_params);
+  PaintArrow(canvas, color_provider, rect, direction, state, extra_params);
+}
 
-  gfx::RectF button_fill_rect(rect);
-  // Windows native Fluent scrollbars draw a border around the button in forced
-  // colors mode regardless of the contrast of the colors; and the border seems
-  // clearly beneficial in high contrast, especially on platforms that don't
-  // natively do forced colors.
+void NativeThemeFluent::PaintScrollbarTrack(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
+    Part part,
+    State state,
+    const ScrollbarTrackExtraParams& extra_params,
+    const gfx::Rect& rect,
+    bool forced_colors,
+    PreferredContrast contrast) const {
+  gfx::Rect track_fill_rect = rect;
+  // Windows native Fluent scrollbars draw a border in forced colors mode
+  // regardless of the contrast of the colors; and the border seems clearly
+  // beneficial in high contrast, especially on platforms that don't natively do
+  // forced colors.
   if (forced_colors || contrast == PreferredContrast::kMore) {
-    gfx::OutsetsF edge_outsets;
-    if (part == kScrollbarUpArrow) {
-      edge_outsets.set_bottom(kScrollbarTrackOutlineWidth);
-    } else if (part == kScrollbarDownArrow) {
-      edge_outsets.set_top(kScrollbarTrackOutlineWidth);
-    } else if (part == kScrollbarLeftArrow) {
-      edge_outsets.set_right(kScrollbarTrackOutlineWidth);
-    } else if (part == kScrollbarRightArrow) {
-      edge_outsets.set_left(kScrollbarTrackOutlineWidth);
+    gfx::Insets edge_insets;
+    if (part == NativeTheme::Part::kScrollbarHorizontalTrack) {
+      edge_insets.set_left_right(-kFluentScrollbarTrackOutlineWidth,
+                                 -kFluentScrollbarTrackOutlineWidth);
+    } else {
+      edge_insets.set_top_bottom(-kFluentScrollbarTrackOutlineWidth,
+                                 -kFluentScrollbarTrackOutlineWidth);
     }
-    button_fill_rect.Outset(edge_outsets);
+    const gfx::InsetsF outline_insets(kFluentScrollbarTrackOutlineWidth / 2.0f);
 
-    gfx::RectF outline_rect = button_fill_rect;
-    outline_rect.Inset(kScrollbarTrackOutlineWidth / 2.0f);
+    gfx::RectF outline_rect(rect);
+    outline_rect.Inset(outline_insets + gfx::InsetsF(edge_insets));
+
+    const SkColor track_outline_color =
+        color_provider->GetColor(kColorWebNativeControlScrollbarThumb);
 
     cc::PaintFlags outline_flags;
-    outline_flags.setColor(
-        GetScrollbarThumbColor(color_provider, state,
-                               {.is_hovering = extra_params.is_hovering,
-                                .thumb_color = extra_params.thumb_color,
-                                .track_color = extra_params.track_color}));
+    outline_flags.setColor(track_outline_color);
     outline_flags.setStyle(cc::PaintFlags::kStroke_Style);
-    outline_flags.setStrokeWidth(kScrollbarTrackOutlineWidth);
-    paint_button(outline_rect, outline_flags);
-
-    // Adjust the fill rect to not overlap with the outline stroke rect.
-    button_fill_rect.Inset(kScrollbarTrackOutlineWidth);
-  }
+    outline_flags.setStrokeWidth(kFluentScrollbarTrackOutlineWidth);
+    canvas->drawRect(gfx::RectFToSkRect(outline_rect), outline_flags);
 
-  // Paint button background.
-  const SkColor bg_color = GetScrollbarArrowBackgroundColor(
-      extra_params, state, dark_mode, contrast, color_provider);
-  cc::PaintFlags bg_flags;
-  bg_flags.setColor(bg_color);
-  paint_button(button_fill_rect, bg_flags);
-
-  // Paint arrow.
-  const SkColor fg_color = GetScrollbarArrowForegroundColor(
-      bg_color, extra_params, state, dark_mode, contrast, color_provider);
-  if (const auto typeface = GetArrowIconTypeface()) {
-    static constexpr auto kCodePointMap =
-        base::MakeFixedFlatMap<Part, base::cstring_view>(
-            {{kScrollbarDownArrow, "\uEDDC"},
-             {kScrollbarLeftArrow, "\uEDD9"},
-             {kScrollbarRightArrow, "\uEDDA"},
-             {kScrollbarUpArrow, "\uEDDB"}});
-
-    const gfx::RectF bounding_rect = GetArrowRect(rect, part, state);
-    // The bounding rect for an arrow is square, so we can use the width
-    // regardless of the arrow direction.
-    SkFont font(typeface, bounding_rect.width());
-    font.setEdging(SkFont::Edging::kAntiAlias);
-    font.setSubpixel(true);
-
-    cc::PaintFlags fg_flags;
-    fg_flags.setAntiAlias(true);
-    fg_flags.setColor(fg_color);
-    canvas->drawTextBlob(
-        SkTextBlob::MakeFromString(kCodePointMap.at(part).c_str(), font),
-        bounding_rect.x(), bounding_rect.bottom(), fg_flags);
-  } else {
-    // Paint regular triangular arrows if arrow icons are not available.
-    PaintArrow(canvas, rect, part, state, fg_color);
+    // Adjust fill rect to not overlap with the outline stroke rect.
+    constexpr gfx::Insets fill_insets(kFluentScrollbarTrackOutlineWidth);
+    track_fill_rect.Inset(fill_insets + edge_insets);
   }
+  const SkColor track_color =
+      extra_params.track_color.has_value()
+          ? extra_params.track_color.value()
+          : color_provider->GetColor(kColorWebNativeControlScrollbarTrack);
+  cc::PaintFlags flags;
+  flags.setColor(track_color);
+  canvas->drawIRect(gfx::RectToSkIRect(track_fill_rect), flags);
 }
 
 void NativeThemeFluent::PaintScrollbarThumb(
@@ -249,82 +118,327 @@ void NativeThemeFluent::PaintScrollbarThumb(
     State state,
     const gfx::Rect& rect,
     const ScrollbarThumbExtraParams& extra_params) const {
+  DCHECK_NE(state, NativeTheme::kDisabled);
+
   cc::PaintFlags flags;
   flags.setAntiAlias(true);
-  flags.setColor(GetScrollbarThumbColor(color_provider, state, extra_params));
+  flags.setColor(GetScrollbarThumbColor(*color_provider, state, extra_params));
   const SkRect sk_rect = gfx::RectToSkRect(rect);
   if (extra_params.is_web_test) {
-    // Web tests draw the thumb as a square to avoid trivial discrepancies due
-    // to rounding/AA.
+    // Web tests draw the thumb as a square to avoid issues that come with the
+    // differences in calculation of anti-aliasing and rounding in different
+    // platforms.
     canvas->drawRect(sk_rect, flags);
   } else {
-    canvas->drawRRect(SkRRect::MakeRectXY(sk_rect, kScrollbarPartsRadius,
-                                          kScrollbarPartsRadius),
+    canvas->drawRRect(SkRRect::MakeRectXY(sk_rect, kFluentScrollbarPartsRadius,
+                                          kFluentScrollbarPartsRadius),
                       flags);
   }
 }
 
-void NativeThemeFluent::PaintScrollbarTrack(
+gfx::Insets NativeThemeFluent::GetScrollbarSolidColorThumbInsets(
+    Part part) const {
+  // TODO(crbug.com/40213017): We should probably move the thumb rect insetting
+  // logic from blink::ScrollbarThemeFluent::ThumbRect() to here, to make sure
+  // the web UI and the native UI use the same thumb insetting logic.
+  return gfx::Insets();
+}
+
+SkColor NativeThemeFluent::GetScrollbarThumbColor(
+    const ui::ColorProvider& color_provider,
+    State state,
+    const ScrollbarThumbExtraParams& extra_params) const {
+  auto get_color_id = [&] {
+    if (state == NativeTheme::kPressed) {
+      return kColorWebNativeControlScrollbarThumbPressed;
+    } else if (state == NativeTheme::kHovered) {
+      return kColorWebNativeControlScrollbarThumbHovered;
+    } else if (extra_params.is_thumb_minimal_mode) {
+      return kColorWebNativeControlScrollbarThumbOverlayMinimalMode;
+    }
+    return kColorWebNativeControlScrollbarThumb;
+  };
+  return GetContrastingPressedOrHoveredColor(
+             extra_params.thumb_color,
+             extra_params.track_color.value_or(
+                 color_provider.GetColor(kColorWebNativeControlScrollbarTrack)),
+             state, /*part=*/Part::kScrollbarVerticalThumb)
+      .value_or(color_provider.GetColor(get_color_id()));
+}
+
+void NativeThemeFluent::PaintScrollbarCorner(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
-    Part part,
     State state,
-    const ScrollbarTrackExtraParams& extra_params,
     const gfx::Rect& rect,
+    const ScrollbarTrackExtraParams& extra_params) const {
+  cc::PaintFlags flags;
+  const SkColor corner_color =
+      extra_params.track_color.has_value()
+          ? extra_params.track_color.value()
+          : color_provider->GetColor(kColorWebNativeControlScrollbarCorner);
+  flags.setColor(corner_color);
+  canvas->drawIRect(RectToSkIRect(rect), flags);
+}
+
+gfx::Size NativeThemeFluent::GetPartSize(Part part,
+                                         State state,
+                                         const ExtraParams& extra) const {
+  switch (part) {
+    case kScrollbarHorizontalThumb:
+      return gfx::Size(kFluentScrollbarMinimalThumbLength,
+                       kFluentScrollbarThumbThickness);
+    case kScrollbarVerticalThumb:
+      return gfx::Size(kFluentScrollbarThumbThickness,
+                       kFluentScrollbarMinimalThumbLength);
+    case kScrollbarHorizontalTrack:
+      return gfx::Size(0, scrollbar_width_);
+    case kScrollbarVerticalTrack:
+      return gfx::Size(scrollbar_width_, 0);
+    case kScrollbarUpArrow:
+    case kScrollbarDownArrow:
+      return gfx::Size(scrollbar_width_, kFluentScrollbarButtonSideLength);
+    case kScrollbarLeftArrow:
+    case kScrollbarRightArrow:
+      return gfx::Size(kFluentScrollbarButtonSideLength, scrollbar_width_);
+    default:
+      break;
+  }
+
+  return NativeThemeBase::GetPartSize(part, state, extra);
+}
+
+void NativeThemeFluent::PaintButton(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
+    const gfx::Rect& rect,
+    Part direction,
     bool forced_colors,
-    PreferredContrast contrast) const {
-  gfx::Rect track_fill_rect = rect;
-  // See comments in `PaintArrowButton()` re: the condition here.
+    PreferredContrast contrast,
+    const ScrollbarArrowExtraParams& extra_params) const {
+  cc::PaintFlags flags;
+  const SkColor button_color = extra_params.track_color.value_or(
+      color_provider->GetColor(kColorWebNativeControlScrollbarTrack));
+  flags.setColor(button_color);
+  gfx::Rect button_fill_rect = rect;
+  // See comments in `PaintScrollbarTrack()` re: the condition here.
   if (forced_colors || contrast == PreferredContrast::kMore) {
+    const gfx::InsetsF outline_insets(kFluentScrollbarTrackOutlineWidth / 2.0f);
     gfx::Insets edge_insets;
-    if (part == kScrollbarHorizontalTrack) {
-      edge_insets.set_left_right(-kScrollbarTrackOutlineWidth,
-                                 -kScrollbarTrackOutlineWidth);
-    } else {
-      edge_insets.set_top_bottom(-kScrollbarTrackOutlineWidth,
-                                 -kScrollbarTrackOutlineWidth);
+    if (direction == NativeTheme::Part::kScrollbarUpArrow) {
+      edge_insets.set_bottom(-kFluentScrollbarTrackOutlineWidth);
+    } else if (direction == NativeTheme::Part::kScrollbarDownArrow) {
+      edge_insets.set_top(-kFluentScrollbarTrackOutlineWidth);
+    } else if (direction == NativeTheme::Part::kScrollbarLeftArrow) {
+      edge_insets.set_right(-kFluentScrollbarTrackOutlineWidth);
+    } else if (direction == NativeTheme::Part::kScrollbarRightArrow) {
+      edge_insets.set_left(-kFluentScrollbarTrackOutlineWidth);
     }
-    const gfx::InsetsF outline_insets(kScrollbarTrackOutlineWidth / 2.0f);
 
     gfx::RectF outline_rect(rect);
     outline_rect.Inset(outline_insets + gfx::InsetsF(edge_insets));
+    const SkColor arrow_outline_color =
+        color_provider->GetColor(kColorWebNativeControlScrollbarThumb);
 
     cc::PaintFlags outline_flags;
-    outline_flags.setColor(
-        color_provider->GetColor(kColorWebNativeControlScrollbarThumb));
+    outline_flags.setColor(arrow_outline_color);
     outline_flags.setStyle(cc::PaintFlags::kStroke_Style);
-    outline_flags.setStrokeWidth(kScrollbarTrackOutlineWidth);
-    canvas->drawRect(gfx::RectFToSkRect(outline_rect), outline_flags);
+    outline_flags.setStrokeWidth(kFluentScrollbarTrackOutlineWidth);
 
-    // Adjust fill rect to not overlap with the outline stroke rect.
-    track_fill_rect.Inset(gfx::Insets(kScrollbarTrackOutlineWidth) +
-                          edge_insets);
+    if (use_overlay_scrollbar()) {
+      PaintRoundedButton(canvas, gfx::RectFToSkRect(outline_rect),
+                         outline_flags, direction);
+    } else {
+      canvas->drawRect(gfx::RectFToSkRect(outline_rect), outline_flags);
+    }
+
+    // Adjust the fill rect to not overlap with the outline stroke rect.
+    constexpr gfx::Insets fill_insets(kFluentScrollbarTrackOutlineWidth);
+    button_fill_rect.Inset(fill_insets + edge_insets);
   }
 
-  cc::PaintFlags flags;
-  flags.setColor(extra_params.track_color.value_or(
-      color_provider->GetColor(kColorWebNativeControlScrollbarTrack)));
-  canvas->drawIRect(gfx::RectToSkIRect(track_fill_rect), flags);
+  if (use_overlay_scrollbar()) {
+    PaintRoundedButton(canvas, gfx::RectToSkRect(button_fill_rect), flags,
+                       direction);
+  } else {
+    canvas->drawIRect(gfx::RectToSkIRect(button_fill_rect), flags);
+  }
 }
 
-void NativeThemeFluent::PaintScrollbarCorner(
+void NativeThemeFluent::PaintArrow(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
-    State state,
     const gfx::Rect& rect,
-    const ScrollbarTrackExtraParams& extra_params) const {
+    Part part,
+    State state,
+    const ScrollbarArrowExtraParams& extra_params) const {
+  const ColorId arrow_color_id =
+      state == NativeTheme::kPressed || state == NativeTheme::kHovered
+          ? kColorWebNativeControlScrollbarArrowForegroundPressed
+          : kColorWebNativeControlScrollbarArrowForeground;
+  const SkColor arrow_color =
+      GetContrastingPressedOrHoveredColor(
+          extra_params.thumb_color,
+          extra_params.track_color.value_or(
+              color_provider->GetColor(kColorWebNativeControlScrollbarTrack)),
+          state, part)
+          .value_or(color_provider->GetColor(arrow_color_id));
   cc::PaintFlags flags;
-  flags.setColor(extra_params.track_color.value_or(
-      color_provider->GetColor(kColorWebNativeControlScrollbarCorner)));
-  canvas->drawIRect(RectToSkIRect(rect), flags);
-}
+  flags.setColor(arrow_color);
 
-sk_sp<SkTypeface> NativeThemeFluent::GetArrowIconTypeface() const {
   if (!typeface_.has_value()) {
     const sk_sp<SkFontMgr> font_manager(skia::DefaultFontMgr());
-    typeface_ = font_manager->matchFamilyStyle("Segoe Fluent Icons", {});
+    typeface_ = sk_sp<SkTypeface>(
+        font_manager->matchFamilyStyle(kFluentScrollbarFont, SkFontStyle()));
   }
-  return typeface_.value();
+  if (!ArrowIconsAvailable()) {
+    // Paint regular triangular arrows if the font with arrow icons is not
+    // available. GetArrowRect() returns the float rect but it is expected to be
+    // the integer rect in this case.
+    const SkPath path =
+        PathForArrow(ToNearestRect(GetArrowRect(rect, part, state)), part);
+    canvas->drawPath(path, flags);
+    return;
+  }
+
+  const gfx::RectF bounding_rect = GetArrowRect(rect, part, state);
+  // The bounding rect for an arrow is a square, so that we can use the width
+  // despite the arrow direction.
+  CHECK(typeface_.has_value());
+  SkFont font(typeface_.value(), bounding_rect.width());
+  font.setEdging(SkFont::Edging::kAntiAlias);
+  font.setSubpixel(true);
+  flags.setAntiAlias(true);
+  const char* arrow_code_point = GetArrowCodePointForScrollbarPart(part);
+  canvas->drawTextBlob(SkTextBlob::MakeFromString(arrow_code_point, font),
+                       bounding_rect.x(), bounding_rect.bottom(), flags);
+}
+
+gfx::RectF NativeThemeFluent::GetArrowRect(const gfx::Rect& rect,
+                                           Part part,
+                                           State state) const {
+  int min_rect_side, max_rect_side;
+  std::tie(min_rect_side, max_rect_side) =
+      std::minmax(rect.width(), rect.height());
+  const int arrow_side = GetArrowSideLength(state);
+
+  // Calculates the scaling ratio used to determine the arrow rect side length.
+  const float arrow_to_button_side_scale_ratio =
+      arrow_side / static_cast<float>(kFluentScrollbarButtonSideLength);
+  int side_length =
+      base::ClampCeil(max_rect_side * arrow_to_button_side_scale_ratio);
+
+  gfx::RectF arrow_rect(rect);
+  if (ArrowIconsAvailable()) {
+    arrow_rect.ClampToCenteredSize(gfx::SizeF(side_length, side_length));
+  } else {
+    // Add 1px to the side length if the difference between smaller button rect
+    // and arrow side length is odd to keep the arrow rect in the center as well
+    // as use int coordinates. This avoids the usage of anti-aliasing.
+    side_length += (min_rect_side - side_length) % 2;
+    arrow_rect.ClampToCenteredSize(gfx::SizeF(side_length, side_length));
+    arrow_rect.set_origin(
+        gfx::PointF(std::floor(arrow_rect.x()), std::floor(arrow_rect.y())));
+  }
+
+  // The end result is a centered arrow rect within the button rect with the
+  // applied offset.
+  OffsetArrowRect(arrow_rect, part, max_rect_side);
+  return arrow_rect;
+}
+
+int NativeThemeFluent::GetArrowSideLength(State state) const {
+  if (state == NativeTheme::kPressed) {
+    return ArrowIconsAvailable()
+               ? kFluentScrollbarPressedArrowRectLength
+               : kFluentScrollbarPressedArrowRectFallbackLength;
+  }
+
+  return kFluentScrollbarArrowRectLength;
+}
+
+void NativeThemeFluent::OffsetArrowRect(gfx::RectF& arrow_rect,
+                                        Part part,
+                                        int max_rect_side) const {
+  const float scaled_offset =
+      std::round(kFluentScrollbarArrowOffset * max_rect_side /
+                 static_cast<float>(kFluentScrollbarButtonSideLength));
+  switch (part) {
+    case kScrollbarUpArrow:
+      arrow_rect.Offset(0, -scaled_offset);
+      break;
+    case kScrollbarDownArrow:
+      arrow_rect.Offset(0, scaled_offset);
+      break;
+    case kScrollbarLeftArrow:
+      arrow_rect.Offset(-scaled_offset, 0);
+      break;
+    case kScrollbarRightArrow:
+      arrow_rect.Offset(scaled_offset, 0);
+      break;
+    default:
+      NOTREACHED();
+  }
+}
+
+const char* NativeThemeFluent::GetArrowCodePointForScrollbarPart(
+    Part part) const {
+  switch (part) {
+    case Part::kScrollbarUpArrow:
+      return kFluentScrollbarUpArrow;
+    case Part::kScrollbarDownArrow:
+      return kFluentScrollbarDownArrow;
+    case Part::kScrollbarLeftArrow:
+      return kFluentScrollbarLeftArrow;
+    case Part::kScrollbarRightArrow:
+      return kFluentScrollbarRightArrow;
+    default:
+      NOTREACHED();
+  }
+}
+
+int NativeThemeFluent::GetPaintedScrollbarTrackInset() const {
+  return kFluentPaintedScrollbarTrackInset;
+}
+
+float NativeThemeFluent::GetContrastRatioForState(State state,
+                                                  Part part) const {
+  CHECK(SupportedPartsForContrastingColor(part));
+  // Calculated by taking the contrast ratio between the foreground and
+  // background colors.
+  static constexpr float kFluentScrollbarForegroundContrastRatio = 1.8f;
+  return kFluentScrollbarForegroundContrastRatio;
+}
+
+void NativeThemeFluent::PaintRoundedButton(cc::PaintCanvas* canvas,
+                                           SkRect rect,
+                                           cc::PaintFlags paint_flags,
+                                           NativeTheme::Part direction) const {
+  paint_flags.setAntiAlias(true);
+
+  SkScalar upper_left_radius = 0;
+  SkScalar lower_left_radius = 0;
+  SkScalar upper_right_radius = 0;
+  SkScalar lower_right_radius = 0;
+  if (direction == NativeTheme::kScrollbarUpArrow) {
+    upper_left_radius = kFluentScrollbarPartsRadius;
+    upper_right_radius = kFluentScrollbarPartsRadius;
+  } else if (direction == NativeTheme::kScrollbarDownArrow) {
+    lower_left_radius = kFluentScrollbarPartsRadius;
+    lower_right_radius = kFluentScrollbarPartsRadius;
+  } else if (direction == NativeTheme::kScrollbarLeftArrow) {
+    lower_left_radius = kFluentScrollbarPartsRadius;
+    upper_left_radius = kFluentScrollbarPartsRadius;
+  } else if (direction == NativeTheme::kScrollbarRightArrow) {
+    lower_right_radius = kFluentScrollbarPartsRadius;
+    upper_right_radius = kFluentScrollbarPartsRadius;
+  }
+
+  gfx::RRectF rounded_rect(
+      gfx::SkRectToRectF(rect), upper_left_radius, upper_left_radius,
+      upper_right_radius, upper_right_radius, lower_right_radius,
+      lower_right_radius, lower_left_radius, lower_left_radius);
+  canvas->drawRRect(static_cast<SkRRect>(rounded_rect), paint_flags);
 }
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_fluent.h b/ui/native_theme/native_theme_fluent.h
index 8059e21b87418..2651811aa918d 100644
--- a/ui/native_theme/native_theme_fluent.h
+++ b/ui/native_theme/native_theme_fluent.h
@@ -8,22 +8,17 @@
 #include <optional>
 
 #include "base/component_export.h"
-#include "base/no_destructor.h"
 #include "third_party/skia/include/core/SkRefCnt.h"
 #include "ui/gfx/geometry/rect_f.h"
 #include "ui/native_theme/native_theme.h"
 #include "ui/native_theme/native_theme_base.h"
 
-class SkTypeface;
-
-namespace cc {
-class PaintCanvas;
-}
-
 namespace gfx {
 class Rect;
 }
 
+class SkTypeface;
+
 namespace ui {
 
 class ColorProvider;
@@ -36,51 +31,23 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeFluent
   static constexpr int kScrollbarThickness = 15;
   // LINT.ThenChange(//third_party/blink/web_tests/resources/scrollbar-util.js:FluentScrollbarThickness)
 
-  // Button height for the vertical scrollbar or width for the horizontal.
-  static constexpr int kScrollbarButtonSideLength = 18;
+  NativeThemeFluent();
 
   NativeThemeFluent(const NativeThemeFluent&) = delete;
   NativeThemeFluent& operator=(const NativeThemeFluent&) = delete;
 
-  // NativeThemeBase:
-  int GetPaintedScrollbarTrackInset() const override;
-
-  // Gets/sets whether arrow icons are treated as available for metric
-  // computations.
-  bool GetArrowIconsAvailable() const;
-  void SetArrowIconsAvailableForTesting(bool available);
-
- protected:
-  NativeThemeFluent();
   ~NativeThemeFluent() override;
 
-  // NativeThemeBase:
-  gfx::Size GetVerticalScrollbarButtonSize() const override;
-  gfx::Size GetVerticalScrollbarThumbSize() const override;
-  gfx::RectF GetArrowRect(const gfx::Rect& rect,
-                          Part part,
-                          State state) const override;
-  std::optional<ColorId> GetScrollbarThumbColorId(
-      State state,
-      const ScrollbarThumbExtraParams& extra_params) const override;
-  float GetScrollbarPartContrastRatioForState(State state) const override;
   void PaintArrowButton(
       cc::PaintCanvas* canvas,
       const ColorProvider* color_provider,
       const gfx::Rect& rect,
-      Part part,
+      Part direction,
       State state,
       bool forced_colors,
       bool dark_mode,
       PreferredContrast contrast,
       const ScrollbarArrowExtraParams& extra_params) const override;
-  void PaintScrollbarThumb(
-      cc::PaintCanvas* canvas,
-      const ColorProvider* color_provider,
-      Part part,
-      State state,
-      const gfx::Rect& rect,
-      const ScrollbarThumbExtraParams& extra_params) const override;
   void PaintScrollbarTrack(cc::PaintCanvas* canvas,
                            const ColorProvider* color_provider,
                            Part part,
@@ -89,24 +56,79 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeFluent
                            const gfx::Rect& rect,
                            bool forced_colors,
                            PreferredContrast contrast) const override;
+  void PaintScrollbarThumb(
+      cc::PaintCanvas* canvas,
+      const ColorProvider* color_provider,
+      Part part,
+      State state,
+      const gfx::Rect& rect,
+      const ScrollbarThumbExtraParams& extra_params) const override;
+  gfx::Insets GetScrollbarSolidColorThumbInsets(Part part) const override;
+  SkColor GetScrollbarThumbColor(
+      const ui::ColorProvider& color_provider,
+      State state,
+      const ScrollbarThumbExtraParams& extra) const override;
   void PaintScrollbarCorner(
       cc::PaintCanvas* canvas,
       const ColorProvider* color_provider,
       State state,
       const gfx::Rect& rect,
       const ScrollbarTrackExtraParams& extra_params) const override;
+  gfx::Size GetPartSize(Part part,
+                        State state,
+                        const ExtraParams& extra) const override;
+  int GetPaintedScrollbarTrackInset() const override;
+  float GetContrastRatioForState(State state, Part part) const override;
 
  private:
-  friend class base::NoDestructor<NativeThemeFluent>;
   friend class NativeThemeFluentTest;
 
-  // Returns the typeface to use for arrow icons. May return null if the
-  // typeface is not available. Lazily loads the typeface on first call.
-  sk_sp<SkTypeface> GetArrowIconTypeface() const;
-
-  // The typeface which contains arrow icons. Because `GetArrowIconTypeface()`
-  // lazily loads, a null optional means "no load attempted" while a null
-  // pointer inside the optional means "load failed and will not be retried".
+  void PaintButton(cc::PaintCanvas* canvas,
+                   const ColorProvider* color_provider,
+                   const gfx::Rect& rect,
+                   Part direction,
+                   bool forced_colors,
+                   PreferredContrast contrast,
+                   const ScrollbarArrowExtraParams& extra_params) const;
+  void PaintArrow(cc::PaintCanvas* canvas,
+                  const ColorProvider* color_provider,
+                  const gfx::Rect& rect,
+                  Part part,
+                  State state,
+                  const ScrollbarArrowExtraParams& extra_params) const;
+
+  // Calculates and returns the position and dimensions of the scaled arrow rect
+  // within the scrollbar button rect. The goal is to keep the arrow in the
+  // center of the button with the applied kFluentScrollbarArrowOffset. See
+  // OffsetArrowRect method for more details.
+  gfx::RectF GetArrowRect(const gfx::Rect& rect, Part part, State state) const;
+
+  // An arrow rect is a square. Returns the side length based on the state and
+  // the font availability.
+  int GetArrowSideLength(State state) const;
+
+  // By Fluent design, arrow rect is offset from the center to the side opposite
+  // from the track rect border by kFluentScrollbarArrowOffset px.
+  void OffsetArrowRect(gfx::RectF& arrow_rect,
+                       Part part,
+                       int max_arrow_rect_side) const;
+
+  // Returns true if the font with arrow icons is present on the device.
+  bool ArrowIconsAvailable() const {
+    return typeface_.has_value() && typeface_.value().get();
+  }
+
+  const char* GetArrowCodePointForScrollbarPart(Part part) const;
+
+  // Used by Overlay Fluent scrollbars to paint buttons with rounded corners.
+  void PaintRoundedButton(cc::PaintCanvas* canvas,
+                          SkRect rect,
+                          cc::PaintFlags paint_flags,
+                          NativeTheme::Part direction) const;
+
+  // The value stores a shared pointer to SkTypeface with the font family, which
+  // contains arrow icons. The typeface is lazily loaded the first time
+  // PaintArrow is called.
   mutable std::optional<sk_sp<SkTypeface>> typeface_;
 };
 
diff --git a/ui/native_theme/native_theme_fluent_unittest.cc b/ui/native_theme/native_theme_fluent_unittest.cc
index 86475f5f0920e..7d4f9b59e497d 100644
--- a/ui/native_theme/native_theme_fluent_unittest.cc
+++ b/ui/native_theme/native_theme_fluent_unittest.cc
@@ -5,18 +5,16 @@
 #include "ui/native_theme/native_theme_fluent.h"
 
 #include <algorithm>
-#include <array>
 #include <cmath>
 #include <memory>
-#include <string_view>
-#include <utility>
 
-#include "base/strings/strcat.h"
 #include "cc/paint/paint_op.h"
 #include "cc/paint/paint_record.h"
 #include "cc/paint/record_paint_canvas.h"
+#include "skia/ext/font_utils.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/skia/include/core/SkColor.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 #include "ui/color/color_id.h"
 #include "ui/color/color_provider.h"
 #include "ui/color/color_provider_utils.h"
@@ -24,62 +22,14 @@
 #include "ui/gfx/geometry/rect_conversions.h"
 #include "ui/gfx/geometry/rect_f.h"
 #include "ui/native_theme/native_theme.h"
+#include "ui/native_theme/native_theme_constants_fluent.h"
 
 namespace ui {
 
 class NativeThemeFluentTest : public ::testing::Test,
                               public ::testing::WithParamInterface<float> {
  protected:
-  const NativeThemeFluent& theme() const { return theme_; }
-
-  // Mocks the availability of the font for drawing arrow icons.
-  void SetArrowIconsAvailable(bool available) {
-    theme_.SetArrowIconsAvailableForTesting(available);
-    EXPECT_EQ(theme().GetArrowIconsAvailable(), available);
-  }
-
-  void VerifyArrowRect() const {
-    SCOPED_TRACE(::testing::Message() << "Scale: " << ScaleFromDIP());
-    for (const auto& parts_elem :
-         std::to_array<std::pair<NativeTheme::Part, std::string_view>>(
-             {{NativeTheme::kScrollbarDownArrow, "down"},
-              {NativeTheme::kScrollbarLeftArrow, "left"},
-              {NativeTheme::kScrollbarRightArrow, "right"},
-              {NativeTheme::kScrollbarUpArrow, "up"}})) {
-      const NativeTheme::Part part = parts_elem.first;
-      SCOPED_TRACE(base::StrCat({"Arrow direction: ", parts_elem.second}));
-      const gfx::RectF button_rect = ButtonRect(part);
-      for (const auto& states_elem :
-           std::to_array<std::pair<NativeTheme::State, std::string_view>>(
-               {{NativeTheme::kDisabled, "disabled"},
-                {NativeTheme::kHovered, "hovered"},
-                {NativeTheme::kNormal, "normal"},
-                {NativeTheme::kPressed, "pressed"}})) {
-        const NativeTheme::State state = states_elem.first;
-        SCOPED_TRACE(base::StrCat({"Arrow state: ", states_elem.second}));
-        const gfx::RectF arrow_rect =
-            theme().GetArrowRect(gfx::ToNearestRect(button_rect), part, state);
-        VerifyArrowRectCommonDimensions(arrow_rect);
-        if (!theme().GetArrowIconsAvailable()) {
-          VerifyArrowRectIsIntRect(arrow_rect);
-        }
-        VerifyArrowRectIsCentered(button_rect, arrow_rect, part);
-        VerifyArrowRectLengthRatio(button_rect, arrow_rect, state);
-      }
-    }
-  }
-
-  void PaintScrollbarThumb(cc::PaintCanvas* canvas) const {
-    ColorProvider color_provider;
-    theme_.PaintScrollbarThumb(canvas, &color_provider,
-                               NativeTheme::kScrollbarVerticalThumb,
-                               NativeTheme::kNormal, gfx::Rect(15, 100), {});
-  }
-
- private:
-  static float ScaleFromDIP() { return GetParam(); }
-
-  static void VerifyArrowRectCommonDimensions(const gfx::RectF& arrow_rect) {
+  void VerifyArrowRectCommonDimensions(const gfx::RectF& arrow_rect) const {
     EXPECT_FALSE(arrow_rect.IsEmpty());
     EXPECT_EQ(arrow_rect.width(), arrow_rect.height());
     EXPECT_EQ(arrow_rect.width(), std::floor(arrow_rect.width()));
@@ -88,57 +38,87 @@ class NativeThemeFluentTest : public ::testing::Test,
   void VerifyArrowRectIsCentered(const gfx::RectF& button_rect,
                                  const gfx::RectF& arrow_rect,
                                  NativeTheme::Part part) const {
-    const gfx::PointF button_center = button_rect.CenterPoint();
-    const gfx::PointF arrow_center = arrow_rect.CenterPoint();
-    // The arrow is shifted away from center along the length axis by one dp,
-    // rounded to integral px.
-    float expected_shift = std::round(ScaleFromDIP());
-    if (!theme().GetArrowIconsAvailable()) {
-      // For triangular arrows, rect coordinates are snapped to integers, which
-      // may introduce an additional half pixel shift.
-      expected_shift += 0.5f;
-    }
     if (part == NativeTheme::kScrollbarUpArrow ||
         part == NativeTheme::kScrollbarDownArrow) {
-      EXPECT_EQ(button_center.x(), arrow_center.x());
-      EXPECT_NEAR(button_center.y(), arrow_center.y(), expected_shift);
+      EXPECT_EQ(button_rect.CenterPoint().x(), arrow_rect.CenterPoint().x());
+      // Due to the offset the arrow rect is shifted from the center.
+      // See NativeThemeFluent::OffsetArrowRect() for more details. Same below.
+      EXPECT_NEAR(button_rect.CenterPoint().y(), arrow_rect.CenterPoint().y(),
+                  ScaleFromDIP() * 2);
     } else {
-      EXPECT_NEAR(button_center.x(), arrow_center.x(), expected_shift);
-      EXPECT_EQ(button_center.y(), arrow_center.y());
+      EXPECT_EQ(button_rect.CenterPoint().y(), arrow_rect.CenterPoint().y());
+      EXPECT_NEAR(button_rect.CenterPoint().x(), arrow_rect.CenterPoint().x(),
+                  ScaleFromDIP() * 2);
     }
   }
 
-  static void VerifyArrowRectIsIntRect(const gfx::RectF& arrow_rect) {
-    EXPECT_TRUE(gfx::IsNearestRectWithinDistance(arrow_rect, 0.01f));
+  void VerifyArrowRectIsIntRect(const gfx::RectF& arrow_rect) const {
+    if (theme_.ArrowIconsAvailable()) {
+      return;
+    }
+
+    // Verify that an arrow rect with triangular arrows is an integer rect.
+    EXPECT_TRUE(IsNearestRectWithinDistance(arrow_rect, 0.01f));
   }
 
-  static void VerifyArrowRectLengthRatio(const gfx::RectF& button_rect,
-                                         const gfx::RectF& arrow_rect,
-                                         NativeTheme::State state) {
-    const float thickness = std::min(button_rect.width(), button_rect.height());
-    const float arrow_side = arrow_rect.width();  // The arrow is square.
-    if (state == NativeTheme::kPressed) {
-      // Pressed icons are ~0.5 times as thick as the button (precise value
-      // depends on zoom and whether arrow icons are available).
-      EXPECT_GT(arrow_side, thickness / 3.0f);
-      EXPECT_LT(arrow_side, thickness / 1.5f);
+  void VerifyArrowRectLengthRatio(const gfx::RectF& button_rect,
+                                  const gfx::RectF& arrow_rect,
+                                  NativeTheme::State state) const {
+    const int smaller_button_side =
+        std::min(button_rect.width(), button_rect.height());
+    if (state == NativeTheme::kNormal) {
+      // Default state arrows are slightly bigger than the half of the button's
+      // smaller side (track thickness).
+      EXPECT_GT(arrow_rect.width(), smaller_button_side / 2.0f);
+      EXPECT_LT(arrow_rect.width(), smaller_button_side);
     } else {
-      // Non-pressed arrows are ~0.6 times as thick as the button.
-      EXPECT_GT(arrow_side, thickness / 2.0f);
-      EXPECT_LT(arrow_side, thickness);
+      EXPECT_GT(arrow_rect.width(), smaller_button_side / 3.0f);
+      EXPECT_LT(arrow_rect.width(), smaller_button_side / 1.5f);
+    }
+  }
+
+  void VerifyArrowRect() const {
+    for (auto const& part :
+         {NativeTheme::kScrollbarUpArrow, NativeTheme::kScrollbarLeftArrow}) {
+      const gfx::RectF button_rect(ButtonRect(part));
+      for (auto const& state : {NativeTheme::kNormal, NativeTheme::kPressed}) {
+        const gfx::RectF arrow_rect =
+            theme_.GetArrowRect(ToNearestRect(button_rect), part, state);
+        VerifyArrowRectCommonDimensions(arrow_rect);
+        VerifyArrowRectIsIntRect(arrow_rect);
+        VerifyArrowRectIsCentered(button_rect, arrow_rect, part);
+        VerifyArrowRectLengthRatio(button_rect, arrow_rect, state);
+      }
     }
   }
 
   gfx::RectF ButtonRect(NativeTheme::Part part) const {
-    gfx::Rect rect({}, theme().GetVerticalScrollbarButtonSize());
-    if (part == NativeTheme::kScrollbarLeftArrow ||
-        part == NativeTheme::kScrollbarRightArrow) {
-      rect.Transpose();
+    const int button_length =
+        base::ClampFloor(kFluentScrollbarButtonSideLength * ScaleFromDIP());
+    const int track_thickness = base::ClampFloor(
+        NativeThemeFluent::kScrollbarThickness * ScaleFromDIP());
+
+    if (part == NativeTheme::kScrollbarUpArrow ||
+        part == NativeTheme::kScrollbarDownArrow) {
+      return gfx::RectF(0, 0, track_thickness, button_length);
+    }
+
+    return gfx::RectF(0, 0, button_length, track_thickness);
+  }
+
+  float ScaleFromDIP() const { return GetParam(); }
+
+  // Mocks the availability of the font for drawing arrow icons.
+  void SetArrowIconsAvailable(bool enabled) {
+    if (enabled) {
+      theme_.typeface_ = skia::DefaultTypeface();
+      EXPECT_TRUE(theme_.ArrowIconsAvailable());
+    } else {
+      theme_.typeface_ = nullptr;
+      EXPECT_FALSE(theme_.ArrowIconsAvailable());
     }
-    return gfx::RectF(gfx::ScaleToEnclosedRect(rect, ScaleFromDIP()));
   }
 
- private:
   NativeThemeFluent theme_;
 };
 
@@ -149,20 +129,28 @@ TEST_P(NativeThemeFluentTest, VerifyArrowRectWithTriangularArrows) {
   VerifyArrowRect();
 }
 
-// Verify the dimensions of an arrow rect with arrow icons for a given button
-// rect depending on the arrow direction and state.
+// Verify the dimensions of an arrow rect with arrow icons for a given
+// button rect depending on the arrow direction and state.
 TEST_P(NativeThemeFluentTest, VerifyArrowRectWithArrowIcons) {
   SetArrowIconsAvailable(true);
   VerifyArrowRect();
 }
 
-// Verify that the thumb paint function draws a round rectangle. Generally,
-// `NativeThemeFluent::Paint*()` functions are covered by Blink's web tests; but
-// in web tests we render the thumbs as squares instead of pill-shaped. This
-// test ensures we don't lose coverage on the PaintOp called to draw the thumb.
+// Verify that the thumb paint function draws a round rectangle.
+// Generally, NativeThemeFluent::Paint* functions are covered by
+// Blink's web tests; but in web tests we render the thumbs as squares
+// instead of pill-shaped. This test ensures we don't lose coverage on the
+// PaintOp called to draw the thumb.
 TEST_F(NativeThemeFluentTest, PaintThumbRoundedCorners) {
   cc::RecordPaintCanvas canvas;
-  PaintScrollbarThumb(&canvas);
+  ColorProvider color_provider;
+  constexpr gfx::Rect kRect(15, 100);
+  // `is_web_test` is `false` by default.
+  const NativeTheme::ScrollbarThumbExtraParams extra_params;
+  theme_.PaintScrollbarThumb(&canvas, &color_provider,
+                             /*part=*/NativeTheme::kScrollbarVerticalThumb,
+                             /*state=*/NativeTheme::kNormal, kRect,
+                             extra_params);
   EXPECT_EQ(canvas.TotalOpCount(), 1u);
   EXPECT_EQ(canvas.ReleaseAsRecord().GetFirstOp().GetType(),
             cc::PaintOpType::kDrawRRect);
@@ -171,59 +159,47 @@ TEST_F(NativeThemeFluentTest, PaintThumbRoundedCorners) {
 // Verify that GetThumbColor returns the correct color given the scrollbar state
 // and extra params.
 TEST_F(NativeThemeFluentTest, GetThumbColor) {
-  const std::unique_ptr<ColorProvider> color_provider =
+  const std::unique_ptr<ui::ColorProvider> color_provider =
       CreateDefaultColorProviderForBlink(/*dark_mode=*/false);
+  NativeTheme::ScrollbarThumbExtraParams extra_params;
+  const auto scrollbar_color = [&](auto state) {
+    return theme_.GetScrollbarThumbColor(*color_provider, state, extra_params);
+  };
+
+  const SkColor normal_thumb_color =
+      color_provider->GetColor(kColorWebNativeControlScrollbarThumb);
+  const SkColor hovered_thumb_color =
+      color_provider->GetColor(kColorWebNativeControlScrollbarThumbHovered);
+  const SkColor pressed_thumb_color =
+      color_provider->GetColor(kColorWebNativeControlScrollbarThumbPressed);
+  const SkColor minimal_thumb_color = color_provider->GetColor(
+      kColorWebNativeControlScrollbarThumbOverlayMinimalMode);
+  static constexpr SkColor css_color = SK_ColorRED;
 
   // When there are no extra params set, the colors should be the ones that
   // correspond to the ColorId.
-  EXPECT_EQ(color_provider->GetColor(kColorWebNativeControlScrollbarThumb),
-            theme().GetScrollbarThumbColor(color_provider.get(),
-                                           NativeTheme::kNormal, {}));
-  const auto hovered_thumb_color =
-      color_provider->GetColor(kColorWebNativeControlScrollbarThumbHovered);
-  EXPECT_EQ(hovered_thumb_color,
-            theme().GetScrollbarThumbColor(color_provider.get(),
-                                           NativeTheme::kHovered, {}));
-  const auto pressed_thumb_color =
-      color_provider->GetColor(kColorWebNativeControlScrollbarThumbPressed);
-  EXPECT_EQ(pressed_thumb_color,
-            theme().GetScrollbarThumbColor(color_provider.get(),
-                                           NativeTheme::kPressed, {}));
+  EXPECT_EQ(normal_thumb_color, scrollbar_color(NativeTheme::kNormal));
+  EXPECT_EQ(hovered_thumb_color, scrollbar_color(NativeTheme::kHovered));
+  EXPECT_EQ(pressed_thumb_color, scrollbar_color(NativeTheme::kPressed));
 
   // When the thumb is being painted in minimal mode, the normal state should
   // return the minimal mode's transparent color while the other states remain
   // unaffected.
-  static constexpr NativeTheme::ScrollbarThumbExtraParams kMinimalParams = {
-      .is_thumb_minimal_mode = true};
-  EXPECT_EQ(color_provider->GetColor(
-                kColorWebNativeControlScrollbarThumbOverlayMinimalMode),
-            theme().GetScrollbarThumbColor(
-                color_provider.get(), NativeTheme::kNormal, kMinimalParams));
-  EXPECT_EQ(hovered_thumb_color,
-            theme().GetScrollbarThumbColor(
-                color_provider.get(), NativeTheme::kHovered, kMinimalParams));
-  EXPECT_EQ(pressed_thumb_color,
-            theme().GetScrollbarThumbColor(
-                color_provider.get(), NativeTheme::kPressed, kMinimalParams));
+  extra_params.is_thumb_minimal_mode = true;
+  EXPECT_EQ(minimal_thumb_color, scrollbar_color(NativeTheme::kNormal));
+  EXPECT_EQ(hovered_thumb_color, scrollbar_color(NativeTheme::kHovered));
+  EXPECT_EQ(pressed_thumb_color, scrollbar_color(NativeTheme::kPressed));
 
   // When there is a css color set in the extra params, we modify the color
   // when it is hovered or pressed to signal the change in state.
-  static constexpr auto kCssColor = SK_ColorGREEN;
-  static constexpr NativeTheme::ScrollbarThumbExtraParams kColorParams = {
-      .thumb_color = kCssColor};
-  EXPECT_EQ(kCssColor,
-            theme().GetScrollbarThumbColor(color_provider.get(),
-                                           NativeTheme::kNormal, kColorParams));
-  EXPECT_NE(kCssColor,
-            theme().GetScrollbarThumbColor(
-                color_provider.get(), NativeTheme::kHovered, kColorParams));
-  EXPECT_NE(kCssColor,
-            theme().GetScrollbarThumbColor(
-                color_provider.get(), NativeTheme::kPressed, kColorParams));
+  extra_params.thumb_color = css_color;
+  EXPECT_EQ(css_color, scrollbar_color(NativeTheme::kNormal));
+  EXPECT_NE(css_color, scrollbar_color(NativeTheme::kHovered));
+  EXPECT_NE(css_color, scrollbar_color(NativeTheme::kPressed));
 }
 
 INSTANTIATE_TEST_SUITE_P(All,
                          NativeThemeFluentTest,
-                         ::testing::Values(1.0f, 1.25f, 1.5f, 1.75f, 2.0f));
+                         ::testing::Values(1.f, 1.25f, 1.5f, 1.75f, 2.f));
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_mac.h b/ui/native_theme/native_theme_mac.h
index 9cfe45793cb72..2a17cc2a754d5 100644
--- a/ui/native_theme/native_theme_mac.h
+++ b/ui/native_theme/native_theme_mac.h
@@ -8,51 +8,147 @@
 #include "base/component_export.h"
 #include "base/no_destructor.h"
 #include "ui/gfx/geometry/size.h"
+#include "ui/native_theme/native_theme_aura.h"
 #include "ui/native_theme/native_theme_base.h"
 
 namespace ui {
 
 class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeMac : public NativeThemeBase {
  public:
+  static const int kButtonCornerRadius = 3;
+
+  // Type of gradient to use on a button background. Use HIGHLIGHTED for the
+  // default button of a window and all combobox controls, but only when the
+  // window is active.
+  enum class ButtonBackgroundType {
+    DISABLED,
+    HIGHLIGHTED,
+    NORMAL,
+    PRESSED,
+    COUNT
+  };
+
   NativeThemeMac(const NativeThemeMac&) = delete;
   NativeThemeMac& operator=(const NativeThemeMac&) = delete;
 
-  // The minimum size in px for the thumb, given device scale factor `scale`.
-  // Exposed publicly for testing.
-  static gfx::Size GetThumbMinSize(bool horizontal, float scale);
+  // NativeTheme:
+  SkColor GetSystemButtonPressedColor(SkColor base_color) const override;
+  PreferredContrast CalculatePreferredContrast() const override;
 
   // NativeThemeBase:
-  SkColor GetSystemButtonPressedColor(SkColor base_color) const override;
+  void Paint(cc::PaintCanvas* canvas,
+             const ColorProvider* color_provider,
+             Part part,
+             State state,
+             const gfx::Rect& rect,
+             const ExtraParams& extra,
+             bool forced_colors,
+             PreferredColorScheme color_scheme,
+             PreferredContrast contrast,
+             const std::optional<SkColor>& accent_color) const override;
+  void PaintMenuPopupBackground(
+      cc::PaintCanvas* canvas,
+      const ColorProvider* color_provider,
+      const gfx::Size& size,
+      const MenuBackgroundExtraParams& menu_background) const override;
   void PaintMenuItemBackground(
       cc::PaintCanvas* canvas,
       const ColorProvider* color_provider,
       State state,
       const gfx::Rect& rect,
-      const MenuItemExtraParams& extra_params) const override;
+      const MenuItemExtraParams& menu_item) const override;
+  void PaintMacScrollbarThumb(cc::PaintCanvas* canvas,
+                              Part part,
+                              State state,
+                              const gfx::Rect& rect,
+                              const ScrollbarExtraParams& scroll_thumb,
+                              bool dark_mode) const;
+  // Paint the track. |track_bounds| is the bounds for the track.
+  void PaintMacScrollBarTrackOrCorner(cc::PaintCanvas* canvas,
+                                      Part part,
+                                      State state,
+                                      const ScrollbarExtraParams& extra_params,
+                                      const gfx::Rect& rect,
+                                      bool dark_mode,
+                                      bool is_corner) const;
+
+  // Paints the styled button shape used for default controls on Mac. The basic
+  // style is used for dialog buttons, comboboxes, and tabbed pane tabs.
+  // Depending on the control part being drawn, the left or the right side can
+  // be given rounded corners.
+  static void PaintStyledGradientButton(cc::PaintCanvas* canvas,
+                                        const gfx::Rect& bounds,
+                                        ButtonBackgroundType type,
+                                        bool round_left,
+                                        bool round_right,
+                                        bool focus);
+
+  // Returns the minimum size for the thumb. We will not inset the thumb if it
+  // will be smaller than this size. The scale parameter should be the device
+  // scale factor.
+  static gfx::Size GetThumbMinSize(bool vertical, float scale);
 
  protected:
+  friend class NativeTheme;
+  friend class base::NoDestructor<NativeThemeMac>;
+
   NativeThemeMac();
   ~NativeThemeMac() override;
 
-  // NativeThemeBase:
-  void PaintImpl(cc::PaintCanvas* canvas,
-                 const ColorProvider* color_provider,
-                 Part part,
-                 State state,
-                 const gfx::Rect& rect,
-                 const ExtraParams& extra_params,
-                 bool forced_colors,
-                 bool dark_mode,
-                 PreferredContrast contrast,
-                 std::optional<SkColor> accent_color) const override;
-  void PaintMenuPopupBackground(
-      cc::PaintCanvas* canvas,
-      const ColorProvider* color_provider,
-      const gfx::Size& size,
-      const MenuBackgroundExtraParams& extra_params) const override;
-
  private:
-  friend class base::NoDestructor<NativeThemeMac>;
+  // Because this header is #included from C++ source, we can't use Obj-C here.
+  // Instead the Obj-C members are defined entirely in the .mm.
+  struct ObjCMembers;
+
+  // Paint the selected menu item background, and a border for emphasis when in
+  // high contrast.
+  void PaintSelectedMenuItem(cc::PaintCanvas* canvas,
+                             const ColorProvider* color_provider,
+                             const gfx::Rect& rect,
+                             const MenuItemExtraParams& extra_params) const;
+
+  void PaintScrollBarTrackGradient(cc::PaintCanvas* canvas,
+                                   const gfx::Rect& rect,
+                                   const ScrollbarExtraParams& extra_params,
+                                   bool is_corner,
+                                   bool dark_mode) const;
+  void PaintScrollbarTrackInnerBorder(cc::PaintCanvas* canvas,
+                                      const gfx::Rect& rect,
+                                      const ScrollbarExtraParams& extra_params,
+                                      bool is_corner,
+                                      bool dark_mode) const;
+  void PaintScrollbarTrackOuterBorder(cc::PaintCanvas* canvas,
+                                      const gfx::Rect& rect,
+                                      const ScrollbarExtraParams& extra_params,
+                                      bool is_corner,
+                                      bool dark_mode) const;
+
+  void InitializeDarkModeStateAndObserver();
+
+  enum ScrollbarPart {
+    kThumb,
+    kTrack,
+    kTrackInnerBorder,
+    kTrackOuterBorder,
+  };
+
+  std::optional<SkColor> GetScrollbarColor(
+      ScrollbarPart part,
+      bool dark_mode,
+      const ScrollbarExtraParams& extra_params) const;
+
+  int ScrollbarTrackBorderWidth(float scale_from_dip) const {
+    constexpr float border_width = 1.0f;
+    return scale_from_dip * border_width;
+  }
+
+  // The amount the thumb is inset from the ends and the inside edge of track
+  // border.
+  int GetScrollbarThumbInset(bool is_overlay, float scale_from_dip) const {
+    return scale_from_dip * (is_overlay ? 2.0f : 3.0f);
+  }
+
+  std::unique_ptr<ObjCMembers> objc_members_;
 };
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_mac.mm b/ui/native_theme/native_theme_mac.mm
index db0ca5631324f..684c6d196d8e3 100644
--- a/ui/native_theme/native_theme_mac.mm
+++ b/ui/native_theme/native_theme_mac.mm
@@ -4,16 +4,17 @@
 
 #include "ui/native_theme/native_theme_mac.h"
 
+#import <Cocoa/Cocoa.h>
 #include <CoreFoundation/CoreFoundation.h>
 #include <MediaAccessibility/MediaAccessibility.h>
+#include <stddef.h>
 
 #include <algorithm>
-#include <array>
 #include <optional>
 #include <variant>
 #include <vector>
 
-#include "base/numerics/safe_conversions.h"
+#include "base/no_destructor.h"
 #include "cc/paint/paint_canvas.h"
 #include "cc/paint/paint_flags.h"
 #include "cc/paint/paint_shader.h"
@@ -31,25 +32,146 @@
 #include "ui/gfx/geometry/skia_conversions.h"
 #include "ui/native_theme/native_theme.h"
 
-namespace ui {
+namespace {
+
+ui::NativeTheme::PreferredColorScheme GetPreferredColorScheme() {
+  NSAppearanceName appearance =
+      [NSApp.effectiveAppearance bestMatchFromAppearancesWithNames:@[
+        NSAppearanceNameAqua, NSAppearanceNameDarkAqua
+      ]];
+  return [appearance isEqual:NSAppearanceNameDarkAqua]
+             ? ui::NativeTheme::PreferredColorScheme::kDark
+             : ui::NativeTheme::PreferredColorScheme::kLight;
+}
+
+bool PrefersReducedTransparency() {
+  return NSWorkspace.sharedWorkspace
+      .accessibilityDisplayShouldReduceTransparency;
+}
+
+bool IsHighContrast() {
+  return NSWorkspace.sharedWorkspace.accessibilityDisplayShouldIncreaseContrast;
+}
+
+bool InvertedColors() {
+  return NSWorkspace.sharedWorkspace.accessibilityDisplayShouldInvertColors;
+}
+
+}  // namespace
+
+// Helper object to respond to light mode/dark mode changeovers.
+@interface EffectiveAppearanceObserver : NSObject
+@end
+
+@implementation EffectiveAppearanceObserver {
+  void (^_handler)() __strong;
+}
+
+- (instancetype)initWithHandler:(void (^)())handler {
+  self = [super init];
+  if (self) {
+    _handler = handler;
+    [NSApp addObserver:self
+            forKeyPath:@"effectiveAppearance"
+               options:0
+               context:nullptr];
+  }
+  return self;
+}
+
+- (void)dealloc {
+  [NSApp removeObserver:self forKeyPath:@"effectiveAppearance"];
+}
+
+- (void)observeValueForKeyPath:(NSString*)forKeyPath
+                      ofObject:(id)object
+                        change:(NSDictionary*)change
+                       context:(void*)context {
+  _handler();
+}
+
+@end
 
 namespace {
 
-bool IsHorizontal(NativeTheme::ScrollbarOrientation orientation) {
-  return orientation == NativeTheme::ScrollbarOrientation::kHorizontal;
+// Helper to make indexing an array by an enum class easier.
+template <class KEY, class VALUE>
+struct EnumArray {
+  VALUE& operator[](const KEY& key) { return array[static_cast<size_t>(key)]; }
+  VALUE array[static_cast<size_t>(KEY::COUNT)];
+};
+
+}  // namespace
+
+namespace ui {
+
+// static
+bool NativeTheme::SystemDarkModeSupported() {
+  return true;
 }
 
-int ScrollbarTrackBorderWidth(float scale_factor) {
-  constexpr int kBorderWidth = 1;
-  return base::ClampFloor(kBorderWidth * scale_factor);
+struct NativeThemeMac::ObjCMembers {
+  id __strong display_accessibility_notification_token;
+  EffectiveAppearanceObserver* __strong appearance_observer;
+};
+
+NativeThemeAura::PreferredContrast NativeThemeMac::CalculatePreferredContrast()
+    const {
+  return IsHighContrast() ? NativeThemeAura::PreferredContrast::kMore
+                          : NativeThemeAura::PreferredContrast::kNoPreference;
+}
+
+void NativeThemeMac::Paint(cc::PaintCanvas* canvas,
+                           const ColorProvider* color_provider,
+                           Part part,
+                           State state,
+                           const gfx::Rect& rect,
+                           const ExtraParams& extra,
+                           bool forced_colors,
+                           PreferredColorScheme color_scheme,
+                           PreferredContrast contrast,
+                           const std::optional<SkColor>& accent_color) const {
+  // For `color_scheme`, `kNoPreference` means "use current".
+  const bool dark_mode =
+      color_scheme == PreferredColorScheme::kDark ||
+      (color_scheme == PreferredColorScheme::kNoPreference &&
+       preferred_color_scheme() == PreferredColorScheme::kDark);
+
+  if (rect.IsEmpty()) {
+    return;
+  }
+
+  switch (part) {
+    case kScrollbarHorizontalThumb:
+    case kScrollbarVerticalThumb:
+      PaintMacScrollbarThumb(canvas, part, state, rect,
+                             std::get<ScrollbarExtraParams>(extra), dark_mode);
+      break;
+    case kScrollbarHorizontalTrack:
+    case kScrollbarVerticalTrack:
+      PaintMacScrollBarTrackOrCorner(canvas, part, state,
+                                     std::get<ScrollbarExtraParams>(extra),
+                                     rect, dark_mode, false);
+      break;
+    case kScrollbarCorner:
+      PaintMacScrollBarTrackOrCorner(canvas, part, state,
+                                     std::get<ScrollbarExtraParams>(extra),
+                                     rect, dark_mode, true);
+      break;
+    default:
+      NativeThemeBase::Paint(canvas, color_provider, part, state, rect, extra,
+                             forced_colors, color_scheme, contrast,
+                             accent_color);
+      break;
+  }
 }
 
 void ConstrainInsets(int old_width, int min_width, int* left, int* right) {
-  const int requested_total_inset = *left + *right;
+  int requested_total_inset = *left + *right;
   if (requested_total_inset == 0) {
     return;
   }
-  const int max_total_inset = old_width - min_width;
+  int max_total_inset = old_width - min_width;
   if (requested_total_inset < max_total_inset) {
     return;
   }
@@ -66,285 +188,366 @@ void ConstrainInsets(int old_width, int min_width, int* left, int* right) {
   *left = max_total_inset - *right;
 }
 
-void CaptionSettingsChangedNotificationCallback(CFNotificationCenterRef,
-                                                void*,
-                                                CFStringRef,
-                                                const void*,
-                                                CFDictionaryRef) {
-  NativeTheme::GetInstanceForWeb()->NotifyOnCaptionStyleUpdated();
-}
-
-// These functions are called from the renderer process through the scrollbar
-// drawing functions. Due to this, they cannot use any of the dynamic NS system
-// colors.
-// TODO(pkasting): Consider whether these colors should instead go in a
-// Mac-specific color mixer, which would mean scrollbars in web content would
-// get these colors instead of Aura defaults.
-
-SkColor GetMacScrollbarThumbColor(
-    bool dark_mode,
-    const NativeTheme::ScrollbarExtraParams& extra_params) {
-  if (extra_params.thumb_color.has_value()) {
-    return extra_params.thumb_color.value();
-  }
-  if (extra_params.is_overlay) {
-    return dark_mode ? SkColorSetARGB(0x80, 0xFF, 0xFF, 0xFF)
-                     : SkColorSetARGB(0x80, 0, 0, 0);
-  }
-  if (extra_params.is_hovering) {
-    return dark_mode ? SkColorSetRGB(0x93, 0x93, 0x93)
-                     : SkColorSetARGB(0x80, 0, 0, 0);
-  }
-  return dark_mode ? SkColorSetRGB(0x6B, 0x6B, 0x6B)
-                   : SkColorSetARGB(0x3A, 0, 0, 0);
-}
-
-template <bool inner_border>
-SkColor GetMacScrollbarTrackBorderColor(
-    bool dark_mode,
-    const NativeTheme::ScrollbarExtraParams& extra_params) {
-  if (extra_params.track_color.has_value()) {
-    return extra_params.track_color.value();
-  }
-  if constexpr (inner_border) {
-    if (extra_params.is_overlay) {
-      return dark_mode ? SkColorSetARGB(0x33, 0xE5, 0xE5, 0xE5)
-                       : SkColorSetARGB(0xF9, 0xDF, 0xDF, 0xDF);
-    }
-    return dark_mode ? SkColorSetRGB(0x3D, 0x3D, 0x3D)
-                     : SkColorSetRGB(0xE8, 0xE8, 0xE8);
-  } else {
-    if (extra_params.is_overlay) {
-      return dark_mode ? SkColorSetARGB(0x28, 0xD8, 0xD8, 0xD8)
-                       : SkColorSetARGB(0xC6, 0xE8, 0xE8, 0xE8);
-    }
-    return dark_mode ? SkColorSetRGB(0x51, 0x51, 0x51)
-                     : SkColorSetRGB(0xED, 0xED, 0xED);
-  }
+void ConstrainedInset(gfx::Rect* rect,
+                      gfx::Size min_size,
+                      gfx::Insets initial_insets) {
+  int inset_left = initial_insets.left();
+  int inset_right = initial_insets.right();
+  int inset_top = initial_insets.top();
+  int inset_bottom = initial_insets.bottom();
+
+  ConstrainInsets(rect->width(), min_size.width(), &inset_left, &inset_right);
+  ConstrainInsets(rect->height(), min_size.height(), &inset_top, &inset_bottom);
+  rect->Inset(
+      gfx::Insets::TLBR(inset_top, inset_left, inset_bottom, inset_right));
 }
 
-void PaintMacScrollbarThumb(
+void NativeThemeMac::PaintMacScrollBarTrackOrCorner(
     cc::PaintCanvas* canvas,
-    NativeTheme::Part part,
-    NativeTheme::State state,
+    Part part,
+    State state,
+    const ScrollbarExtraParams& extra_params,
     const gfx::Rect& rect,
-    const NativeTheme::ScrollbarExtraParams& extra_params,
-    bool dark_mode) {
-  // Compute the bounds for the rounded rect for the thumb from the bounds of
-  // the thumb.
-  gfx::Rect bounds(rect);
-  {
-    // Shrink the thumb evenly in length and girth to fit within the track.
-    const int base_inset = base::ClampRound((extra_params.is_overlay ? 2 : 3) *
-                                            extra_params.scale_from_dip);
-    int inset_left = base_inset, inset_right = base_inset,
-        inset_top = base_inset, inset_bottom = base_inset;
-
-    // Also shrink the thumb in girth to not touch the border.
-    const bool horizontal = IsHorizontal(extra_params.orientation);
-    (horizontal ? inset_top : inset_left) +=
-        ScrollbarTrackBorderWidth(extra_params.scale_from_dip);
-
-    const gfx::Size min_size = NativeThemeMac::GetThumbMinSize(
-        horizontal, extra_params.scale_from_dip);
-    ConstrainInsets(bounds.width(), min_size.width(), &inset_left,
-                    &inset_right);
-    ConstrainInsets(bounds.height(), min_size.height(), &inset_top,
-                    &inset_bottom);
-    bounds.Inset(
-        gfx::Insets::TLBR(inset_top, inset_left, inset_bottom, inset_right));
+    bool dark_mode,
+    bool is_corner) const {
+  if (is_corner && extra_params.is_overlay) {
+    return;
   }
-
-  const SkScalar radius = std::min(bounds.width(), bounds.height());
-
-  cc::PaintFlags flags;
-  flags.setAntiAlias(true);
-  flags.setColor(GetMacScrollbarThumbColor(dark_mode, extra_params));
-  gfx::Canvas(canvas, 1.0f).DrawRoundRect(bounds, radius, flags);
+  PaintScrollBarTrackGradient(canvas, rect, extra_params, is_corner, dark_mode);
+  PaintScrollbarTrackInnerBorder(canvas, rect, extra_params, is_corner,
+                                 dark_mode);
+  PaintScrollbarTrackOuterBorder(canvas, rect, extra_params, is_corner,
+                                 dark_mode);
 }
 
-void PaintScrollBarTrackGradient(
+void NativeThemeMac::PaintScrollBarTrackGradient(
     cc::PaintCanvas* canvas,
     const gfx::Rect& rect,
-    const NativeTheme::ScrollbarExtraParams& extra_params,
+    const ScrollbarExtraParams& extra_params,
     bool is_corner,
-    bool dark_mode) {
-  cc::PaintFlags flags;
-  if (extra_params.track_color.has_value()) {
-    flags.setAntiAlias(true);
-    flags.setColor(extra_params.track_color.value());
+    bool dark_mode) const {
+  gfx::Canvas paint_canvas(canvas, 1.0f);
+  // Select colors.
+  std::vector<SkColor4f> gradient_colors;
+  if (extra_params.is_overlay) {
+    if (dark_mode) {
+      gradient_colors = {SkColor4f{0.847f, 0.847f, 0.847f, 0.157f},
+                         SkColor4f{0.8f, 0.8f, 0.8f, 0.149f},
+                         SkColor4f{0.8f, 0.8f, 0.8f, 0.149f},
+                         SkColor4f{0.8f, 0.8f, 0.8f, 0.149f}};
+    } else {
+      gradient_colors = {SkColor4f{0.973f, 0.973f, 0.973f, 0.776f},
+                         SkColor4f{0.973f, 0.973f, 0.973f, 0.761f},
+                         SkColor4f{0.973f, 0.973f, 0.973f, 0.761f},
+                         SkColor4f{0.973f, 0.973f, 0.973f, 0.761f}};
+    }
   } else {
-    // Set the gradient direction.
-    std::array<SkPoint, 2> gradient_bounds;
-    const SkPoint origin = gfx::PointToSkPoint(rect.origin());
-    if (is_corner) {
-      if (extra_params.orientation ==
-          NativeTheme::ScrollbarOrientation::kVerticalOnRight) {
-        gradient_bounds = {origin, gfx::PointToSkPoint(rect.bottom_right())};
-      } else {
-        gradient_bounds = {gfx::PointToSkPoint(rect.top_right()),
-                           gfx::PointToSkPoint(rect.bottom_left())};
-      }
+    // Non-overlay scroller track colors are not transparent. On Safari, they
+    // are, but on all other macOS applications they are not.
+    if (dark_mode) {
+      gradient_colors = {SkColor4f{0.176f, 0.176f, 0.176f, 1.0f},
+                         SkColor4f{0.169f, 0.169f, 0.169f, 1.0f}};
     } else {
-      if (IsHorizontal(extra_params.orientation)) {
-        gradient_bounds = {origin, gfx::PointToSkPoint(rect.top_right())};
-      } else {
-        gradient_bounds = {origin, gfx::PointToSkPoint(rect.bottom_left())};
-      }
+      gradient_colors = {SkColor4f{0.98f, 0.98f, 0.98f, 1.0f},
+                         SkColor4f{0.98f, 0.98f, 0.98f, 1.0f}};
     }
+  }
 
-    // Select colors.
-    std::vector<SkColor4f> gradient_colors;
-    if (extra_params.is_overlay) {
-      if (dark_mode) {
-        gradient_colors = {SkColor4f{0.847f, 0.847f, 0.847f, 0.157f},
-                           SkColor4f{0.8f, 0.8f, 0.8f, 0.149f},
-                           SkColor4f{0.8f, 0.8f, 0.8f, 0.149f},
-                           SkColor4f{0.8f, 0.8f, 0.8f, 0.149f}};
-      } else {
-        gradient_colors = {SkColor4f{0.973f, 0.973f, 0.973f, 0.776f},
-                           SkColor4f{0.973f, 0.973f, 0.973f, 0.761f},
-                           SkColor4f{0.973f, 0.973f, 0.973f, 0.761f},
-                           SkColor4f{0.973f, 0.973f, 0.973f, 0.761f}};
-      }
+  // Set the gradient direction.
+  std::vector<SkPoint> gradient_bounds;
+  if (is_corner) {
+    if (extra_params.orientation == ScrollbarOrientation::kVerticalOnRight) {
+      gradient_bounds = {gfx::PointToSkPoint(rect.origin()),
+                         gfx::PointToSkPoint(rect.bottom_right())};
     } else {
-      // On Safari non-overlay scrollbar track colors are transparent, but on
-      // all other macOS applications they are not.
-      if (dark_mode) {
-        gradient_colors = {SkColor4f{0.176f, 0.176f, 0.176f, 1.0f},
-                           SkColor4f{0.169f, 0.169f, 0.169f, 1.0f}};
-      } else {
-        gradient_colors = {SkColor4f{0.98f, 0.98f, 0.98f, 1.0f},
-                           SkColor4f{0.98f, 0.98f, 0.98f, 1.0f}};
-      }
+      gradient_bounds = {gfx::PointToSkPoint(rect.top_right()),
+                         gfx::PointToSkPoint(rect.bottom_left())};
     }
+  } else {
+    if (extra_params.orientation == ScrollbarOrientation::kHorizontal) {
+      gradient_bounds = {gfx::PointToSkPoint(rect.origin()),
+                         gfx::PointToSkPoint(rect.top_right())};
+    } else {
+      gradient_bounds = {gfx::PointToSkPoint(rect.origin()),
+                         gfx::PointToSkPoint(rect.bottom_left())};
+    }
+  }
 
+  // And draw.
+  cc::PaintFlags flags;
+  std::optional<SkColor> track_color =
+      GetScrollbarColor(ScrollbarPart::kTrack, dark_mode, extra_params);
+  if (track_color.has_value()) {
+    flags.setAntiAlias(true);
+    flags.setStyle(cc::PaintFlags::kFill_Style);
+    flags.setColor(track_color.value());
+  } else {
     flags.setShader(cc::PaintShader::MakeLinearGradient(
         gradient_bounds.data(), gradient_colors.data(), nullptr,
         gradient_colors.size(), SkTileMode::kClamp));
   }
-
-  gfx::Canvas(canvas, 1.0f).DrawRect(rect, flags);
+  paint_canvas.DrawRect(rect, flags);
 }
 
-void PaintScrollbarTrackInnerBorder(
+void NativeThemeMac::PaintScrollbarTrackInnerBorder(
     cc::PaintCanvas* canvas,
     const gfx::Rect& rect,
-    const NativeTheme::ScrollbarExtraParams& extra_params,
+    const ScrollbarExtraParams& extra_params,
     bool is_corner,
-    bool dark_mode) {
+    bool dark_mode) const {
+  gfx::Canvas paint_canvas(canvas, 1.0f);
+
   // Compute the rect for the border.
   gfx::Rect inner_border(rect);
-  const int border_width =
-      ScrollbarTrackBorderWidth(extra_params.scale_from_dip);
-  if (extra_params.orientation ==
-      NativeTheme::ScrollbarOrientation::kVerticalOnLeft) {
-    inner_border.set_x(rect.right() - border_width);
+  if (extra_params.orientation == ScrollbarOrientation::kVerticalOnLeft) {
+    inner_border.set_x(rect.right() -
+                       ScrollbarTrackBorderWidth(extra_params.scale_from_dip));
   }
-  const bool horizontal = IsHorizontal(extra_params.orientation);
-  if (is_corner || horizontal) {
-    inner_border.set_height(border_width);
+  if (is_corner ||
+      extra_params.orientation == ScrollbarOrientation::kHorizontal) {
+    inner_border.set_height(
+        ScrollbarTrackBorderWidth(extra_params.scale_from_dip));
   }
-  if (is_corner || !horizontal) {
-    inner_border.set_width(border_width);
+  if (is_corner ||
+      extra_params.orientation != ScrollbarOrientation::kHorizontal) {
+    inner_border.set_width(
+        ScrollbarTrackBorderWidth(extra_params.scale_from_dip));
   }
 
+  // And draw.
   cc::PaintFlags flags;
-  flags.setColor(
-      GetMacScrollbarTrackBorderColor<true>(dark_mode, extra_params));
-  gfx::Canvas(canvas, 1.0f).DrawRect(inner_border, flags);
+  SkColor inner_border_color =
+      GetScrollbarColor(ScrollbarPart::kTrackInnerBorder, dark_mode,
+                        extra_params)
+          .value();
+  flags.setColor(inner_border_color);
+  paint_canvas.DrawRect(inner_border, flags);
 }
 
-void PaintScrollbarTrackOuterBorder(
+void NativeThemeMac::PaintScrollbarTrackOuterBorder(
     cc::PaintCanvas* canvas,
     const gfx::Rect& rect,
-    const NativeTheme::ScrollbarExtraParams& extra_params,
+    const ScrollbarExtraParams& extra_params,
     bool is_corner,
-    bool dark_mode) {
+    bool dark_mode) const {
   gfx::Canvas paint_canvas(canvas, 1.0f);
-
   cc::PaintFlags flags;
-  flags.setColor(
-      GetMacScrollbarTrackBorderColor<false>(dark_mode, extra_params));
+  SkColor outer_border_color =
+      GetScrollbarColor(ScrollbarPart::kTrackOuterBorder, dark_mode,
+                        extra_params)
+          .value();
+  flags.setColor(outer_border_color);
 
   // Draw the horizontal outer border.
-  const bool horizontal = IsHorizontal(extra_params.orientation);
-  const int border_width =
-      ScrollbarTrackBorderWidth(extra_params.scale_from_dip);
-  if (is_corner || horizontal) {
+  if (is_corner ||
+      extra_params.orientation == ScrollbarOrientation::kHorizontal) {
     gfx::Rect outer_border(rect);
-    outer_border.set_y(rect.bottom() - border_width);
-    outer_border.set_height(border_width);
+    outer_border.set_height(
+        ScrollbarTrackBorderWidth(extra_params.scale_from_dip));
+    outer_border.set_y(rect.bottom() -
+                       ScrollbarTrackBorderWidth(extra_params.scale_from_dip));
     paint_canvas.DrawRect(outer_border, flags);
   }
 
   // Draw the vertical outer border.
-  if (is_corner || !horizontal) {
+  if (is_corner ||
+      extra_params.orientation != ScrollbarOrientation::kHorizontal) {
     gfx::Rect outer_border(rect);
-    if (extra_params.orientation ==
-        NativeTheme::ScrollbarOrientation::kVerticalOnRight) {
-      outer_border.set_x(rect.right() - border_width);
+    outer_border.set_width(
+        ScrollbarTrackBorderWidth(extra_params.scale_from_dip));
+    if (extra_params.orientation == ScrollbarOrientation::kVerticalOnRight) {
+      outer_border.set_x(rect.right() - ScrollbarTrackBorderWidth(
+                                            extra_params.scale_from_dip));
     }
-    outer_border.set_width(border_width);
     paint_canvas.DrawRect(outer_border, flags);
   }
 }
 
-void PaintMacScrollBarTrackOrCorner(
+gfx::Size NativeThemeMac::GetThumbMinSize(bool vertical, float scale) {
+  const int kLength = 18 * scale;
+  const int kGirth = 6 * scale;
+
+  return vertical ? gfx::Size(kGirth, kLength) : gfx::Size(kLength, kGirth);
+}
+
+void NativeThemeMac::PaintMacScrollbarThumb(
     cc::PaintCanvas* canvas,
-    const NativeTheme::ScrollbarExtraParams& extra_params,
+    Part part,
+    State state,
     const gfx::Rect& rect,
-    bool dark_mode,
-    bool is_corner) {
-  if (is_corner && extra_params.is_overlay) {
-    return;
+    const ScrollbarExtraParams& scroll_thumb,
+    bool dark_mode) const {
+  gfx::Canvas paint_canvas(canvas, 1.0f);
+
+  // Compute the bounds for the rounded rect for the thumb from the bounds of
+  // the thumb.
+  gfx::Rect bounds(rect);
+  {
+    // Shrink the thumb evenly in length and girth to fit within the track.
+    gfx::Insets thumb_insets(GetScrollbarThumbInset(
+        scroll_thumb.is_overlay, scroll_thumb.scale_from_dip));
+
+    // Also shrink the thumb in girth to not touch the border.
+    if (scroll_thumb.orientation == ScrollbarOrientation::kHorizontal) {
+      thumb_insets.set_top(
+          thumb_insets.top() +
+          ScrollbarTrackBorderWidth(scroll_thumb.scale_from_dip));
+      ConstrainedInset(&bounds,
+                       GetThumbMinSize(false, scroll_thumb.scale_from_dip),
+                       thumb_insets);
+    } else {
+      thumb_insets.set_left(
+          thumb_insets.left() +
+          ScrollbarTrackBorderWidth(scroll_thumb.scale_from_dip));
+      ConstrainedInset(&bounds,
+                       GetThumbMinSize(true, scroll_thumb.scale_from_dip),
+                       thumb_insets);
+    }
   }
-  PaintScrollBarTrackGradient(canvas, rect, extra_params, is_corner, dark_mode);
-  PaintScrollbarTrackInnerBorder(canvas, rect, extra_params, is_corner,
-                                 dark_mode);
-  PaintScrollbarTrackOuterBorder(canvas, rect, extra_params, is_corner,
-                                 dark_mode);
+
+  // Draw.
+  cc::PaintFlags flags;
+  flags.setAntiAlias(true);
+  flags.setStyle(cc::PaintFlags::kFill_Style);
+  SkColor thumb_color =
+      GetScrollbarColor(ScrollbarPart::kThumb, dark_mode, scroll_thumb).value();
+  flags.setColor(thumb_color);
+  const SkScalar radius = std::min(bounds.width(), bounds.height());
+  paint_canvas.DrawRoundRect(bounds, radius, flags);
 }
 
-}  // namespace
+std::optional<SkColor> NativeThemeMac::GetScrollbarColor(
+    ScrollbarPart part,
+    bool dark_mode,
+    const ScrollbarExtraParams& extra_params) const {
+  // This function is called from the renderer process through the scrollbar
+  // drawing functions. Due to this, it cannot use any of the dynamic NS system
+  // colors.
+  if (part == ScrollbarPart::kThumb) {
+    if (extra_params.thumb_color.has_value()) {
+      return extra_params.thumb_color.value();
+    }
+    if (extra_params.is_overlay) {
+      return dark_mode ? SkColorSetARGB(0x80, 0xFF, 0xFF, 0xFF)
+                       : SkColorSetARGB(0x80, 0, 0, 0);
+    }
 
-// static
-gfx::Size NativeThemeMac::GetThumbMinSize(bool horizontal, float scale) {
-  gfx::Size size = gfx::ScaleToRoundedSize({6, 18}, scale);
-  if (horizontal) {
-    size.Transpose();
+    if (dark_mode) {
+      return extra_params.is_hovering ? SkColorSetRGB(0x93, 0x93, 0x93)
+                                      : SkColorSetRGB(0x6B, 0x6B, 0x6B);
+    }
+
+    return extra_params.is_hovering ? SkColorSetARGB(0x80, 0, 0, 0)
+                                    : SkColorSetARGB(0x3A, 0, 0, 0);
+  } else if (part == ScrollbarPart::kTrackInnerBorder) {
+    if (extra_params.track_color.has_value()) {
+      return extra_params.track_color.value();
+    }
+
+    if (extra_params.is_overlay) {
+      return dark_mode ? SkColorSetARGB(0x33, 0xE5, 0xE5, 0xE5)
+                       : SkColorSetARGB(0xF9, 0xDF, 0xDF, 0xDF);
+    }
+
+    return dark_mode ? SkColorSetRGB(0x3D, 0x3D, 0x3D)
+                     : SkColorSetRGB(0xE8, 0xE8, 0xE8);
+  } else if (part == ScrollbarPart::kTrackOuterBorder) {
+    if (extra_params.track_color.has_value()) {
+      return extra_params.track_color.value();
+    }
+    if (extra_params.is_overlay) {
+      return dark_mode ? SkColorSetARGB(0x28, 0xD8, 0xD8, 0xD8)
+                       : SkColorSetARGB(0xC6, 0xE8, 0xE8, 0xE8);
+    }
+
+    return dark_mode ? SkColorSetRGB(0x51, 0x51, 0x51)
+                     : SkColorSetRGB(0xED, 0xED, 0xED);
+  } else if (part == ScrollbarPart::kTrack) {
+    if (extra_params.track_color.has_value()) {
+      return extra_params.track_color.value();
+    }
   }
-  return size;
+
+  return std::nullopt;
 }
 
 SkColor NativeThemeMac::GetSystemButtonPressedColor(SkColor base_color) const {
+  // TODO crbug.com/1003612: This should probably be replaced with a color
+  // transform.
   // Mac has a different "pressed button" styling because it doesn't use
   // ripples.
-  // TODO(crbug.com/40098660): This should probably be replaced with a color
-  // transform.
   return color_utils::GetResultingPaintColor(SkColorSetA(SK_ColorBLACK, 0x10),
                                              base_color);
 }
 
+void NativeThemeMac::PaintMenuPopupBackground(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
+    const gfx::Size& size,
+    const MenuBackgroundExtraParams& menu_background) const {
+  DCHECK(color_provider);
+  cc::PaintFlags flags;
+  flags.setAntiAlias(true);
+  flags.setColor(color_provider->GetColor(kColorMenuBackground));
+  const SkScalar radius = SkIntToScalar(menu_background.corner_radius);
+  SkRect rect = gfx::RectToSkRect(gfx::Rect(size));
+  canvas->drawRoundRect(rect, radius, radius, flags);
+}
+
 void NativeThemeMac::PaintMenuItemBackground(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
     State state,
     const gfx::Rect& rect,
-    const MenuItemExtraParams& extra_params) const {
-  if (state != kHovered) {
-    return;
+    const MenuItemExtraParams& menu_item) const {
+  switch (state) {
+    case NativeTheme::kNormal:
+    case NativeTheme::kDisabled:
+      // Draw nothing over the regular background.
+      break;
+    case NativeTheme::kHovered:
+      PaintSelectedMenuItem(canvas, color_provider, rect, menu_item);
+      break;
+    default:
+      NOTREACHED();
   }
+}
 
-  CHECK(color_provider);
-  cc::PaintFlags flags;
-  flags.setAntiAlias(true);
-  flags.setColor(color_provider->GetColor(kColorMenuItemBackgroundSelected));
-  const SkScalar radius = SkIntToScalar(extra_params.corner_radius);
-  canvas->drawRoundRect(gfx::RectToSkRect(rect), radius, radius, flags);
+void CaptionSettingsChangedNotificationCallback(CFNotificationCenterRef,
+                                                void*,
+                                                CFStringRef,
+                                                const void*,
+                                                CFDictionaryRef) {
+  NativeTheme::GetInstanceForWeb()->NotifyOnCaptionStyleUpdated();
 }
 
 NativeThemeMac::NativeThemeMac() {
+  objc_members_ = std::make_unique<ObjCMembers>();
+
+  InitializeDarkModeStateAndObserver();
+
+  set_prefers_reduced_transparency(PrefersReducedTransparency());
+  set_inverted_colors(InvertedColors());
+  if (!IsForcedHighContrast()) {
+    SetPreferredContrast(CalculatePreferredContrast());
+  }
+  __block auto theme = this;
+  objc_members_->display_accessibility_notification_token =
+      [NSWorkspace.sharedWorkspace.notificationCenter
+          addObserverForName:
+              NSWorkspaceAccessibilityDisplayOptionsDidChangeNotification
+                      object:nil
+                       queue:nil
+                  usingBlock:^(NSNotification* notification) {
+                    if (!IsForcedHighContrast()) {
+                      theme->SetPreferredContrast(CalculatePreferredContrast());
+                    }
+                    theme->set_prefers_reduced_transparency(
+                        PrefersReducedTransparency());
+                    theme->set_inverted_colors(InvertedColors());
+                    theme->NotifyOnNativeThemeUpdated();
+                  }];
+
   if (static bool initialized = false; !initialized) {
     // Observe caption style changes. Technically these notify the web instance
     // rather than `this`, but there's a 1:1 relationship between the two, and
@@ -359,52 +562,33 @@ NativeThemeMac::NativeThemeMac() {
   }
 }
 
-NativeThemeMac::~NativeThemeMac() = default;
-
-void NativeThemeMac::PaintImpl(cc::PaintCanvas* canvas,
-                               const ColorProvider* color_provider,
-                               Part part,
-                               State state,
-                               const gfx::Rect& rect,
-                               const ExtraParams& extra_params,
-                               bool forced_colors,
-                               bool dark_mode,
-                               PreferredContrast contrast,
-                               std::optional<SkColor> accent_color) const {
-  // Mac uses bespoke scrollbar painting methods (instead of simply overriding
-  // the parent ones) in order to pass `ScrollbarExtraParams`, which doesn't
-  // exist on other platforms.
-  if (part == kScrollbarHorizontalThumb || part == kScrollbarVerticalThumb) {
-    PaintMacScrollbarThumb(canvas, part, state, rect,
-                           std::get<ScrollbarExtraParams>(extra_params),
-                           dark_mode);
-    return;
-  }
-  if (part == kScrollbarHorizontalTrack || part == kScrollbarVerticalTrack ||
-      part == kScrollbarCorner) {
-    PaintMacScrollBarTrackOrCorner(canvas,
-                                   std::get<ScrollbarExtraParams>(extra_params),
-                                   rect, dark_mode, part == kScrollbarCorner);
-    return;
-  }
-
-  NativeThemeBase::PaintImpl(canvas, color_provider, part, state, rect,
-                             extra_params, forced_colors, dark_mode, contrast,
-                             accent_color);
+NativeThemeMac::~NativeThemeMac() {
+  [NSNotificationCenter.defaultCenter
+      removeObserver:objc_members_->display_accessibility_notification_token];
 }
 
-void NativeThemeMac::PaintMenuPopupBackground(
+void NativeThemeMac::PaintSelectedMenuItem(
     cc::PaintCanvas* canvas,
     const ColorProvider* color_provider,
-    const gfx::Size& size,
-    const MenuBackgroundExtraParams& extra_params) const {
-  CHECK(color_provider);
+    const gfx::Rect& rect,
+    const MenuItemExtraParams& extra_params) const {
+  DCHECK(color_provider);
+  // Draw the background.
   cc::PaintFlags flags;
   flags.setAntiAlias(true);
-  flags.setColor(color_provider->GetColor(kColorMenuBackground));
+  flags.setColor(color_provider->GetColor(kColorMenuItemBackgroundSelected));
   const SkScalar radius = SkIntToScalar(extra_params.corner_radius);
-  canvas->drawRoundRect(gfx::RectToSkRect(gfx::Rect(size)), radius, radius,
-                        flags);
+  canvas->drawRoundRect(gfx::RectToSkRect(rect), radius, radius, flags);
+}
+
+void NativeThemeMac::InitializeDarkModeStateAndObserver() {
+  __block auto theme = this;
+  set_preferred_color_scheme(GetPreferredColorScheme());
+  objc_members_->appearance_observer =
+      [[EffectiveAppearanceObserver alloc] initWithHandler:^{
+        theme->set_preferred_color_scheme(GetPreferredColorScheme());
+        theme->NotifyOnNativeThemeUpdated();
+      }];
 }
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_mac_unittest.mm b/ui/native_theme/native_theme_mac_unittest.mm
index 417f9b94e57fa..52913a6c3ec9d 100644
--- a/ui/native_theme/native_theme_mac_unittest.mm
+++ b/ui/native_theme/native_theme_mac_unittest.mm
@@ -11,10 +11,10 @@ namespace ui {
 namespace {
 
 TEST(NativeThemeMacTest, ThumbSize) {
-  EXPECT_EQ(NativeThemeMac::GetThumbMinSize(false, 1.0), gfx::Size(6, 18));
-  EXPECT_EQ(NativeThemeMac::GetThumbMinSize(true, 1.0), gfx::Size(18, 6));
-  EXPECT_EQ(NativeThemeMac::GetThumbMinSize(false, 2.0), gfx::Size(12, 36));
-  EXPECT_EQ(NativeThemeMac::GetThumbMinSize(true, 2.0), gfx::Size(36, 12));
+  EXPECT_EQ(gfx::Size(6.0, 18.0), NativeThemeMac::GetThumbMinSize(true, 1.0));
+  EXPECT_EQ(gfx::Size(18.0, 6.0), NativeThemeMac::GetThumbMinSize(false, 1.0));
+  EXPECT_EQ(gfx::Size(12.0, 36.0), NativeThemeMac::GetThumbMinSize(true, 2.0));
+  EXPECT_EQ(gfx::Size(36.0, 12.0), NativeThemeMac::GetThumbMinSize(false, 2.0));
 }
 
 }  // namespace
diff --git a/ui/native_theme/native_theme_mobile.cc b/ui/native_theme/native_theme_mobile.cc
index 7a1fbaadadb5b..ed84197c1e96f 100644
--- a/ui/native_theme/native_theme_mobile.cc
+++ b/ui/native_theme/native_theme_mobile.cc
@@ -4,46 +4,43 @@
 
 #include "ui/native_theme/native_theme_mobile.h"
 
+#include "base/no_destructor.h"
 #include "base/notreached.h"
-#include "cc/paint/paint_canvas.h"
-#include "cc/paint/paint_flags.h"
 #include "third_party/skia/include/core/SkColor.h"
-#include "third_party/skia/include/core/SkPath.h"
 #include "third_party/skia/include/core/SkRect.h"
-#include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/size.h"
-#include "ui/gfx/geometry/skia_conversions.h"
 #include "ui/native_theme/native_theme_base.h"
 
 namespace ui {
 
-gfx::Size NativeThemeMobile::GetPartSize(
-    Part part,
-    State state,
-    const ExtraParams& extra_params) const {
-  // Radio buttons and checkboxes are slightly bigger than the defaults in
-  // `NativeThemeBase`, to make touch easier on small form factor devices.
-  return (part == kCheckbox || part == kRadio)
-             ? gfx::Size(16, 16)
-             : NativeThemeBase::GetPartSize(part, state, extra_params);
+gfx::Size NativeThemeMobile::GetPartSize(Part part,
+                                         State state,
+                                         const ExtraParams& extra) const {
+  if (part == kCheckbox || part == kRadio) {
+    // Radio buttons and checkboxes are slightly bigger than the defaults in
+    // `NativeThemeBase`, to make touch easier on small form factor devices.
+    static constexpr gfx::Size kCheckboxAndRadioSize(16, 16);
+    return kCheckboxAndRadioSize;
+  }
+  return NativeThemeBase::GetPartSize(part, state, extra);
+}
+
+void NativeThemeMobile::AdjustCheckboxRadioRectForPadding(SkRect* rect) const {
+  // Take 1px for padding around the checkbox/radio button.
+  rect->setLTRB(static_cast<int>(rect->x()) + 1,
+                static_cast<int>(rect->y()) + 1,
+                static_cast<int>(rect->right()) - 1,
+                static_cast<int>(rect->bottom()) - 1);
 }
 
 SkColor NativeThemeMobile::GetControlColor(
     ControlColorId color_id,
     bool dark_mode,
-    PreferredContrast contrast,
     const ColorProvider* color_provider) const {
   // TODO(pkasting): Ensure the relevant bits of //ui/color/ are built on
   // Android, then have `WebThemeEngineAndroid::Paint()` pass a web-only
   // provider that provides the colors below, eliminating the need for this
   // override.
-  const auto maybe_add_alpha = [&](ControlColorId id) {
-    const SkColor color =
-        GetControlColor(id, dark_mode, contrast, color_provider);
-    return (dark_mode || contrast == PreferredContrast::kMore)
-               ? color
-               : SkColorSetA(color, 0x80);
-  };
   switch (color_id) {
     case kBorder:
       return dark_mode ? SkColorSetRGB(0x85, 0x85, 0x85)
@@ -69,9 +66,9 @@ SkColor NativeThemeMobile::GetControlColor(
     case kPressedAccent:
       return dark_mode ? SkColorSetRGB(0x61, 0xA9, 0xFF)
                        : SkColorSetRGB(0x37, 0x93, 0xFF);
-    case kCheckboxBackground:
+    case kBackground:
       return dark_mode ? SkColorSetRGB(0x3B, 0x3B, 0x3B) : SK_ColorWHITE;
-    case kDisabledCheckboxBackground:
+    case kDisabledBackground:
       return dark_mode ? SkColorSetRGB(0x3B, 0x3B, 0x3B)
                        : SkColorSetA(SK_ColorWHITE, 0x99);
     case kFill:
@@ -104,12 +101,6 @@ SkColor NativeThemeMobile::GetControlColor(
     case kPressedSlider:
       return dark_mode ? SkColorSetRGB(0x61, 0xA9, 0xFF)
                        : SkColorSetRGB(0x37, 0x93, 0xFF);
-    case kSliderBorder:
-      return maybe_add_alpha(kBorder);
-    case kHoveredSliderBorder:
-      return maybe_add_alpha(kHoveredBorder);
-    case kPressedSliderBorder:
-      return maybe_add_alpha(kPressedBorder);
     case kAutoCompleteBackground:
       return dark_mode ? SkColorSetARGB(0x66, 0x46, 0x5A, 0x7E)
                        : SkColorSetRGB(0xE8, 0xF0, 0xFE);
@@ -119,14 +110,12 @@ SkColor NativeThemeMobile::GetControlColor(
       // Even though Android does not paint scrollbars, these are used for the
       // arrow buttons that comprise a web "inner spin button" control.
       return dark_mode ? SK_ColorWHITE : SK_ColorBLACK;
-    case kScrollbarArrowDisabled:
-      return dark_mode ? SkColorSetRGB(0x55, 0x55, 0x55)
-                       : SkColorSetRGB(0xA3, 0xA3, 0xA3);
     case kScrollbarCornerControlColorId:
     case kScrollbarTrack:
     case kScrollbarThumb:
     case kScrollbarThumbPressed:
     case kScrollbarThumbHovered:
+    case kScrollbarThumbInactive:
       // These colors are unused because Android does not paint scrollbars.
       NOTREACHED();
     case kButtonBorder:
@@ -146,7 +135,6 @@ SkColor NativeThemeMobile::GetControlColor(
       return dark_mode ? SkColorSetRGB(0x6B, 0x6B, 0x6B)
                        : SkColorSetRGB(0xEF, 0xEF, 0xEF);
     case kButtonDisabledFill:
-    case kScrollbarArrowBackgroundDisabled:
       return dark_mode ? SkColorSetRGB(0x36, 0x36, 0x36)
                        : SkColorSetARGB(0x4D, 0xEF, 0xEF, 0xEF);
     case kButtonHoveredFill:
@@ -161,73 +149,6 @@ SkColor NativeThemeMobile::GetControlColor(
   NOTREACHED();
 }
 
-void NativeThemeMobile::PaintArrowButton(
-    cc::PaintCanvas* canvas,
-    const ColorProvider* color_provider,
-    const gfx::Rect& rect,
-    Part part,
-    State state,
-    bool forced_colors,
-    bool dark_mode,
-    PreferredContrast contrast,
-    const ScrollbarArrowExtraParams& extra_params) const {
-  // Paint the background.
-  PaintLightenLayer(canvas, color_provider, gfx::RectToSkRect(rect), state, 0,
-                    dark_mode, contrast);
-
-  // Paint the button's outline and fill the middle.
-  SkPath outline;
-  if (part == kScrollbarUpArrow) {
-    outline.moveTo(rect.x() + 0.5f, rect.y() + rect.height() + 0.5f);
-    outline.rLineTo(0, -(rect.height() - 2));
-    outline.rLineTo(2, -2);
-    outline.rLineTo(rect.width() - 5, 0);
-    outline.rLineTo(2, 2);
-    outline.rLineTo(0, rect.height() - 2);
-  } else if (part == kScrollbarDownArrow) {
-    outline.moveTo(rect.x() + 0.5f, rect.y() - 0.5f);
-    outline.rLineTo(0, rect.height() - 2);
-    outline.rLineTo(2, 2);
-    outline.rLineTo(rect.width() - 5, 0);
-    outline.rLineTo(2, -2);
-    outline.rLineTo(0, -(rect.height() - 2));
-  } else if (part == kScrollbarRightArrow) {
-    outline.moveTo(rect.x() - 0.5f, rect.y() + 0.5f);
-    outline.rLineTo(rect.width() - 2, 0);
-    outline.rLineTo(2, 2);
-    outline.rLineTo(0, rect.height() - 5);
-    outline.rLineTo(-2, 2);
-    outline.rLineTo(-(rect.width() - 2), 0);
-  } else {
-    CHECK_EQ(kScrollbarLeftArrow, part);
-    outline.moveTo(rect.x() + rect.width() + 0.5f, rect.y() + 0.5f);
-    outline.rLineTo(-(rect.width() - 2), 0);
-    outline.rLineTo(-2, 2);
-    outline.rLineTo(0, rect.height() - 5);
-    outline.rLineTo(2, 2);
-    outline.rLineTo(rect.width() - 2, 0);
-  }
-  outline.close();
-
-  const SkColor bg_color = GetScrollbarArrowBackgroundColor(
-      extra_params, state, dark_mode, contrast, color_provider);
-  cc::PaintFlags flags;
-  flags.setStyle(cc::PaintFlags::kFill_Style);
-  flags.setColor(bg_color);
-  canvas->drawPath(outline, flags);
-
-  flags.setAntiAlias(true);
-  flags.setStyle(cc::PaintFlags::kStroke_Style);
-  flags.setColor(GetControlColorForState(kButtonBorderColors, state, dark_mode,
-                                         contrast, color_provider));
-  canvas->drawPath(outline, flags);
-
-  PaintArrow(
-      canvas, rect, part, state,
-      GetScrollbarArrowForegroundColor(bg_color, extra_params, state, dark_mode,
-                                       contrast, color_provider));
-}
-
 NativeThemeMobile::NativeThemeMobile() = default;
 
 NativeThemeMobile::~NativeThemeMobile() = default;
diff --git a/ui/native_theme/native_theme_mobile.h b/ui/native_theme/native_theme_mobile.h
index 644a175098e1e..56e2233d7a434 100644
--- a/ui/native_theme/native_theme_mobile.h
+++ b/ui/native_theme/native_theme_mobile.h
@@ -18,28 +18,19 @@ class NativeThemeMobile : public NativeThemeBase {
   // NativeThemeBase:
   gfx::Size GetPartSize(Part part,
                         State state,
-                        const ExtraParams& extra_params) const override;
+                        const ExtraParams& extra) const override;
 
  protected:
+  friend class NativeTheme;
+  friend class base::NoDestructor<NativeThemeMobile>;
+
   // NativeThemeBase:
+  void AdjustCheckboxRadioRectForPadding(SkRect* rect) const override;
   SkColor GetControlColor(ControlColorId color_id,
                           bool dark_mode,
-                          PreferredContrast contrast,
                           const ColorProvider* color_provider) const override;
-  void PaintArrowButton(
-      cc::PaintCanvas* gc,
-      const ColorProvider* color_provider,
-      const gfx::Rect& rect,
-      Part part,
-      State state,
-      bool forced_colors,
-      bool dark_mode,
-      PreferredContrast contrast,
-      const ScrollbarArrowExtraParams& extra_params) const override;
 
  private:
-  friend class base::NoDestructor<NativeThemeMobile>;
-
   NativeThemeMobile();
   ~NativeThemeMobile() override;
 };
diff --git a/ui/native_theme/native_theme_observer.h b/ui/native_theme/native_theme_observer.h
index 9256ff6fa607e..4d581717f1815 100644
--- a/ui/native_theme/native_theme_observer.h
+++ b/ui/native_theme/native_theme_observer.h
@@ -20,10 +20,13 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeObserver
 
   // Called when the native theme changes. The observed theme is passed so that
   // observers may handle changes to their associated native theme instances.
-  virtual void OnNativeThemeUpdated(NativeTheme* observed_theme) {}
+  virtual void OnNativeThemeUpdated(ui::NativeTheme* observed_theme) {}
 
   // Called when the caption style changes.
   virtual void OnCaptionStyleUpdated() {}
+
+  // Called when the system Increased Contrast state changes.
+  virtual void OnPreferredContrastChanged(ui::NativeTheme* observed_theme) {}
 };
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_unittest.cc b/ui/native_theme/native_theme_unittest.cc
index 88b0031da0de8..80510ecf72fbd 100644
--- a/ui/native_theme/native_theme_unittest.cc
+++ b/ui/native_theme/native_theme_unittest.cc
@@ -5,69 +5,104 @@
 #include "ui/native_theme/native_theme.h"
 
 #include <optional>
-#include <utility>
 
-#include "base/scoped_observation.h"
 #include "base/test/metrics/histogram_tester.h"
 #include "base/time/time.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/color/color_provider_key.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
-#include "ui/native_theme/native_theme.h"
-#include "ui/native_theme/native_theme_observer.h"
 
 namespace ui {
+
 namespace {
 
-class NativeThemeTest : public ::testing::Test {
- protected:
-  NativeThemeTest() = default;
-  ~NativeThemeTest() override = default;
+class TestNativeTheme : public NativeTheme {
+ public:
+  TestNativeTheme() = default;
+  TestNativeTheme(const TestNativeTheme&) = delete;
+  TestNativeTheme& operator=(const TestNativeTheme&) = delete;
+  ~TestNativeTheme() override = default;
 
-  MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
+  ColorProviderKey::ForcedColors GetForcedColorsKey() const {
+    return GetColorProviderKey(/*custom_theme=*/nullptr).forced_colors;
   }
 
- private:
-  MockOsSettingsProvider os_settings_provider_;
+  // NativeTheme:
+  gfx::Size GetPartSize(Part part,
+                        State state,
+                        const ExtraParams& extra) const override {
+    return gfx::Size();
+  }
+  void Paint(cc::PaintCanvas* canvas,
+             const ui::ColorProvider* color_provider,
+             Part part,
+             State state,
+             const gfx::Rect& rect,
+             const ExtraParams& extra,
+             bool forced_colors,
+             PreferredColorScheme color_scheme,
+             PreferredContrast contrast,
+             const std::optional<SkColor>& accent_color) const override {}
+  bool SupportsNinePatch(Part part) const override { return false; }
+  gfx::Size GetNinePatchCanvasSize(Part part) const override {
+    return gfx::Size();
+  }
+  gfx::Rect GetNinePatchAperture(Part part) const override {
+    return gfx::Rect();
+  }
 };
 
-TEST_F(NativeThemeTest, PreferredColorScheme) {
-  using enum NativeTheme::PreferredColorScheme;
-  const auto* const native_theme = NativeTheme::GetInstanceForNativeUi();
+}  // namespace
 
-  EXPECT_EQ(native_theme->preferred_color_scheme(), kLight);
+TEST(NativeThemeTest, TestOnNativeThemeUpdatedMetricsEmitted) {
+  base::HistogramTester histogram_tester;
+  TestNativeTheme theme;
+  histogram_tester.ExpectTotalCount(
+      "Views.Browser.TimeSpentProcessingOnNativeThemeUpdatedEvent", 0);
+  histogram_tester.ExpectUniqueSample(
+      "Views.Browser.NumColorProvidersInitializedDuringOnNativeThemeUpdated", 0,
+      0);
 
-  os_settings_provider().SetPreferredColorScheme(kDark);
-  EXPECT_EQ(native_theme->preferred_color_scheme(), kDark);
+  theme.NotifyOnNativeThemeUpdated();
+  histogram_tester.ExpectTotalCount(
+      "Views.Browser.TimeSpentProcessingOnNativeThemeUpdatedEvent", 1);
+  histogram_tester.ExpectUniqueSample(
+      "Views.Browser.NumColorProvidersInitializedDuringOnNativeThemeUpdated", 0,
+      1);
 
-  os_settings_provider().SetPreferredColorScheme(kNoPreference);
-  EXPECT_EQ(native_theme->preferred_color_scheme(), kNoPreference);
+  theme.NotifyOnNativeThemeUpdated();
+  histogram_tester.ExpectTotalCount(
+      "Views.Browser.TimeSpentProcessingOnNativeThemeUpdatedEvent", 2);
+  histogram_tester.ExpectUniqueSample(
+      "Views.Browser.NumColorProvidersInitializedDuringOnNativeThemeUpdated", 0,
+      2);
 }
 
-TEST_F(NativeThemeTest, PreferredContrast) {
-  using enum NativeTheme::PreferredContrast;
-  const auto* const native_theme = NativeTheme::GetInstanceForNativeUi();
+TEST(NativeThemeTest, TestColorProviderKeyForcedColors) {
+  TestNativeTheme theme;
 
-  EXPECT_EQ(native_theme->preferred_contrast(), kNoPreference);
+  theme.set_forced_colors(true);
+  theme.set_page_colors(NativeTheme::PageColors::kDusk);
+  EXPECT_EQ(theme.GetForcedColorsKey(), ColorProviderKey::ForcedColors::kDusk);
 
-  os_settings_provider().SetPreferredContrast(kMore);
-  EXPECT_EQ(native_theme->preferred_contrast(), kMore);
+  theme.set_page_colors(NativeTheme::PageColors::kOff);
+  EXPECT_EQ(theme.GetForcedColorsKey(), ColorProviderKey::ForcedColors::kNone);
 
-  os_settings_provider().SetPreferredContrast(kCustom);
-  EXPECT_EQ(native_theme->preferred_contrast(), kCustom);
+  theme.set_page_colors(NativeTheme::PageColors::kHighContrast);
+  EXPECT_EQ(theme.GetForcedColorsKey(),
+            ColorProviderKey::ForcedColors::kSystem);
 
-  os_settings_provider().SetPreferredContrast(kLess);
-  EXPECT_EQ(native_theme->preferred_contrast(), kLess);
-}
+  theme.set_forced_colors(false);
+  theme.set_page_colors(NativeTheme::PageColors::kOff);
+  EXPECT_EQ(theme.GetForcedColorsKey(), ColorProviderKey::ForcedColors::kNone);
 
-TEST_F(NativeThemeTest, UserColor) {
-  static constexpr auto kAccentColor = SkColorSetRGB(135, 115, 10);
-  os_settings_provider().SetAccentColor(kAccentColor);
-  EXPECT_EQ(kAccentColor, NativeTheme::GetInstanceForNativeUi()->user_color());
+  theme.set_page_colors(NativeTheme::PageColors::kHighContrast);
+  EXPECT_EQ(theme.GetForcedColorsKey(), ColorProviderKey::ForcedColors::kNone);
+
+  theme.set_page_colors(NativeTheme::PageColors::kDusk);
+  EXPECT_EQ(theme.GetForcedColorsKey(), ColorProviderKey::ForcedColors::kNone);
 }
 
-TEST_F(NativeThemeTest, CaretBlinkInterval) {
+TEST(NativeThemeTest, CaretBlinkInterval) {
   auto* const native_theme = NativeTheme::GetInstanceForNativeUi();
   static constexpr auto kNewInterval = base::Milliseconds(42);
   native_theme->set_caret_blink_interval(kNewInterval);
@@ -77,88 +112,4 @@ TEST_F(NativeThemeTest, CaretBlinkInterval) {
   EXPECT_EQ(native_theme->caret_blink_interval(), base::TimeDelta());
 }
 
-TEST_F(NativeThemeTest, ColorMode) {
-  using enum NativeTheme::PreferredColorScheme;
-  const auto* const native_theme = NativeTheme::GetInstanceForNativeUi();
-
-  os_settings_provider().SetPreferredColorScheme(kDark);
-  EXPECT_EQ(native_theme->GetColorProviderKey(nullptr).color_mode,
-            ColorProviderKey::ColorMode::kDark);
-
-  os_settings_provider().SetPreferredColorScheme(kLight);
-  EXPECT_EQ(native_theme->GetColorProviderKey(nullptr).color_mode,
-            ColorProviderKey::ColorMode::kLight);
-
-  os_settings_provider().SetForcedColorsActive(true);
-  os_settings_provider().SetPreferredColorScheme(kDark);
-  EXPECT_EQ(native_theme->GetColorProviderKey(nullptr).color_mode,
-            ColorProviderKey::ColorMode::kDark);
-
-  os_settings_provider().SetPreferredColorScheme(kLight);
-  EXPECT_EQ(native_theme->GetColorProviderKey(nullptr).color_mode,
-            ColorProviderKey::ColorMode::kLight);
-}
-
-TEST_F(NativeThemeTest, MetricsEmitted) {
-  auto* const native_theme = NativeTheme::GetInstanceForNativeUi();
-  base::HistogramTester histogram_tester;
-
-  native_theme->NotifyOnNativeThemeUpdated();
-  histogram_tester.ExpectTotalCount(
-      "Views.Browser.TimeSpentProcessingOnNativeThemeUpdatedEvent", 1);
-  histogram_tester.ExpectUniqueSample(
-      "Views.Browser.NumColorProvidersInitializedDuringOnNativeThemeUpdated", 0,
-      1);
-
-  native_theme->NotifyOnNativeThemeUpdated();
-  histogram_tester.ExpectTotalCount(
-      "Views.Browser.TimeSpentProcessingOnNativeThemeUpdatedEvent", 2);
-  histogram_tester.ExpectUniqueSample(
-      "Views.Browser.NumColorProvidersInitializedDuringOnNativeThemeUpdated", 0,
-      2);
-}
-
-TEST_F(NativeThemeTest, DelayScoper) {
-  // Monitor calls to `OnNativeThemeUpdated()`.
-  struct MockObserver : NativeThemeObserver {
-    void OnNativeThemeUpdated(NativeTheme* observed_theme) override {
-      ++call_count;
-    }
-
-    int call_count = 0;
-  } observer;
-  base::ScopedObservation<NativeTheme, NativeThemeObserver> observation(
-      &observer);
-  observation.Observe(NativeTheme::GetInstanceForNativeUi());
-
-  const auto expect_notification_count = [&](int n) {
-    EXPECT_EQ(std::exchange(observer.call_count, 0), n);
-  };
-
-  // Sanity check: setting the color should normally notify.
-  os_settings_provider().SetAccentColor(SK_ColorRED);
-  expect_notification_count(1);
-
-  // When there are scopers alive, there should be no notifications.
-  std::optional<NativeTheme::UpdateNotificationDelayScoper> scoper_1, scoper_2;
-  scoper_1.emplace();
-  scoper_2.emplace();
-  os_settings_provider().SetAccentColor(SK_ColorGREEN);
-  expect_notification_count(0);
-
-  // Destroying some, but not all scopers should still not notify.
-  scoper_2.reset();
-  expect_notification_count(0);
-
-  // Since there are still scopers, further changes should still not notify.
-  os_settings_provider().SetAccentColor(SK_ColorBLUE);
-  expect_notification_count(0);
-
-  // When the last scoper is destroyed, there should only be one notification,
-  // even though there were multiple changes above.
-  scoper_1.reset();
-  expect_notification_count(1);
-}
-
-}  // namespace
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_win.cc b/ui/native_theme/native_theme_win.cc
index 7e9d720996329..7cb8a878f49b7 100644
--- a/ui/native_theme/native_theme_win.cc
+++ b/ui/native_theme/native_theme_win.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "ui/native_theme/native_theme_win.h"
 
 #include <windows.h>
@@ -11,21 +16,19 @@
 #include <vsstyle.h>
 
 #include <array>
-#include <cmath>
 #include <optional>
+#include <tuple>
 #include <utility>
 #include <variant>
 
 #include "base/check.h"
-#include "base/compiler_specific.h"
-#include "base/containers/fixed_flat_map.h"
-#include "base/containers/flat_map.h"
-#include "base/containers/span.h"
+#include "base/functional/bind.h"
+#include "base/metrics/histogram_functions.h"
 #include "base/no_destructor.h"
 #include "base/notreached.h"
-#include "base/numerics/checked_math.h"
-#include "base/numerics/safe_conversions.h"
-#include "base/strings/cstring_view.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/time/time.h"
+#include "base/win/dark_mode_support.h"
 #include "base/win/scoped_gdi_object.h"
 #include "base/win/scoped_hdc.h"
 #include "base/win/scoped_select_object.h"
@@ -49,28 +52,28 @@
 #include "third_party/skia/include/private/chromium/SkPMColor.h"
 #include "ui/color/color_id.h"
 #include "ui/color/color_provider.h"
+#include "ui/color/win/native_color_mixers_win.h"
 #include "ui/display/win/screen_win.h"
+#include "ui/gfx/color_conversions.h"
+#include "ui/gfx/color_utils.h"
 #include "ui/gfx/geometry/point_f.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/rect_f.h"
 #include "ui/gfx/geometry/skia_conversions.h"
 #include "ui/native_theme/native_theme.h"
-#include "ui/native_theme/os_settings_provider.h"
 
 namespace ui {
 
 namespace {
 
-using ThemeHandles = base::flat_map<base::wcstring_view, HANDLE>;
-
-void SetCheckerboardShader(SkPaint* paint, int left, int top) {
+void SetCheckerboardShader(SkPaint* paint, const RECT& align_rect) {
   // Create a 2x2 checkerboard pattern using the 3D face and highlight colors.
-  const auto& os_settings_provider = OsSettingsProvider::Get();
-  using enum OsSettingsProvider::ColorId;
-  const SkColor face = os_settings_provider.Color(kButtonFace)
+  const auto* const native_theme = NativeTheme::GetInstanceForNativeUi();
+  using enum NativeTheme::SystemThemeColor;
+  const SkColor face = native_theme->GetSystemThemeColor(kButtonFace)
                            .value_or(SkColorSetRGB(0xC0, 0xC0, 0xC0));
-  const SkColor highlight =
-      os_settings_provider.Color(kButtonHighlight).value_or(SK_ColorWHITE);
+  const SkColor highlight = native_theme->GetSystemThemeColor(kButtonHighlight)
+                                .value_or(SK_ColorWHITE);
   SkColor buffer[] = {face, highlight, highlight, face};
   // Confusing bit: we first create a temporary bitmap with our desired pattern,
   // then copy it to another bitmap.  The temporary bitmap doesn't take
@@ -88,11 +91,33 @@ void SetCheckerboardShader(SkPaint* paint, int left, int top) {
 
   // Align the pattern with the upper corner of |align_rect|.
   SkMatrix local_matrix;
-  local_matrix.setTranslate(SkIntToScalar(left), SkIntToScalar(top));
+  local_matrix.setTranslate(SkIntToScalar(align_rect.left),
+                            SkIntToScalar(align_rect.top));
   paint->setShader(bitmap.makeShader(SkTileMode::kRepeat, SkTileMode::kRepeat,
                                      SkSamplingOptions(), &local_matrix));
 }
 
+//    <-a->
+// [  *****             ]
+//  ____ |              |
+//  <-a-> <------b----->
+// a: object_width
+// b: frame_width
+// *: animating object
+//
+// - the animation goes from "[" to "]" repeatedly.
+// - the animation offset is at first "|"
+//
+int ComputeAnimationProgress(int frame_width,
+                             int object_width,
+                             int pixels_per_second,
+                             double animated_seconds) {
+  int animation_width = frame_width + object_width;
+  double interval = static_cast<double>(animation_width) / pixels_per_second;
+  double ratio = fmod(animated_seconds, interval) / interval;
+  return static_cast<int>(animation_width * ratio) - object_width;
+}
+
 // Custom scoped object for storing DC and a bitmap that was selected into it,
 // and making sure that they are deleted in the right order.
 class ScopedCreateDCWithBitmap {
@@ -114,7 +139,7 @@ class ScopedCreateDCWithBitmap {
   base::win::ScopedCreateDC::Handle Get() const { return dc_.Get(); }
 
   // Selects |handle| to bitmap into DC. Returns false if handle is not valid.
-  bool SelectBitmap(HBITMAP handle) {
+  bool SelectBitmap(base::win::ScopedGDIObject<HBITMAP>::element_type handle) {
     bitmap_.reset(handle);
     if (!bitmap_.is_valid()) {
       return false;
@@ -129,635 +154,299 @@ class ScopedCreateDCWithBitmap {
   base::win::ScopedGDIObject<HBITMAP> bitmap_;
 };
 
-// Returns the cached open theme handles. This is process-scoped rather than
-// owned by `NativeThemeWin` so that, in case two `NativeThemeWin` instances are
-// live simultaneously (e.g. in tests), destroying one (and thus calling
-// `CloseThemeData()` on all its handles) won't leave the other holding invalid
-// handles.
-ThemeHandles* GetThemeHandles() {
-  static base::NoDestructor<ThemeHandles> kThemeHandles;
-  return kThemeHandles.get();
+base::win::RegKey OpenThemeRegKey(REGSAM access) {
+  base::win::RegKey hkcu_themes_regkey;
+  // Validity is checked at time-of-use.
+  std::ignore = hkcu_themes_regkey.Open(HKEY_CURRENT_USER,
+                                        L"Software\\Microsoft\\Windows\\"
+                                        L"CurrentVersion\\Themes\\Personalize",
+                                        access);
+  return hkcu_themes_regkey;
 }
 
-// Returns the theme handle for `part`, opening it if necessary.
-HANDLE GetThemeHandle(NativeTheme::Part part) {
-  base::wcstring_view theme_class;
-  switch (part) {
-    case NativeTheme::kCheckbox:
-    case NativeTheme::kPushButton:
-    case NativeTheme::kRadio:
-      theme_class = L"Button";
-      break;
-    case NativeTheme::kMenuList:
-    case NativeTheme::kMenuCheck:
-    case NativeTheme::kMenuCheckBackground:
-    case NativeTheme::kMenuPopupArrow:
-    case NativeTheme::kMenuPopupGutter:
-    case NativeTheme::kMenuPopupSeparator:
-      theme_class = L"Menu";
-      break;
-    case NativeTheme::kProgressBar:
-      theme_class = L"Progress";
-      break;
-    case NativeTheme::kScrollbarDownArrow:
-    case NativeTheme::kScrollbarLeftArrow:
-    case NativeTheme::kScrollbarRightArrow:
-    case NativeTheme::kScrollbarUpArrow:
-    case NativeTheme::kScrollbarHorizontalGripper:
-    case NativeTheme::kScrollbarVerticalGripper:
-    case NativeTheme::kScrollbarHorizontalThumb:
-    case NativeTheme::kScrollbarVerticalThumb:
-    case NativeTheme::kScrollbarHorizontalTrack:
-    case NativeTheme::kScrollbarVerticalTrack:
-      theme_class = OsSettingsProvider::Get().DarkColorSchemeAvailable()
-                        ? base::wcstring_view(L"Explorer::Scrollbar")
-                        : base::wcstring_view(L"Scrollbar");
-      break;
-    case NativeTheme::kInnerSpinButton:
-      theme_class = L"Spin";
-      break;
-    case NativeTheme::kWindowResizeGripper:
-      theme_class = L"Status";
-      break;
-    case NativeTheme::kTabPanelBackground:
-      theme_class = L"Tab";
-      break;
-    case NativeTheme::kTextField:
-      theme_class = L"Edit";
-      break;
-    case NativeTheme::kTrackbarThumb:
-    case NativeTheme::kTrackbarTrack:
-      theme_class = L"Trackbar";
-      break;
-    default:
-      NOTREACHED();
-  }
-
-  HANDLE& handle = (*GetThemeHandles())[theme_class];
-  if (!handle) {
-    handle = OpenThemeData(nullptr, theme_class.c_str());
-  }
-  return handle;
+base::win::RegKey OpenColorFilteringRegKey(REGSAM access) {
+  base::win::RegKey hkcu_color_filtering_regkey;
+  // Validity is checked at time-of-use.
+  std::ignore = hkcu_color_filtering_regkey.Open(
+      HKEY_CURRENT_USER, L"Software\\Microsoft\\ColorFiltering", access);
+  return hkcu_color_filtering_regkey;
 }
 
-int GetWindowsPart(NativeTheme::Part part,
-                   const NativeTheme::ExtraParams& extra_params) {
-  if (part == NativeTheme::kScrollbarHorizontalTrack) {
-    return std::get<NativeTheme::ScrollbarTrackExtraParams>(extra_params)
-                   .is_upper
-               ? SBP_UPPERTRACKHORZ
-               : SBP_LOWERTRACKHORZ;
-  }
-  if (part == NativeTheme::kScrollbarVerticalTrack) {
-    return std::get<NativeTheme::ScrollbarTrackExtraParams>(extra_params)
-                   .is_upper
-               ? SBP_UPPERTRACKVERT
-               : SBP_LOWERTRACKVERT;
-  }
-  if (part == NativeTheme::kInnerSpinButton) {
-    return std::get<NativeTheme::InnerSpinButtonExtraParams>(extra_params)
-                   .spin_up
-               ? SPNP_UP
-               : SPNP_DOWN;
-  }
-  if (part == NativeTheme::kTrackbarThumb) {
-    return std::get<NativeTheme::TrackbarExtraParams>(extra_params).vertical
-               ? TKP_THUMBVERT
-               : TKP_THUMBBOTTOM;
-  }
-  if (part == NativeTheme::kTrackbarTrack) {
-    return std::get<NativeTheme::TrackbarExtraParams>(extra_params).vertical
-               ? TKP_TRACKVERT
-               : TKP_TRACK;
-  }
+}  // namespace
 
-  static constexpr auto kPartMap =
-      base::MakeFixedFlatMap<NativeTheme::Part, int>(
-          {{NativeTheme::kCheckbox, BP_CHECKBOX},
-           {NativeTheme::kPushButton, BP_PUSHBUTTON},
-           {NativeTheme::kRadio, BP_RADIOBUTTON},
-           {NativeTheme::kMenuList, CP_DROPDOWNBUTTON},
-           {NativeTheme::kTextField, EP_EDITTEXT},
-           {NativeTheme::kMenuCheck, MENU_POPUPCHECK},
-           {NativeTheme::kMenuCheckBackground, MENU_POPUPCHECKBACKGROUND},
-           {NativeTheme::kMenuPopupGutter, MENU_POPUPGUTTER},
-           {NativeTheme::kMenuPopupSeparator, MENU_POPUPSEPARATOR},
-           {NativeTheme::kMenuPopupArrow, MENU_POPUPSUBMENU},
-           {NativeTheme::kProgressBar, PP_BAR},
-           {NativeTheme::kScrollbarDownArrow, SBP_ARROWBTN},
-           {NativeTheme::kScrollbarLeftArrow, SBP_ARROWBTN},
-           {NativeTheme::kScrollbarRightArrow, SBP_ARROWBTN},
-           {NativeTheme::kScrollbarUpArrow, SBP_ARROWBTN},
-           {NativeTheme::kScrollbarHorizontalGripper, SBP_GRIPPERHORZ},
-           {NativeTheme::kScrollbarVerticalGripper, SBP_GRIPPERVERT},
-           {NativeTheme::kScrollbarHorizontalThumb, SBP_THUMBBTNHORZ},
-           {NativeTheme::kScrollbarVerticalThumb, SBP_THUMBBTNVERT},
-           {NativeTheme::kWindowResizeGripper,
-            // Use the status bar gripper.  There doesn't seem to be a standard
-            // gripper in Windows for the space between scrollbars.  This is
-            // pretty close, but it's supposed to be painted over a status bar.
-            SP_GRIPPER},
-           {NativeTheme::kTabPanelBackground, TABP_BODY}});
-  return kPartMap.at(part);
+// static
+bool NativeTheme::SystemDarkModeSupported() {
+  static bool system_supports_dark_mode =
+      ([]() { return OpenThemeRegKey(KEY_READ).Valid(); })();
+  return system_supports_dark_mode;
 }
 
-int GetWindowsState(NativeTheme::Part part,
-                    NativeTheme::State state,
-                    const NativeTheme::ExtraParams& extra_params) {
-  if (part == NativeTheme::kCheckbox) {
-    const auto& button = std::get<NativeTheme::ButtonExtraParams>(extra_params);
-    if (button.checked) {
-      return std::to_array({CBS_CHECKEDDISABLED, CBS_CHECKEDHOT,
-                            CBS_CHECKEDNORMAL, CBS_CHECKEDPRESSED})[state];
-    }
-    if (button.indeterminate) {
-      return std::to_array({CBS_MIXEDDISABLED, CBS_MIXEDHOT, CBS_MIXEDNORMAL,
-                            CBS_MIXEDPRESSED})[state];
-    }
-    return std::to_array({CBS_UNCHECKEDDISABLED, CBS_UNCHECKEDHOT,
-                          CBS_UNCHECKEDNORMAL, CBS_UNCHECKEDPRESSED})[state];
-  }
-  if (part == NativeTheme::kInnerSpinButton &&
-      std::get<NativeTheme::InnerSpinButtonExtraParams>(extra_params).spin_up) {
-    return std::to_array(
-        {UPS_DISABLED, UPS_HOT, UPS_NORMAL, UPS_PRESSED})[state];
-  }
-  if (part == NativeTheme::kMenuCheck &&
-      std::get<NativeTheme::MenuCheckExtraParams>(extra_params).is_radio) {
-    return (state == NativeTheme::kDisabled) ? MC_BULLETDISABLED
-                                             : MC_BULLETNORMAL;
-  }
-  if (part == NativeTheme::kPushButton && state == NativeTheme::kNormal &&
-      std::get<NativeTheme::ButtonExtraParams>(extra_params).is_default) {
-    return PBS_DEFAULTED;
-  }
-  if (part == NativeTheme::kRadio &&
-      std::get<NativeTheme::ButtonExtraParams>(extra_params).checked) {
-    return std::to_array({RBS_CHECKEDDISABLED, RBS_CHECKEDHOT,
-                          RBS_CHECKEDNORMAL, RBS_CHECKEDPRESSED})[state];
-  }
-  if (part >= NativeTheme::kScrollbarDownArrow &&
-      part <= NativeTheme::kScrollbarUpArrow &&
-      state == NativeTheme::kHovered &&
-      std::get<NativeTheme::ScrollbarArrowExtraParams>(extra_params)
-          .is_hovering) {
-    return std::to_array(
-        {ABS_DOWNHOVER, ABS_LEFTHOVER, ABS_RIGHTHOVER,
-         ABS_UPHOVER})[part - NativeTheme::kScrollbarDownArrow];
-  }
-  if ((part == NativeTheme::kScrollbarHorizontalThumb ||
-       part == NativeTheme::kScrollbarVerticalThumb ||
-       part == NativeTheme::kScrollbarHorizontalGripper ||
-       part == NativeTheme::kScrollbarVerticalGripper) &&
-      state == NativeTheme::kHovered &&
-      !std::get<NativeTheme::ScrollbarThumbExtraParams>(extra_params)
-           .is_hovering) {
-    return SCRBS_HOT;
-  }
-  if (part >= NativeTheme::kScrollbarHorizontalThumb &&
-      part <= NativeTheme::kScrollbarVerticalGripper) {
-    return std::to_array(
-        {SCRBS_DISABLED, SCRBS_HOVER, SCRBS_NORMAL, SCRBS_PRESSED})[state];
-  }
-  if (part == NativeTheme::kTextField && state == NativeTheme::kNormal) {
-    const auto& text_field =
-        std::get<NativeTheme::TextFieldExtraParams>(extra_params);
-    if (text_field.is_read_only) {
-      return ETS_READONLY;
-    }
-    if (text_field.is_focused) {
-      return ETS_FOCUSED;
+// static
+void NativeThemeWin::CloseHandles() {
+  static_cast<NativeThemeWin*>(NativeTheme::GetInstanceForNativeUi())
+      ->CloseHandlesInternal();
+}
+
+gfx::Size NativeThemeWin::GetPartSize(Part part,
+                                      State state,
+                                      const ExtraParams& extra) const {
+  // The GetThemePartSize call below returns the default size without
+  // accounting for user customization (crbug/218291).
+  switch (part) {
+    case kScrollbarDownArrow:
+    case kScrollbarLeftArrow:
+    case kScrollbarRightArrow:
+    case kScrollbarUpArrow:
+    case kScrollbarHorizontalThumb:
+    case kScrollbarVerticalThumb:
+    case kScrollbarHorizontalTrack:
+    case kScrollbarVerticalTrack: {
+      int size =
+          display::win::GetScreenWin()->GetSystemMetricsInDIP(SM_CXVSCROLL);
+      if (size == 0) {
+        size = 17;
+      }
+      return gfx::Size(size, size);
     }
-  }
-  if (part == NativeTheme::kTrackbarThumb ||
-      part == NativeTheme::kTrackbarTrack) {
-    return std::to_array(
-        {TUS_DISABLED, TUS_HOT, TUS_NORMAL, TUS_PRESSED})[state];
-  }
-  if (part == NativeTheme::kMenuPopupGutter ||
-      part == NativeTheme::kMenuPopupSeparator ||
-      part == NativeTheme::kProgressBar ||
-      part == NativeTheme::kTabPanelBackground ||
-      part == NativeTheme::kWindowResizeGripper) {
-    return 0;
+    default:
+      break;
   }
 
-  static constexpr auto kStateMap = base::MakeFixedFlatMap<
-      NativeTheme::Part, std::array<int, NativeTheme::kNumStates>>(
-      {{NativeTheme::kInnerSpinButton,
-        {DNS_DISABLED, DNS_HOT, DNS_NORMAL, DNS_PRESSED}},
-       {NativeTheme::kMenuList,
-        {CBXS_DISABLED, CBXS_HOT, CBXS_NORMAL, CBXS_PRESSED}},
-       {NativeTheme::kMenuCheck,
-        {MC_CHECKMARKDISABLED, MC_CHECKMARKNORMAL, MC_CHECKMARKNORMAL,
-         MC_CHECKMARKNORMAL}},
-       {NativeTheme::kMenuCheckBackground,
-        {MCB_DISABLED, MCB_NORMAL, MCB_NORMAL, MCB_NORMAL}},
-       {NativeTheme::kMenuPopupArrow,
-        {MSM_DISABLED, MSM_NORMAL, MSM_NORMAL, MSM_NORMAL}},
-       {NativeTheme::kPushButton,
-        {PBS_DISABLED, PBS_HOT, PBS_NORMAL, PBS_PRESSED}},
-       {NativeTheme::kRadio,
-        {RBS_UNCHECKEDDISABLED, RBS_UNCHECKEDHOT, RBS_UNCHECKEDNORMAL,
-         RBS_UNCHECKEDPRESSED}},
-       {NativeTheme::kScrollbarDownArrow,
-        {ABS_DOWNDISABLED, ABS_DOWNHOT, ABS_DOWNNORMAL, ABS_DOWNPRESSED}},
-       {NativeTheme::kScrollbarLeftArrow,
-        {ABS_LEFTDISABLED, ABS_LEFTHOT, ABS_LEFTNORMAL, ABS_LEFTPRESSED}},
-       {NativeTheme::kScrollbarRightArrow,
-        {ABS_RIGHTDISABLED, ABS_RIGHTHOT, ABS_RIGHTNORMAL, ABS_RIGHTPRESSED}},
-       {NativeTheme::kScrollbarUpArrow,
-        {ABS_UPDISABLED, ABS_UPHOT, ABS_UPNORMAL, ABS_UPPRESSED}},
-       {NativeTheme::kTextField,
-        {ETS_DISABLED, ETS_HOT, ETS_NORMAL, ETS_SELECTED}}});
-  return kStateMap.at(part)[state];
-}
+  int part_id = GetWindowsPart(part, state, extra);
+  int state_id = GetWindowsState(part, state, extra);
 
-void PaintMenuSeparator(
-    cc::PaintCanvas* canvas,
-    const ColorProvider* color_provider,
-    const NativeTheme::MenuSeparatorExtraParams& extra_params) {
-  CHECK(color_provider);
-  const gfx::RectF rect(*extra_params.paint_rect);
-  gfx::PointF start = rect.CenterPoint();
-  gfx::PointF end = start;
-  if (extra_params.type == VERTICAL_SEPARATOR) {
-    start.set_y(rect.y());
-    end.set_y(rect.bottom());
-  } else {
-    start.set_x(rect.x());
-    end.set_x(rect.right());
+  base::win::ScopedGetDC screen_dc(nullptr);
+  SIZE size;
+  HANDLE handle = GetThemeHandle(GetThemeName(part));
+  if (handle && SUCCEEDED(GetThemePartSize(handle, screen_dc, part_id, state_id,
+                                           nullptr, TS_TRUE, &size))) {
+    return gfx::Size(size.cx, size.cy);
   }
 
-  cc::PaintFlags flags;
-  flags.setColor(color_provider->GetColor(extra_params.color_id));
-  canvas->drawLine(start.x(), start.y(), end.x(), end.y(), flags);
+  // TODO(rogerta): For now, we need to support radio buttons and checkboxes
+  // when theming is not enabled.  Support for other parts can be added
+  // if/when needed.
+  return (part == kCheckbox || part == kRadio) ? gfx::Size(13, 13)
+                                               : gfx::Size();
 }
 
-void PaintMenuGutter(cc::PaintCanvas* canvas,
-                     const ColorProvider* color_provider,
-                     const gfx::Rect& rect) {
-  CHECK(color_provider);
-  cc::PaintFlags flags;
-  flags.setColor(color_provider->GetColor(kColorMenuSeparator));
-  const int center_x = rect.x() + rect.width() / 2;
-  canvas->drawLine(center_x, rect.y(), center_x, rect.bottom(), flags);
-}
+void NativeThemeWin::Paint(cc::PaintCanvas* canvas,
+                           const ui::ColorProvider* color_provider,
+                           Part part,
+                           State state,
+                           const gfx::Rect& rect,
+                           const ExtraParams& extra,
+                           bool forced_colors,
+                           PreferredColorScheme color_scheme,
+                           PreferredContrast contrast,
+                           const std::optional<SkColor>& accent_color) const {
+  if (rect.IsEmpty()) {
+    return;
+  }
 
-void PaintMenuBackground(cc::PaintCanvas* canvas,
-                         const ColorProvider* color_provider,
-                         const gfx::Rect& rect) {
-  CHECK(color_provider);
-  cc::PaintFlags flags;
-  flags.setColor(color_provider->GetColor(kColorMenuBackground));
-  canvas->drawRect(gfx::RectToSkRect(rect), flags);
+  switch (part) {
+    case kMenuPopupGutter:
+      PaintMenuGutter(canvas, color_provider, rect);
+      return;
+    case kMenuPopupSeparator:
+      PaintMenuSeparator(canvas, color_provider,
+                         std::get<MenuSeparatorExtraParams>(extra));
+      return;
+    case kMenuPopupBackground:
+      PaintMenuBackground(canvas, color_provider, rect);
+      return;
+    case kMenuItemBackground:
+      PaintMenuItemBackground(canvas, color_provider, state, rect,
+                              std::get<MenuItemExtraParams>(extra));
+      return;
+    default:
+      PaintIndirect(canvas, part, state, rect, extra);
+      return;
+  }
 }
 
-void PaintButtonClassic(HDC hdc,
-                        NativeTheme::Part part,
-                        NativeTheme::State state,
-                        RECT* rect,
-                        const NativeTheme::ButtonExtraParams& extra_params) {
-  if ((part == NativeTheme::kPushButton) &&
-      ((state == NativeTheme::kPressed) || extra_params.is_default)) {
-    // Pressed or defaulted buttons have a shadow replacing the outer 1 px.
-    if (HBRUSH brush = GetSysColorBrush(COLOR_3DDKSHADOW)) {
-      FrameRect(hdc, rect, brush);
-      InflateRect(rect, -1, -1);
+NativeThemeWin::NativeThemeWin() {
+  // By default UI should not use the system accent color.
+  set_should_use_system_accent_color(false);
+
+  // The below code attempts calls to user32.dll, so avoid it if those calls are
+  // not possible.
+  if (base::win::IsUser32AndGdi32Available()) {
+    // If there's no sequenced task runner handle, we can't be called back for
+    // registry changes. This generally happens in tests.
+    const bool observers_can_operate =
+        base::SequencedTaskRunner::HasCurrentDefault();
+
+    hkcu_themes_regkey_ = OpenThemeRegKey(KEY_READ | KEY_NOTIFY);
+    if (hkcu_themes_regkey_.Valid()) {
+      if (!IsForcedDarkMode() && !IsForcedHighContrast()) {
+        UpdateDarkModeStatus();
+      }
+      UpdatePrefersReducedTransparency();
+      if (observers_can_operate) {
+        RegisterThemeRegkeyObserver();
+      }
     }
-  }
 
-  int classic_state = extra_params.classic_state;
-  if (part == NativeTheme::kCheckbox) {
-    classic_state |= DFCS_BUTTONCHECK;
-  } else if (part == NativeTheme::kPushButton) {
-    classic_state |= DFCS_BUTTONRADIO;
-  } else if (part == NativeTheme::kRadio) {
-    classic_state |= DFCS_BUTTONPUSH;
-  }
-  if (state == NativeTheme::kDisabled) {
-    classic_state |= DFCS_INACTIVE;
-  } else if (state == NativeTheme::kPressed) {
-    classic_state |= DFCS_PUSHED;
-  }
-  if (extra_params.checked) {
-    classic_state |= DFCS_CHECKED;
-  }
-  DrawFrameControl(hdc, rect, DFC_BUTTON, classic_state);
+    hkcu_color_filtering_regkey_ =
+        OpenColorFilteringRegKey(KEY_READ | KEY_NOTIFY);
+    if (hkcu_color_filtering_regkey_.Valid()) {
+      UpdateInvertedColors();
+      if (observers_can_operate) {
+        RegisterColorFilteringRegkeyObserver();
+      }
+    }
 
-  // Draw a focus rectangle (the dotted line box) on defaulted buttons.
-  if ((part == NativeTheme::kPushButton) && extra_params.is_default) {
-    InflateRect(rect, -GetSystemMetrics(SM_CXEDGE),
-                -GetSystemMetrics(SM_CYEDGE));
-    DrawFocusRect(hdc, rect);
+    if (!IsForcedHighContrast()) {
+      set_forced_colors(IsUsingHighContrastThemeInternal());
+    }
+
+    UpdateSystemColors();
   }
 
-  // Classic theme doesn't support indeterminate checkboxes.  We draw a
-  // rectangle inside a checkbox like IE10 does.
-  if ((part == NativeTheme::kCheckbox) && extra_params.indeterminate) {
-    RECT inner_rect = *rect;
-    // "4 / 13" matches IE10 in classic theme.
-    const int padding = (inner_rect.right - inner_rect.left) * 4 / 13;
-    InflateRect(&inner_rect, -padding, -padding);
-    FillRect(
-        hdc, &inner_rect,
-        GetSysColorBrush((state == NativeTheme::kDisabled) ? COLOR_GRAYTEXT
-                                                           : COLOR_WINDOWTEXT));
+  set_preferred_color_scheme(CalculatePreferredColorScheme());
+  SetPreferredContrast(CalculatePreferredContrast());
+
+  memset(theme_handles_, 0, sizeof(theme_handles_));
+
+  // Histogram high contrast state.
+  // NOTE: Reported in metrics; do not reorder, add additional values at end.
+  enum class HighContrastColorScheme {
+    kNone = 0,
+    kDark = 1,
+    kLight = 2,
+    kMaxValue = kLight,
+  };
+  auto color_scheme = HighContrastColorScheme::kNone;
+  if (forced_colors()) {
+    color_scheme =
+        (preferred_color_scheme() == NativeTheme::PreferredColorScheme::kDark)
+            ? HighContrastColorScheme::kDark
+            : HighContrastColorScheme::kLight;
   }
+  base::UmaHistogramEnumeration("Accessibility.WinHighContrastTheme",
+                                color_scheme);
 }
 
-void PaintLeftMenuArrowThemed(HDC hdc,
-                              HANDLE handle,
-                              int part_id,
-                              int state_id,
-                              const gfx::Rect& rect) {
-  // There is no way to tell the uxtheme API to draw a left pointing arrow; it
-  // doesn't have a flag equivalent to `DFCS_MENUARROWRIGHT`.  But they are
-  // needed for RTL locales on Vista.  So use a memory DC and mirror the region
-  // with GDI's `StretchBlt()`.
-  base::win::ScopedCreateDC mem_dc(CreateCompatibleDC(hdc));
-  base::win::ScopedGDIObject<HBITMAP> mem_bitmap(
-      CreateCompatibleBitmap(hdc, rect.width(), rect.height()));
-  base::win::ScopedSelectObject select_bitmap(mem_dc.Get(), mem_bitmap.get());
-  // Copy and horizontally mirror the background from hdc into mem_dc. Use a
-  // negative-width source rect, starting at the rightmost pixel.
-  StretchBlt(mem_dc.Get(), 0, 0, rect.width(), rect.height(), hdc,
-             rect.right() - 1, rect.y(), -rect.width(), rect.height(), SRCCOPY);
-  // Draw the arrow.
-  RECT theme_rect = {
-      .left = 0, .top = 0, .right = rect.width(), .bottom = rect.height()};
-  DrawThemeBackground(handle, mem_dc.Get(), part_id, state_id, &theme_rect,
-                      nullptr);
-  // Copy and mirror the result back into mem_dc.
-  StretchBlt(hdc, rect.x(), rect.y(), rect.width(), rect.height(), mem_dc.Get(),
-             rect.width() - 1, 0, -rect.width(), rect.height(), SRCCOPY);
+NativeThemeWin::~NativeThemeWin() {
+  // TODO(crbug.com/40551168): Calling CloseHandles() here breaks
+  // certain tests and the reliability bots.
+  // CloseHandles();
 }
 
-void PaintScrollbarArrowClassic(HDC hdc,
-                                NativeTheme::Part part,
-                                NativeTheme::State state,
-                                RECT* rect) {
-  static constexpr auto kParts = std::to_array(
-      {DFCS_SCROLLDOWN, DFCS_SCROLLLEFT, DFCS_SCROLLRIGHT, DFCS_SCROLLUP});
-  static constexpr auto kStates =
-      std::to_array({DFCS_INACTIVE, DFCS_HOT, 0, DFCS_PUSHED});
-  DrawFrameControl(
-      hdc, rect, DFC_SCROLL,
-      kParts[part - NativeTheme::kScrollbarDownArrow] | kStates[state]);
+bool NativeThemeWin::IsUsingHighContrastThemeInternal() const {
+  HIGHCONTRAST result;
+  result.cbSize = sizeof(HIGHCONTRAST);
+  return SystemParametersInfo(SPI_GETHIGHCONTRAST, result.cbSize, &result, 0) &&
+         (result.dwFlags & HCF_HIGHCONTRASTON) == HCF_HIGHCONTRASTON;
 }
 
-void PaintScrollbarTrackClassic(
-    SkCanvas* canvas,
-    HDC hdc,
-    RECT* rect,
-    const NativeTheme::ScrollbarTrackExtraParams& extra_params) {
-  const auto& os_settings_provider = OsSettingsProvider::Get();
-  using enum OsSettingsProvider::ColorId;
-  if (const auto scrollbar_color = os_settings_provider.Color(kScrollbar);
-      (scrollbar_color != os_settings_provider.Color(kButtonFace)) &&
-      (scrollbar_color != os_settings_provider.Color(kWindow))) {
-    FillRect(hdc, rect, reinterpret_cast<HBRUSH>(COLOR_SCROLLBAR + 1));
-  } else {
-    SkPaint paint;
-    SetCheckerboardShader(&paint, extra_params.track_x, extra_params.track_y);
-    canvas->drawIRect(skia::RECTToSkIRect(*rect), paint);
-  }
-  if (extra_params.classic_state & DFCS_PUSHED) {
-    InvertRect(hdc, rect);
+void NativeThemeWin::CloseHandlesInternal() {
+  for (int i = 0; i < LAST; ++i) {
+    if (theme_handles_[i]) {
+      CloseThemeData(theme_handles_[i]);
+      theme_handles_[i] = nullptr;
+    }
   }
 }
 
-void PaintHorizontalTrackbarThumbClassic(
-    SkCanvas* canvas,
-    HDC hdc,
-    const RECT& rect,
-    const NativeTheme::TrackbarExtraParams& extra_params) {
-  // Split rect into top and bottom pieces.
-  const int half_thickness = (rect.right - rect.left) / 2;
-  RECT top_section = rect;
-  top_section.bottom -= half_thickness;
-  DrawEdge(hdc, &top_section, EDGE_RAISED,
-           BF_LEFT | BF_TOP | BF_RIGHT | BF_SOFT | BF_MIDDLE | BF_ADJUST);
-
-  // Split bottom piece into two halves.
-  RECT left_half = rect;
-  left_half.top = top_section.bottom;
-  RECT right_half = left_half;
-  right_half.left += half_thickness;
-  left_half.right = right_half.left;
-  DrawEdge(hdc, &left_half, EDGE_RAISED,
-           BF_DIAGONAL_ENDTOPLEFT | BF_SOFT | BF_MIDDLE | BF_ADJUST);
-  DrawEdge(hdc, &right_half, EDGE_RAISED,
-           BF_DIAGONAL_ENDBOTTOMLEFT | BF_SOFT | BF_MIDDLE | BF_ADJUST);
-
-  if (!(extra_params.classic_state & DFCS_PUSHED)) {
+void NativeThemeWin::OnWndProc(HWND hwnd,
+                               UINT message,
+                               WPARAM wparam,
+                               LPARAM lparam) {
+  if (message != WM_SYSCOLORCHANGE &&
+      (message != WM_SETTINGCHANGE || wparam != SPI_SETHIGHCONTRAST)) {
     return;
   }
 
-  // Draw hatching.
-  SkPaint paint;
-  SetCheckerboardShader(&paint, rect.left, rect.top);
-
-  // Fill all three pieces with the pattern.
-  canvas->drawIRect(skia::RECTToSkIRect(top_section), paint);
-
-  const SkScalar left_triangle_top = SkIntToScalar(left_half.top);
-  const SkScalar left_triangle_right = SkIntToScalar(left_half.right);
-  SkPath left_triangle;
-  left_triangle.moveTo(SkIntToScalar(left_half.left), left_triangle_top);
-  left_triangle.lineTo(left_triangle_right, left_triangle_top);
-  left_triangle.lineTo(left_triangle_right, SkIntToScalar(left_half.bottom));
-  left_triangle.close();
-  canvas->drawPath(left_triangle, paint);
-
-  const SkScalar right_triangle_left = SkIntToScalar(right_half.left);
-  const SkScalar right_triangle_top = SkIntToScalar(right_half.top);
-  SkPath right_triangle;
-  right_triangle.moveTo(right_triangle_left, right_triangle_top);
-  right_triangle.lineTo(SkIntToScalar(right_half.right), right_triangle_top);
-  right_triangle.lineTo(right_triangle_left, SkIntToScalar(right_half.bottom));
-  right_triangle.close();
-  canvas->drawPath(right_triangle, paint);
-}
-
-void PaintProgressBarOverlayThemed(
-    HDC hdc,
-    HANDLE handle,
-    RECT* bar_rect,
-    RECT* value_rect,
-    const NativeTheme::ProgressBarExtraParams& extra_params) {
-  // There is no documentation about the animation of the indeterminate progress
-  // bar. The following are guesses based on observing other programs.
-  constexpr int kOverlayWidth = 120;
-  const int pixels_per_second = extra_params.determinate ? 300 : 175;
-
-  int bar_width = bar_rect->right - bar_rect->left;
-  RECT overlay_rect;
-  if (extra_params.determinate) {
-    // We care about the direction here because PP_CHUNK painting is asymmetric.
-    // TODO(morrita): This RTL guess can be wrong.  We should pass in the
-    // direction from WebKit.
-    const bool mirror = bar_rect->right == value_rect->right &&
-                        bar_rect->left != value_rect->left;
-    const DTBGOPTS value_draw_options = {
-        .dwSize = sizeof(DTBGOPTS),
-        .dwFlags = static_cast<DWORD>(mirror ? DTBG_MIRRORDC : 0),
-        .rcClip = *bar_rect};
-
-    // On Vista or later, the progress bar part has a single-block value part
-    // and a glossy effect. The value part has exactly same height as the bar
-    // part, so we don't need to shrink the rect.
-    DrawThemeBackgroundEx(handle, hdc, PP_FILL, 0, value_rect,
-                          &value_draw_options);
-
-    overlay_rect = *value_rect;
-  } else {
-    // The glossy overlay for the indeterminate progress bar has a small pause
-    // after each animation. Emulate this by adding an invisible margin the
-    // animation has to traverse.
-    bar_width += pixels_per_second;
-    overlay_rect = *bar_rect;
+  UpdateSystemColors();
+  if (!IsForcedHighContrast()) {
+    set_forced_colors(IsUsingHighContrastThemeInternal());
   }
-
-  const int animation_width = bar_width + kOverlayWidth;
-  const double interval =
-      static_cast<double>(animation_width) / pixels_per_second;
-  const double ratio =
-      std::fmod(extra_params.animated_seconds, interval) / interval;
-  overlay_rect.right =
-      overlay_rect.left + base::ClampFloor(animation_width * ratio);
-  overlay_rect.left = overlay_rect.right - kOverlayWidth;
-  DrawThemeBackground(handle, hdc, PP_MOVEOVERLAY, 0, &overlay_rect,
-                      extra_params.determinate ? value_rect : bar_rect);
+  set_preferred_color_scheme(CalculatePreferredColorScheme());
+  SetPreferredContrast(CalculatePreferredContrast());
+  NotifyOnNativeThemeUpdated();
 }
 
-void PaintTextFieldThemed(
-    HDC hdc,
-    HANDLE handle,
-    HBRUSH bg_brush,
-    int part_id,
-    int state_id,
-    RECT* rect,
-    const NativeTheme::TextFieldExtraParams& extra_params) {
-  static constexpr DTBGOPTS kOmitBorderOptions = {.dwSize = sizeof(DTBGOPTS),
-                                                  .dwFlags = DTBG_OMITBORDER,
-                                                  .rcClip = {0, 0, 0, 0}};
-  DrawThemeBackgroundEx(
-      handle, hdc, part_id, state_id, rect,
-      extra_params.draw_edges ? nullptr : &kOmitBorderOptions);
-
-  if (extra_params.fill_content_area) {
-    RECT content_rect;
-    GetThemeBackgroundContentRect(handle, hdc, part_id, state_id, rect,
-                                  &content_rect);
-    FillRect(hdc, &content_rect, bg_brush);
+void NativeThemeWin::UpdateSystemColors() {
+  static constexpr auto kColors =
+      std::to_array<std::pair<SystemThemeColor, ui::ColorId>>(
+          {{SystemThemeColor::kButtonFace, kColorNativeBtnFace},
+           {SystemThemeColor::kButtonHighlight, kColorNativeBtnHighlight},
+           {SystemThemeColor::kButtonText, kColorNativeBtnText},
+           {SystemThemeColor::kGrayText, kColorNativeGrayText},
+           {SystemThemeColor::kHighlight, kColorNativeHighlight},
+           {SystemThemeColor::kHighlightText, kColorNativeHighlightText},
+           {SystemThemeColor::kHotlight, kColorNativeHotlight},
+           {SystemThemeColor::kMenuHighlight, kColorNativeMenuHilight},
+           {SystemThemeColor::kScrollbar, kColorNativeScrollbar},
+           {SystemThemeColor::kWindow, kColorNativeWindow},
+           {SystemThemeColor::kWindowText, kColorNativeWindowText}});
+  const auto sys_colors = GetCurrentSysColors();
+  for (const auto& entry : kColors) {
+    system_colors_[entry.first] = sys_colors.at(entry.second);
   }
 }
 
-void PaintTextFieldClassic(
-    HDC hdc,
-    HBRUSH bg_brush,
-    RECT* rect,
-    const NativeTheme::TextFieldExtraParams& extra_params) {
-  if (extra_params.draw_edges) {
-    DrawEdge(hdc, rect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
+void NativeThemeWin::PaintMenuSeparator(
+    cc::PaintCanvas* canvas,
+    const ColorProvider* color_provider,
+    const MenuSeparatorExtraParams& params) const {
+  DCHECK(color_provider);
+  const gfx::RectF rect(*params.paint_rect);
+  gfx::PointF start = rect.CenterPoint();
+  gfx::PointF end = start;
+  if (params.type == ui::VERTICAL_SEPARATOR) {
+    start.set_y(rect.y());
+    end.set_y(rect.bottom());
+  } else {
+    start.set_x(rect.x());
+    end.set_x(rect.right());
   }
 
-  if (extra_params.fill_content_area) {
-    if (extra_params.classic_state & DFCS_INACTIVE) {
-      bg_brush = reinterpret_cast<HBRUSH>(COLOR_BTNFACE + 1);
-    }
-    FillRect(hdc, rect, bg_brush);
-  }
+  cc::PaintFlags flags;
+  flags.setColor(color_provider->GetColor(kColorMenuSeparator));
+  canvas->drawLine(start.x(), start.y(), end.x(), end.y(), flags);
 }
 
-void PaintScaledTheme(HANDLE theme,
-                      HDC hdc,
-                      int part_id,
-                      int state_id,
-                      const gfx::Rect& rect) {
-  // Correct the scaling and positioning of sub-components such as scrollbar
-  // arrows and thumb grippers in the event that the world transform applies
-  // scaling (e.g. in high-DPI mode).
-  if (XFORM save_transform; GetWorldTransform(hdc, &save_transform)) {
-    if (float scale = save_transform.eM11;
-        scale != 1 && save_transform.eM12 == 0) {
-      ModifyWorldTransform(hdc, NULL, MWT_IDENTITY);
-      gfx::Rect scaled_rect = gfx::ScaleToEnclosedRect(rect, scale);
-      scaled_rect.Offset(save_transform.eDx, save_transform.eDy);
-      RECT bounds = scaled_rect.ToRECT();
-      DrawThemeBackground(theme, hdc, part_id, state_id, &bounds, nullptr);
-      SetWorldTransform(hdc, &save_transform);
-      return;
-    }
-  }
-  RECT bounds = rect.ToRECT();
-  DrawThemeBackground(theme, hdc, part_id, state_id, &bounds, nullptr);
+void NativeThemeWin::PaintMenuGutter(cc::PaintCanvas* canvas,
+                                     const ColorProvider* color_provider,
+                                     const gfx::Rect& rect) const {
+  DCHECK(color_provider);
+  cc::PaintFlags flags;
+  flags.setColor(color_provider->GetColor(kColorMenuSeparator));
+  int position_x = rect.x() + rect.width() / 2;
+  canvas->drawLine(position_x, rect.y(), position_x, rect.bottom(), flags);
 }
 
-void PaintFrameControl(HDC hdc,
-                       const gfx::Rect& rect,
-                       UINT type,
-                       UINT state,
-                       bool is_selected,
-                       NativeTheme::State control_state) {
-  const int width = rect.width();
-  const int height = rect.height();
-
-  // `DrawFrameControl()` for menu arrow/check wants a monochrome bitmap.
-  base::win::ScopedGDIObject<HBITMAP> mask_bitmap(
-      CreateBitmap(width, height, 1, 1, nullptr));
-  if (!mask_bitmap.get()) {
-    return;
-  }
-
-  base::win::ScopedCreateDC bitmap_dc(CreateCompatibleDC(nullptr));
-  base::win::ScopedSelectObject select_bitmap(bitmap_dc.Get(),
-                                              mask_bitmap.get());
-  RECT local_rect = {.left = 0, .top = 0, .right = width, .bottom = height};
-  DrawFrameControl(bitmap_dc.Get(), &local_rect, type, state);
-
-  // We're going to use `BitBlt()` with a black-and-white mask. This results in
-  // using the dest DC's text color for the black bits in the mask, and the dest
-  // DC's background color for the white bits in the mask. `DrawFrameControl()`
-  // draws the check in black, and the background in white.
-  int bg_color_key = COLOR_MENU;
-  int text_color_key = COLOR_MENUTEXT;
-  if (control_state == NativeTheme::kDisabled) {
-    bg_color_key = is_selected ? COLOR_HIGHLIGHT : COLOR_MENU;
-    text_color_key = COLOR_GRAYTEXT;
-  } else if (control_state == NativeTheme::kHovered) {
-    bg_color_key = COLOR_HIGHLIGHT;
-    text_color_key = COLOR_HIGHLIGHTTEXT;
-  }
-  const COLORREF old_bg_color = SetBkColor(hdc, GetSysColor(bg_color_key));
-  const COLORREF old_text_color =
-      SetTextColor(hdc, GetSysColor(text_color_key));
-  BitBlt(hdc, rect.x(), rect.y(), width, height, bitmap_dc.Get(), 0, 0,
-         SRCCOPY);
-  SetBkColor(hdc, old_bg_color);
-  SetTextColor(hdc, old_text_color);
+void NativeThemeWin::PaintMenuBackground(cc::PaintCanvas* canvas,
+                                         const ColorProvider* color_provider,
+                                         const gfx::Rect& rect) const {
+  DCHECK(color_provider);
+  cc::PaintFlags flags;
+  flags.setColor(color_provider->GetColor(kColorMenuBackground));
+  canvas->drawRect(gfx::RectToSkRect(rect), flags);
 }
 
-void PaintDirect(SkCanvas* destination_canvas,
-                 HDC hdc,
-                 NativeTheme::Part part,
-                 NativeTheme::State state,
-                 const gfx::Rect& rect,
-                 const NativeTheme::ExtraParams& extra_params) {
-  if (part == NativeTheme::kScrollbarCorner) {
+void NativeThemeWin::PaintDirect(SkCanvas* destination_canvas,
+                                 HDC hdc,
+                                 Part part,
+                                 State state,
+                                 const gfx::Rect& rect,
+                                 const ExtraParams& extra) const {
+  if (part == kScrollbarCorner) {
     // Special-cased here since there is no theme name for kScrollbarCorner.
     destination_canvas->drawColor(SK_ColorWHITE, SkBlendMode::kSrc);
     return;
   }
 
   RECT rect_win = rect.ToRECT();
-  if (part == NativeTheme::kTrackbarTrack) {
+  if (part == kTrackbarTrack) {
     // Make the channel be 4 px thick in the center of the supplied rect.  (4 px
-    // matches what XP does in various menus; `GetThemePartSize()` doesn't seem
-    // to return good values here.)
+    // matches what XP does in various menus; GetThemePartSize() doesn't seem to
+    // return good values here.)
     constexpr int kChannelThickness = 4;
-    if (std::get<NativeTheme::TrackbarExtraParams>(extra_params).vertical) {
+    if (std::get<TrackbarExtraParams>(extra).vertical) {
       rect_win.top += (rect_win.bottom - rect_win.top - kChannelThickness) / 2;
       rect_win.bottom = rect_win.top + kChannelThickness;
     } else {
@@ -767,76 +456,89 @@ void PaintDirect(SkCanvas* destination_canvas,
   }
 
   // Most parts can be drawn simply when there is a theme handle.
-  const HANDLE handle = GetThemeHandle(part);
-  const int part_id = GetWindowsPart(part, extra_params);
-  const int state_id = GetWindowsState(part, state, extra_params);
+  const HANDLE handle = GetThemeHandle(GetThemeName(part));
+  const int part_id = GetWindowsPart(part, state, extra);
+  const int state_id = GetWindowsState(part, state, extra);
   if (handle) {
-    if (part == NativeTheme::kMenuPopupArrow &&
-        !std::get<NativeTheme::MenuArrowExtraParams>(extra_params)
-             .pointing_right) {
-      // The right-pointing arrow can use the common code, but the left-pointing
-      // one needs custom code.
-      PaintLeftMenuArrowThemed(hdc, handle, part_id, state_id, rect);
-      return;
-    }
-    if (part >= NativeTheme::kScrollbarDownArrow &&
-        part <= NativeTheme::kScrollbarVerticalThumb) {
-      PaintScaledTheme(handle, hdc, part_id, state_id, rect);
-      return;
-    }
-    if (part == NativeTheme::kCheckbox ||
-        part == NativeTheme::kInnerSpinButton ||
-        part == NativeTheme::kMenuList || part == NativeTheme::kMenuCheck ||
-        part == NativeTheme::kMenuCheckBackground ||
-        part == NativeTheme::kMenuPopupArrow ||
-        part == NativeTheme::kProgressBar || part == NativeTheme::kPushButton ||
-        part == NativeTheme::kRadio ||
-        part == NativeTheme::kScrollbarHorizontalTrack ||
-        part == NativeTheme::kScrollbarVerticalTrack ||
-        part == NativeTheme::kTabPanelBackground ||
-        part == NativeTheme::kTrackbarThumb ||
-        part == NativeTheme::kTrackbarTrack ||
-        part == NativeTheme::kWindowResizeGripper) {
-      DrawThemeBackground(handle, hdc, part_id, state_id, &rect_win, nullptr);
-      if (part != NativeTheme::kProgressBar) {
+    switch (part) {
+      case kMenuPopupArrow:
+        // The right-pointing arrow can use the common code, but the
+        // left-pointing one needs custom code.
+        if (!std::get<MenuArrowExtraParams>(extra).pointing_right) {
+          PaintLeftMenuArrowThemed(hdc, handle, part_id, state_id, rect);
+          return;
+        }
+        [[fallthrough]];
+      case kCheckbox:
+      case kInnerSpinButton:
+      case kMenuCheck:
+      case kMenuCheckBackground:
+      case kMenuList:
+      case kProgressBar:
+      case kPushButton:
+      case kRadio:
+      case kScrollbarHorizontalTrack:
+      case kScrollbarVerticalTrack:
+      case kTabPanelBackground:
+      case kTrackbarThumb:
+      case kTrackbarTrack:
+      case kWindowResizeGripper:
+        DrawThemeBackground(handle, hdc, part_id, state_id, &rect_win, nullptr);
+        if (part == kProgressBar) {
+          break;  // Further painting to do below.
+        }
         return;
-      }
+      case kScrollbarDownArrow:
+      case kScrollbarHorizontalGripper:
+      case kScrollbarHorizontalThumb:
+      case kScrollbarLeftArrow:
+      case kScrollbarRightArrow:
+      case kScrollbarUpArrow:
+      case kScrollbarVerticalGripper:
+      case kScrollbarVerticalThumb:
+        PaintScaledTheme(handle, hdc, part_id, state_id, rect);
+        return;
+      case kTextField:
+        break;  // Handled entirely below.
+      case kMenuItemBackground:
+      case kMenuPopupBackground:
+      case kMenuPopupGutter:
+      case kMenuPopupSeparator:
+      case kScrollbarCorner:
+      case kSliderTrack:
+      case kSliderThumb:
+      case kMaxPart:
+        NOTREACHED();
     }
   }
 
   // Do any further painting the common code couldn't handle.
   switch (part) {
-    case NativeTheme::kCheckbox:
-    case NativeTheme::kPushButton:
-    case NativeTheme::kRadio:
-      PaintButtonClassic(
-          hdc, part, state, &rect_win,
-          std::get<NativeTheme::ButtonExtraParams>(extra_params));
+    case kCheckbox:
+    case kPushButton:
+    case kRadio:
+      PaintButtonClassic(hdc, part, state, &rect_win,
+                         std::get<ButtonExtraParams>(extra));
       return;
-    case NativeTheme::kInnerSpinButton:
+    case kInnerSpinButton:
       DrawFrameControl(
           hdc, &rect_win, DFC_SCROLL,
-          std::get<NativeTheme::InnerSpinButtonExtraParams>(extra_params)
-              .classic_state);
+          std::get<InnerSpinButtonExtraParams>(extra).classic_state);
       return;
-    case NativeTheme::kMenuCheck: {
-      const auto& menu_check =
-          std::get<NativeTheme::MenuCheckExtraParams>(extra_params);
+    case kMenuCheck: {
+      const auto& menu_check = std::get<MenuCheckExtraParams>(extra);
       PaintFrameControl(hdc, rect, DFC_MENU,
                         menu_check.is_radio ? DFCS_MENUBULLET : DFCS_MENUCHECK,
                         menu_check.is_selected, state);
       return;
     }
-    case NativeTheme::kMenuList:
-      DrawFrameControl(
-          hdc, &rect_win, DFC_SCROLL,
-          DFCS_SCROLLCOMBOBOX |
-              std::get<NativeTheme::MenuListExtraParams>(extra_params)
-                  .classic_state);
+    case kMenuList:
+      DrawFrameControl(hdc, &rect_win, DFC_SCROLL,
+                       DFCS_SCROLLCOMBOBOX |
+                           std::get<MenuListExtraParams>(extra).classic_state);
       return;
-    case NativeTheme::kMenuPopupArrow: {
-      const auto& menu_arrow =
-          std::get<NativeTheme::MenuArrowExtraParams>(extra_params);
+    case kMenuPopupArrow: {
+      const auto& menu_arrow = std::get<MenuArrowExtraParams>(extra);
       // For some reason, Windows uses the name DFCS_MENUARROWRIGHT to indicate
       // a left pointing arrow.
       PaintFrameControl(
@@ -845,9 +547,8 @@ void PaintDirect(SkCanvas* destination_canvas,
           menu_arrow.is_selected, state);
       return;
     }
-    case NativeTheme::kProgressBar: {
-      const auto& progress_bar =
-          std::get<NativeTheme::ProgressBarExtraParams>(extra_params);
+    case kProgressBar: {
+      const auto& progress_bar = std::get<ProgressBarExtraParams>(extra);
       RECT value_rect =
           gfx::Rect(progress_bar.value_rect_x, progress_bar.value_rect_y,
                     progress_bar.value_rect_width,
@@ -863,32 +564,30 @@ void PaintDirect(SkCanvas* destination_canvas,
       }
       return;
     }
-    case NativeTheme::kScrollbarDownArrow:
-    case NativeTheme::kScrollbarLeftArrow:
-    case NativeTheme::kScrollbarRightArrow:
-    case NativeTheme::kScrollbarUpArrow:
+    case kScrollbarDownArrow:
+    case kScrollbarLeftArrow:
+    case kScrollbarRightArrow:
+    case kScrollbarUpArrow:
       PaintScrollbarArrowClassic(hdc, part, state, &rect_win);
       return;
-    case NativeTheme::kScrollbarHorizontalThumb:
-    case NativeTheme::kScrollbarVerticalThumb:
+    case kScrollbarHorizontalThumb:
+    case kScrollbarVerticalThumb:
       DrawEdge(hdc, &rect_win, EDGE_RAISED, BF_RECT | BF_MIDDLE);
       return;
-    case NativeTheme::kScrollbarHorizontalTrack:
-    case NativeTheme::kScrollbarVerticalTrack:
-      PaintScrollbarTrackClassic(
-          destination_canvas, hdc, &rect_win,
-          std::get<NativeTheme::ScrollbarTrackExtraParams>(extra_params));
+    case kScrollbarHorizontalTrack:
+    case kScrollbarVerticalTrack:
+      PaintScrollbarTrackClassic(destination_canvas, hdc, &rect_win,
+                                 std::get<ScrollbarTrackExtraParams>(extra));
       return;
-    case NativeTheme::kTabPanelBackground:
+    case kTabPanelBackground:
       // Classic just renders a flat color background.
       FillRect(hdc, &rect_win, reinterpret_cast<HBRUSH>(COLOR_3DFACE + 1));
       return;
-    case NativeTheme::kTextField: {
+    case kTextField: {
       // TODO(mpcomplete): can we detect if the color is specified by the user,
       // and if not, just use the system color?
       // CreateSolidBrush() accepts a RGB value but alpha must be 0.
-      const auto& text_field =
-          std::get<NativeTheme::TextFieldExtraParams>(extra_params);
+      const auto& text_field = std::get<TextFieldExtraParams>(extra);
       base::win::ScopedGDIObject<HBRUSH> bg_brush(CreateSolidBrush(
           skia::SkColorToCOLORREF(text_field.background_color)));
       if (handle) {
@@ -899,9 +598,8 @@ void PaintDirect(SkCanvas* destination_canvas,
       }
       return;
     }
-    case NativeTheme::kTrackbarThumb: {
-      const auto& trackbar =
-          std::get<NativeTheme::TrackbarExtraParams>(extra_params);
+    case kTrackbarThumb: {
+      const auto& trackbar = std::get<TrackbarExtraParams>(extra);
       if (trackbar.vertical) {
         DrawEdge(hdc, &rect_win, EDGE_RAISED, BF_RECT | BF_SOFT | BF_MIDDLE);
       } else {
@@ -910,33 +608,134 @@ void PaintDirect(SkCanvas* destination_canvas,
       }
       return;
     }
-    case NativeTheme::kTrackbarTrack:
+    case kTrackbarTrack:
       DrawEdge(hdc, &rect_win, EDGE_SUNKEN, BF_RECT);
       return;
-    case NativeTheme::kWindowResizeGripper:
+    case kWindowResizeGripper:
       // Draw a windows classic scrollbar gripper.
       DrawFrameControl(hdc, &rect_win, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
       return;
-    default:
-      return;
+    case kMenuCheckBackground:
+    case kScrollbarHorizontalGripper:
+    case kScrollbarVerticalGripper:
+      return;  // No further painting necessary.
+    case kMenuItemBackground:
+    case kMenuPopupBackground:
+    case kMenuPopupGutter:
+    case kMenuPopupSeparator:
+    case kScrollbarCorner:
+    case kSliderTrack:
+    case kSliderThumb:
+    case kMaxPart:
+      NOTREACHED();
   }
 }
 
-void PaintIndirect(cc::PaintCanvas* destination_canvas,
-                   NativeTheme::Part part,
-                   NativeTheme::State state,
-                   const gfx::Rect& rect,
-                   NativeTheme::ExtraParams extra_params) {
-  // TODO(asvitkine): This path is pretty inefficient - for each paint operation
-  // it creates a new offscreen bitmap Skia canvas. This can be sped up by doing
-  // it only once per part/state and keeping a cache of the resulting bitmaps.
-  //
-  // TODO(enne): This could also potentially be sped up for software raster
-  // by moving these draw ops into `PaintRecord` itself and then moving the
-  // `PaintDirect()` code to be part of the raster for `PaintRecord`.
+bool NativeThemeWin::SupportsNinePatch(Part part) const {
+  // The only nine-patch resources currently supported (overlay scrollbar) are
+  // painted by NativeThemeAura on Windows.
+  return false;
+}
 
-  // If this process doesn't have access to GDI, we'd need to use a shared
-  // memory segment instead, but that is not supported right now.
+gfx::Size NativeThemeWin::GetNinePatchCanvasSize(Part part) const {
+  NOTREACHED() << "NativeThemeWin doesn't support nine-patch resources.";
+}
+
+gfx::Rect NativeThemeWin::GetNinePatchAperture(Part part) const {
+  NOTREACHED() << "NativeThemeWin doesn't support nine-patch resources.";
+}
+
+NativeTheme::PreferredColorScheme
+NativeThemeWin::CalculatePreferredColorScheme() const {
+  if (IsForcedDarkMode()) {
+    return NativeTheme::PreferredColorScheme::kDark;
+  }
+
+  if (forced_colors()) {
+    // According to the spec, the preferred color scheme for web content is
+    // "dark" if the Canvas color has L<33% and "light" if L>67%, where "L" is
+    // LAB lightness. The Canvas color is mapped to the Window system color.
+    // https://www.w3.org/TR/css-color-adjust-1/#forced
+    if (const auto bg_color = GetSystemThemeColor(SystemThemeColor::kWindow)) {
+      const SkColor srgb_legacy = bg_color.value();
+      const auto [r, g, b] = gfx::SRGBLegacyToSRGB(SkColorGetR(srgb_legacy),
+                                                   SkColorGetG(srgb_legacy),
+                                                   SkColorGetB(srgb_legacy));
+      const auto [x, y, z] = gfx::SRGBToXYZD50(r, g, b);
+      const float lab_lightness = std::get<0>(gfx::XYZD50ToLab(x, y, z));
+      if (lab_lightness < 33.0f) {
+        return PreferredColorScheme::kDark;
+      }
+      if (lab_lightness > 67.0f) {
+        return PreferredColorScheme::kLight;
+      }
+    }
+  }
+
+  return in_dark_mode_ ? NativeTheme::PreferredColorScheme::kDark
+                       : NativeTheme::PreferredColorScheme::kLight;
+}
+
+NativeTheme::PreferredContrast NativeThemeWin::CalculatePreferredContrast()
+    const {
+  if (!forced_colors() || IsForcedHighContrast()) {
+    return NativeTheme::CalculatePreferredContrast();
+  }
+
+  // TODO(sartang@microsoft.com): Update the spec page at
+  // https://www.w3.org/TR/css-color-adjust-1/#forced, it currently does not
+  // mention the relation between forced-colors-active and prefers-contrast.
+  //
+  // According to spec [1], "in addition to forced-colors: active, the user
+  // agent must also match one of prefers-contrast: more or
+  // prefers-contrast: less if it can determine that the forced color
+  // palette chosen by the user has a particularly high or low contrast,
+  // and must make prefers-contrast: custom match otherwise".
+  //
+  // Using WCAG definitions [2], we have decided to match 'more' in Forced
+  // Colors Mode if the contrast ratio between the foreground and background
+  // color is 7:1 or greater.
+  //
+  // "A contrast ratio of 3:1 is the minimum level recommended by [[ISO-9241-3]]
+  // and [[ANSI-HFES-100-1988]] for standard text and vision"[2]. Given this,
+  // we will start by matching to 'less' in Forced Colors Mode if the contrast
+  // ratio between the foreground and background color is 2.5:1 or less.
+  //
+  // These ratios will act as an experimental baseline that we can adjust based
+  // on user feedback.
+  //
+  // [1]
+  // https://drafts.csswg.org/mediaqueries-5/#valdef-media-forced-colors-active
+  // [2] https://www.w3.org/WAI/WCAG21/Understanding/contrast-enhanced
+  if (const auto bg_color = GetSystemThemeColor(SystemThemeColor::kWindow),
+      fg_color = GetSystemThemeColor(SystemThemeColor::kWindowText);
+      bg_color.has_value() && fg_color.has_value()) {
+    const float contrast_ratio =
+        color_utils::GetContrastRatio(bg_color.value(), fg_color.value());
+    if (contrast_ratio >= 7) {
+      return PreferredContrast::kMore;
+    }
+    return contrast_ratio <= 2.5 ? PreferredContrast::kLess
+                                 : PreferredContrast::kCustom;
+  }
+  return PreferredContrast::kNoPreference;
+}
+
+void NativeThemeWin::PaintIndirect(cc::PaintCanvas* destination_canvas,
+                                   Part part,
+                                   State state,
+                                   const gfx::Rect& rect,
+                                   const ExtraParams& extra) const {
+  // TODO(asvitkine): This path is pretty inefficient - for each paint operation
+  // it creates a new offscreen bitmap Skia canvas. This can be sped up by doing
+  // it only once per part/state and keeping a cache of the resulting bitmaps.
+  //
+  // TODO(enne): This could also potentially be sped up for software raster
+  // by moving these draw ops into PaintRecord itself and then moving the
+  // PaintDirect code to be part of the raster for PaintRecord.
+
+  // If this process doesn't have access to GDI, we'd need to use shared memory
+  // segment instead but that is not supported right now.
   if (!base::win::IsUser32AndGdi32Available()) {
     return;
   }
@@ -947,8 +746,8 @@ void PaintIndirect(cc::PaintCanvas* destination_canvas,
   }
 
   skia::InitializeDC(offscreen_hdc.Get());
-  if (const HRGN clip = CreateRectRgn(0, 0, rect.width(), rect.height());
-      (SelectClipRgn(offscreen_hdc.Get(), clip) == ERROR) ||
+  HRGN clip = CreateRectRgn(0, 0, rect.width(), rect.height());
+  if ((SelectClipRgn(offscreen_hdc.Get(), clip) == ERROR) ||
       !DeleteObject(clip)) {
     return;
   }
@@ -959,17 +758,17 @@ void PaintIndirect(cc::PaintCanvas* destination_canvas,
     return;
   }
 
-  // Will be null if lower-level Windows calls fail, or if the backing allocated
-  // is 0 pixels in size (which should never happen according to Windows
-  // documentation).
-  const sk_sp<SkSurface> offscreen_surface =
+  // Will be NULL if lower-level Windows calls fail, or if the backing
+  // allocated is 0 pixels in size (which should never happen according to
+  // Windows documentation).
+  sk_sp<SkSurface> offscreen_surface =
       skia::MapPlatformSurface(offscreen_hdc.Get());
   if (!offscreen_surface) {
     return;
   }
 
-  SkCanvas* const offscreen_canvas = offscreen_surface->getCanvas();
-  CHECK(offscreen_canvas);
+  SkCanvas* offscreen_canvas = offscreen_surface->getCanvas();
+  DCHECK(offscreen_canvas);
 
   // Some of the Windows theme drawing operations do not write correct alpha
   // values for fully-opaque pixels; instead the pixels get alpha 0. This is
@@ -978,46 +777,49 @@ void PaintIndirect(cc::PaintCanvas* destination_canvas,
   // To work-around this, mark all pixels with a placeholder value, to detect
   // which pixels get touched by the paint operation. After paint, set any
   // pixels that have alpha 0 to opaque and placeholders to fully-transparent.
-  constexpr SkColor kPlaceholder = SkColorSetARGB(1, 0, 0, 0);
-  offscreen_canvas->clear(kPlaceholder);
+  constexpr SkColor placeholder = SkColorSetARGB(1, 0, 0, 0);
+  offscreen_canvas->clear(placeholder);
 
   // Offset destination rects to have origin (0,0).
   gfx::Rect adjusted_rect(rect.size());
-  if (part == NativeTheme::kProgressBar) {
-    auto& progress_bar =
-        std::get<NativeTheme::ProgressBarExtraParams>(extra_params);
-    progress_bar.value_rect_x = 0;
-    progress_bar.value_rect_y = 0;
-  } else if (part == NativeTheme::kScrollbarHorizontalTrack ||
-             part == NativeTheme::kScrollbarVerticalTrack) {
-    auto& scrollbar_track =
-        std::get<NativeTheme::ScrollbarTrackExtraParams>(extra_params);
-    scrollbar_track.track_x = 0;
-    scrollbar_track.track_y = 0;
+  ExtraParams adjusted_extra = extra;
+  switch (part) {
+    case kProgressBar: {
+      auto progress_bar = std::get<ProgressBarExtraParams>(adjusted_extra);
+      progress_bar.value_rect_x = 0;
+      progress_bar.value_rect_y = 0;
+      break;
+    }
+    case kScrollbarHorizontalTrack:
+    case kScrollbarVerticalTrack: {
+      auto scrollbar_track =
+          std::get<ScrollbarTrackExtraParams>(adjusted_extra);
+      scrollbar_track.track_x = 0;
+      scrollbar_track.track_y = 0;
+      break;
+    }
+    default:
+      break;
   }
   // Draw the theme controls using existing HDC-drawing code.
   PaintDirect(offscreen_canvas, offscreen_hdc.Get(), part, state, adjusted_rect,
-              extra_params);
+              adjusted_extra);
 
   SkBitmap offscreen_bitmap = skia::MapPlatformBitmap(offscreen_hdc.Get());
 
   // Post-process the pixels to fix up the alpha values (see big comment above).
-  const SkPMColor placeholder_value = SkPreMultiplyColor(kPlaceholder);
-  for (SkPMColor& pixel :
-       // SAFETY: `offscreen_bitmap` is the same size as `offscreen_hdc`, which
-       // is holding `hbitmap`, which is `rect.width()` x `rect.height()` pixels
-       // in size.
-       UNSAFE_BUFFERS(base::span(offscreen_bitmap.getAddr32(0, 0),
-                                 base::CheckMul(rect.width(), rect.height())
-                                     .Cast<size_t>()
-                                     .ValueOrDie()))) {
-    if (pixel == placeholder_value) {
+  const SkPMColor placeholder_value = SkPreMultiplyColor(placeholder);
+  const int pixel_count = rect.width() * rect.height();
+  SkPMColor* pixels = offscreen_bitmap.getAddr32(0, 0);
+  for (int i = 0; i < pixel_count; i++) {
+    if (pixels[i] == placeholder_value) {
       // Pixel wasn't touched - make it fully transparent.
-      pixel = SkPMColorSetARGB(0, 0, 0, 0);
-    } else if (SkPMColorGetA(pixel) == 0) {
+      pixels[i] = SkPMColorSetARGB(0, 0, 0, 0);
+    } else if (SkPMColorGetA(pixels[i]) == 0) {
       // Pixel was touched but has incorrect alpha of 0, make it fully opaque.
-      pixel = SkPMColorSetARGB(0xFF, SkPMColorGetR(pixel), SkPMColorGetG(pixel),
-                               SkPMColorGetB(pixel));
+      pixels[i] =
+          SkPMColorSetARGB(0xFF, SkPMColorGetR(pixels[i]),
+                           SkPMColorGetG(pixels[i]), SkPMColorGetB(pixels[i]));
     }
   }
 
@@ -1026,90 +828,867 @@ void PaintIndirect(cc::PaintCanvas* destination_canvas,
       rect.y());
 }
 
-}  // namespace
+void NativeThemeWin::PaintButtonClassic(HDC hdc,
+                                        Part part,
+                                        State state,
+                                        RECT* rect,
+                                        const ButtonExtraParams& extra) const {
+  int classic_state = extra.classic_state;
+  switch (part) {
+    case kCheckbox:
+      classic_state |= DFCS_BUTTONCHECK;
+      break;
+    case kPushButton:
+      classic_state |= DFCS_BUTTONRADIO;
+      break;
+    case kRadio:
+      classic_state |= DFCS_BUTTONPUSH;
+      break;
+    default:
+      NOTREACHED();
+  }
 
-// static
-void NativeThemeWin::CloseHandles() {
-  for (auto& entry : *GetThemeHandles()) {
-    if (entry.second) {
-      CloseThemeData(entry.second);
-      entry.second = nullptr;
+  if (state == kDisabled) {
+    classic_state |= DFCS_INACTIVE;
+  } else if (state == kPressed) {
+    classic_state |= DFCS_PUSHED;
+  }
+
+  if (extra.checked) {
+    classic_state |= DFCS_CHECKED;
+  }
+
+  if ((part == kPushButton) && ((state == kPressed) || extra.is_default)) {
+    // Pressed or defaulted buttons have a shadow replacing the outer 1 px.
+    HBRUSH brush = GetSysColorBrush(COLOR_3DDKSHADOW);
+    if (brush) {
+      FrameRect(hdc, rect, brush);
+      InflateRect(rect, -1, -1);
     }
   }
+
+  DrawFrameControl(hdc, rect, DFC_BUTTON, classic_state);
+
+  // Draw a focus rectangle (the dotted line box) on defaulted buttons.
+  if ((part == kPushButton) && extra.is_default) {
+    InflateRect(rect, -GetSystemMetrics(SM_CXEDGE),
+                -GetSystemMetrics(SM_CYEDGE));
+    DrawFocusRect(hdc, rect);
+  }
+
+  // Classic theme doesn't support indeterminate checkboxes.  We draw a
+  // recangle inside a checkbox like IE10 does.
+  if ((part == kCheckbox) && extra.indeterminate) {
+    RECT inner_rect = *rect;
+    // "4 / 13" is same as IE10 in classic theme.
+    int padding = (inner_rect.right - inner_rect.left) * 4 / 13;
+    InflateRect(&inner_rect, -padding, -padding);
+    int color_index = (state == kDisabled) ? COLOR_GRAYTEXT : COLOR_WINDOWTEXT;
+    FillRect(hdc, &inner_rect, GetSysColorBrush(color_index));
+  }
 }
 
-gfx::Size NativeThemeWin::GetPartSize(Part part,
-                                      State state,
-                                      const ExtraParams& extra_params) const {
-  // The `GetThemePartSize()` call below returns the default size without
-  // accounting for user customization.
-  if (part >= kScrollbarDownArrow && part <= kScrollbarVerticalTrack) {
-    int size =
-        display::win::GetScreenWin()->GetSystemMetricsInDIP(SM_CXVSCROLL);
-    if (size == 0) {
-      size = 17;
-    }
-    return gfx::Size(size, size);
+void NativeThemeWin::PaintLeftMenuArrowThemed(HDC hdc,
+                                              HANDLE handle,
+                                              int part_id,
+                                              int state_id,
+                                              const gfx::Rect& rect) const {
+  // There is no way to tell the uxtheme API to draw a left pointing arrow; it
+  // doesn't have a flag equivalent to DFCS_MENUARROWRIGHT.  But they are needed
+  // for RTL locales on Vista.  So use a memory DC and mirror the region with
+  // GDI's StretchBlt.
+  base::win::ScopedCreateDC mem_dc(CreateCompatibleDC(hdc));
+  base::win::ScopedGDIObject<HBITMAP> mem_bitmap(
+      CreateCompatibleBitmap(hdc, rect.width(), rect.height()));
+  base::win::ScopedSelectObject select_bitmap(mem_dc.Get(), mem_bitmap.get());
+  // Copy and horizontally mirror the background from hdc into mem_dc. Use a
+  // negative-width source rect, starting at the rightmost pixel.
+  StretchBlt(mem_dc.Get(), 0, 0, rect.width(), rect.height(), hdc,
+             rect.right() - 1, rect.y(), -rect.width(), rect.height(), SRCCOPY);
+  // Draw the arrow.
+  RECT theme_rect = {0, 0, rect.width(), rect.height()};
+  DrawThemeBackground(handle, mem_dc.Get(), part_id, state_id, &theme_rect,
+                      nullptr);
+  // Copy and mirror the result back into mem_dc.
+  StretchBlt(hdc, rect.x(), rect.y(), rect.width(), rect.height(), mem_dc.Get(),
+             rect.width() - 1, 0, -rect.width(), rect.height(), SRCCOPY);
+}
+
+void NativeThemeWin::PaintScrollbarArrowClassic(HDC hdc,
+                                                Part part,
+                                                State state,
+                                                RECT* rect) const {
+  int classic_state = DFCS_SCROLLDOWN;
+  switch (part) {
+    case kScrollbarDownArrow:
+      break;
+    case kScrollbarLeftArrow:
+      classic_state = DFCS_SCROLLLEFT;
+      break;
+    case kScrollbarRightArrow:
+      classic_state = DFCS_SCROLLRIGHT;
+      break;
+    case kScrollbarUpArrow:
+      classic_state = DFCS_SCROLLUP;
+      break;
+    default:
+      NOTREACHED();
+  }
+  switch (state) {
+    case kDisabled:
+      classic_state |= DFCS_INACTIVE;
+      break;
+    case kHovered:
+      classic_state |= DFCS_HOT;
+      break;
+    case kNormal:
+      break;
+    case kPressed:
+      classic_state |= DFCS_PUSHED;
+      break;
+    case kNumStates:
+      NOTREACHED();
+  }
+  DrawFrameControl(hdc, rect, DFC_SCROLL, classic_state);
+}
+
+void NativeThemeWin::PaintScrollbarTrackClassic(
+    SkCanvas* canvas,
+    HDC hdc,
+    RECT* rect,
+    const ScrollbarTrackExtraParams& extra) const {
+  if ((system_colors_[SystemThemeColor::kScrollbar] !=
+       system_colors_[SystemThemeColor::kButtonFace]) &&
+      (system_colors_[SystemThemeColor::kScrollbar] !=
+       system_colors_[SystemThemeColor::kWindow])) {
+    FillRect(hdc, rect, reinterpret_cast<HBRUSH>(COLOR_SCROLLBAR + 1));
+  } else {
+    SkPaint paint;
+    RECT align_rect = gfx::Rect(extra.track_x, extra.track_y, extra.track_width,
+                                extra.track_height)
+                          .ToRECT();
+    SetCheckerboardShader(&paint, align_rect);
+    canvas->drawIRect(skia::RECTToSkIRect(*rect), paint);
+  }
+  if (extra.classic_state & DFCS_PUSHED) {
+    InvertRect(hdc, rect);
+  }
+}
+
+void NativeThemeWin::PaintHorizontalTrackbarThumbClassic(
+    SkCanvas* canvas,
+    HDC hdc,
+    const RECT& rect,
+    const TrackbarExtraParams& extra) const {
+  // Split rect into top and bottom pieces.
+  RECT top_section = rect;
+  RECT bottom_section = rect;
+  top_section.bottom -= ((bottom_section.right - bottom_section.left) / 2);
+  bottom_section.top = top_section.bottom;
+  DrawEdge(hdc, &top_section, EDGE_RAISED,
+           BF_LEFT | BF_TOP | BF_RIGHT | BF_SOFT | BF_MIDDLE | BF_ADJUST);
+
+  // Split triangular piece into two diagonals.
+  RECT& left_half = bottom_section;
+  RECT right_half = bottom_section;
+  right_half.left += ((bottom_section.right - bottom_section.left) / 2);
+  left_half.right = right_half.left;
+  DrawEdge(hdc, &left_half, EDGE_RAISED,
+           BF_DIAGONAL_ENDTOPLEFT | BF_SOFT | BF_MIDDLE | BF_ADJUST);
+  DrawEdge(hdc, &right_half, EDGE_RAISED,
+           BF_DIAGONAL_ENDBOTTOMLEFT | BF_SOFT | BF_MIDDLE | BF_ADJUST);
+
+  // If the button is pressed, draw hatching.
+  if (extra.classic_state & DFCS_PUSHED) {
+    SkPaint paint;
+    SetCheckerboardShader(&paint, rect);
+
+    // Fill all three pieces with the pattern.
+    canvas->drawIRect(skia::RECTToSkIRect(top_section), paint);
+
+    SkScalar left_triangle_top = SkIntToScalar(left_half.top);
+    SkScalar left_triangle_right = SkIntToScalar(left_half.right);
+    SkPath left_triangle;
+    left_triangle.moveTo(SkIntToScalar(left_half.left), left_triangle_top);
+    left_triangle.lineTo(left_triangle_right, left_triangle_top);
+    left_triangle.lineTo(left_triangle_right, SkIntToScalar(left_half.bottom));
+    left_triangle.close();
+    canvas->drawPath(left_triangle, paint);
+
+    SkScalar right_triangle_left = SkIntToScalar(right_half.left);
+    SkScalar right_triangle_top = SkIntToScalar(right_half.top);
+    SkPath right_triangle;
+    right_triangle.moveTo(right_triangle_left, right_triangle_top);
+    right_triangle.lineTo(SkIntToScalar(right_half.right), right_triangle_top);
+    right_triangle.lineTo(right_triangle_left,
+                          SkIntToScalar(right_half.bottom));
+    right_triangle.close();
+    canvas->drawPath(right_triangle, paint);
+  }
+}
+
+void NativeThemeWin::PaintProgressBarOverlayThemed(
+    HDC hdc,
+    HANDLE handle,
+    RECT* bar_rect,
+    RECT* value_rect,
+    const ProgressBarExtraParams& extra) const {
+  // There is no documentation about the animation speed, frame-rate, nor
+  // size of moving overlay of the indeterminate progress bar.
+  // So we just observed real-world programs and guessed following parameters.
+  constexpr int kDeterminateOverlayWidth = 120;
+  constexpr int kDeterminateOverlayPixelsPerSecond = 300;
+  constexpr int kIndeterminateOverlayWidth = 120;
+  constexpr int kIndeterminateOverlayPixelsPerSecond = 175;
+
+  int bar_width = bar_rect->right - bar_rect->left;
+  if (!extra.determinate) {
+    // The glossy overlay for the indeterminate progress bar has a small pause
+    // after each animation. We emulate this by adding an invisible margin the
+    // animation has to traverse.
+    int width_with_margin = bar_width + kIndeterminateOverlayPixelsPerSecond;
+    int overlay_width = kIndeterminateOverlayWidth;
+    RECT overlay_rect = *bar_rect;
+    overlay_rect.left += ComputeAnimationProgress(
+        width_with_margin, overlay_width, kIndeterminateOverlayPixelsPerSecond,
+        extra.animated_seconds);
+    overlay_rect.right = overlay_rect.left + overlay_width;
+    DrawThemeBackground(handle, hdc, PP_MOVEOVERLAY, 0, &overlay_rect,
+                        bar_rect);
+    return;
+  }
+
+  // We care about the direction here because PP_CHUNK painting is asymmetric.
+  // TODO(morrita): This RTL guess can be wrong.  We should pass in the
+  // direction from WebKit.
+  const bool mirror = bar_rect->right == value_rect->right &&
+                      bar_rect->left != value_rect->left;
+  const DTBGOPTS value_draw_options = {sizeof(DTBGOPTS),
+                                       mirror ? DTBG_MIRRORDC : 0u, *bar_rect};
+
+  // On Vista or later, the progress bar part has a single-block value part
+  // and a glossy effect. The value part has exactly same height as the bar
+  // part, so we don't need to shrink the rect.
+  DrawThemeBackgroundEx(handle, hdc, PP_FILL, 0, value_rect,
+                        &value_draw_options);
+
+  RECT overlay_rect = *value_rect;
+  overlay_rect.left += ComputeAnimationProgress(
+      bar_width, kDeterminateOverlayWidth, kDeterminateOverlayPixelsPerSecond,
+      extra.animated_seconds);
+  overlay_rect.right = overlay_rect.left + kDeterminateOverlayWidth;
+  DrawThemeBackground(handle, hdc, PP_MOVEOVERLAY, 0, &overlay_rect,
+                      value_rect);
+}
+
+void NativeThemeWin::PaintTextFieldThemed(
+    HDC hdc,
+    HANDLE handle,
+    HBRUSH bg_brush,
+    int part_id,
+    int state_id,
+    RECT* rect,
+    const TextFieldExtraParams& extra) const {
+  static constexpr DTBGOPTS kOmitBorderOptions = {
+      sizeof(DTBGOPTS), DTBG_OMITBORDER, {0, 0, 0, 0}};
+  DrawThemeBackgroundEx(handle, hdc, part_id, state_id, rect,
+                        extra.draw_edges ? nullptr : &kOmitBorderOptions);
+
+  if (extra.fill_content_area) {
+    RECT content_rect;
+    GetThemeBackgroundContentRect(handle, hdc, part_id, state_id, rect,
+                                  &content_rect);
+    FillRect(hdc, &content_rect, bg_brush);
   }
+}
 
-  if (HANDLE handle = GetThemeHandle(part)) {
-    base::win::ScopedGetDC screen_dc(nullptr);
-    SIZE size;
-    if (SUCCEEDED(GetThemePartSize(handle, screen_dc,
-                                   GetWindowsPart(part, extra_params),
-                                   GetWindowsState(part, state, extra_params),
-                                   nullptr, TS_TRUE, &size))) {
-      return gfx::Size(size.cx, size.cy);
+void NativeThemeWin::PaintTextFieldClassic(
+    HDC hdc,
+    HBRUSH bg_brush,
+    RECT* rect,
+    const TextFieldExtraParams& extra) const {
+  if (extra.draw_edges) {
+    DrawEdge(hdc, rect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
+  }
+
+  if (extra.fill_content_area) {
+    if (extra.classic_state & DFCS_INACTIVE) {
+      bg_brush = reinterpret_cast<HBRUSH>(COLOR_BTNFACE + 1);
     }
+    FillRect(hdc, rect, bg_brush);
   }
+}
 
-  // TODO(rogerta): For now, we need to support radio buttons and checkboxes
-  // when theming is not enabled.  Support for other parts can be added
-  // if/when needed.
-  return (part == kCheckbox || part == kRadio) ? gfx::Size(13, 13)
-                                               : gfx::Size();
+void NativeThemeWin::PaintScaledTheme(HANDLE theme,
+                                      HDC hdc,
+                                      int part_id,
+                                      int state_id,
+                                      const gfx::Rect& rect) const {
+  // Correct the scaling and positioning of sub-components such as scrollbar
+  // arrows and thumb grippers in the event that the world transform applies
+  // scaling (e.g. in high-DPI mode).
+  XFORM save_transform;
+  if (GetWorldTransform(hdc, &save_transform)) {
+    float scale = save_transform.eM11;
+    if (scale != 1 && save_transform.eM12 == 0) {
+      ModifyWorldTransform(hdc, NULL, MWT_IDENTITY);
+      gfx::Rect scaled_rect = gfx::ScaleToEnclosedRect(rect, scale);
+      scaled_rect.Offset(save_transform.eDx, save_transform.eDy);
+      RECT bounds = scaled_rect.ToRECT();
+      DrawThemeBackground(theme, hdc, part_id, state_id, &bounds, nullptr);
+      SetWorldTransform(hdc, &save_transform);
+      return;
+    }
+  }
+  RECT bounds = rect.ToRECT();
+  DrawThemeBackground(theme, hdc, part_id, state_id, &bounds, nullptr);
 }
 
-NativeThemeWin::NativeThemeWin() = default;
+// static
+NativeThemeWin::ThemeName NativeThemeWin::GetThemeName(Part part) {
+  switch (part) {
+    case kCheckbox:
+    case kPushButton:
+    case kRadio:
+      return BUTTON;
+    case kMenuList:
+    case kMenuCheck:
+    case kMenuCheckBackground:
+    case kMenuPopupArrow:
+    case kMenuPopupGutter:
+    case kMenuPopupSeparator:
+      return MENU;
+    case kProgressBar:
+      return PROGRESS;
+    case kScrollbarDownArrow:
+    case kScrollbarLeftArrow:
+    case kScrollbarRightArrow:
+    case kScrollbarUpArrow:
+    case kScrollbarHorizontalGripper:
+    case kScrollbarVerticalGripper:
+    case kScrollbarHorizontalThumb:
+    case kScrollbarVerticalThumb:
+    case kScrollbarHorizontalTrack:
+    case kScrollbarVerticalTrack:
+      return SCROLLBAR;
+    case kInnerSpinButton:
+      return SPIN;
+    case kWindowResizeGripper:
+      return STATUS;
+    case kTabPanelBackground:
+      return TAB;
+    case kTextField:
+      return TEXTFIELD;
+    case kTrackbarThumb:
+    case kTrackbarTrack:
+      return TRACKBAR;
+    case kMenuPopupBackground:
+    case kMenuItemBackground:
+    case kScrollbarCorner:
+    case kSliderTrack:
+    case kSliderThumb:
+    case kMaxPart:
+      NOTREACHED();
+  }
+}
 
-NativeThemeWin::~NativeThemeWin() {
-  CloseHandles();
+// static
+int NativeThemeWin::GetWindowsPart(Part part,
+                                   State state,
+                                   const ExtraParams& extra) {
+  switch (part) {
+    case kCheckbox:
+      return BP_CHECKBOX;
+    case kPushButton:
+      return BP_PUSHBUTTON;
+    case kRadio:
+      return BP_RADIOBUTTON;
+    case kMenuList:
+      return CP_DROPDOWNBUTTON;
+    case kTextField:
+      return EP_EDITTEXT;
+    case kMenuCheck:
+      return MENU_POPUPCHECK;
+    case kMenuCheckBackground:
+      return MENU_POPUPCHECKBACKGROUND;
+    case kMenuPopupGutter:
+      return MENU_POPUPGUTTER;
+    case kMenuPopupSeparator:
+      return MENU_POPUPSEPARATOR;
+    case kMenuPopupArrow:
+      return MENU_POPUPSUBMENU;
+    case kProgressBar:
+      return PP_BAR;
+    case kScrollbarDownArrow:
+    case kScrollbarLeftArrow:
+    case kScrollbarRightArrow:
+    case kScrollbarUpArrow:
+      return SBP_ARROWBTN;
+    case kScrollbarHorizontalGripper:
+      return SBP_GRIPPERHORZ;
+    case kScrollbarVerticalGripper:
+      return SBP_GRIPPERVERT;
+    case kScrollbarHorizontalThumb:
+      return SBP_THUMBBTNHORZ;
+    case kScrollbarVerticalThumb:
+      return SBP_THUMBBTNVERT;
+    case kScrollbarHorizontalTrack:
+      return std::get<ScrollbarTrackExtraParams>(extra).is_upper
+                 ? SBP_UPPERTRACKHORZ
+                 : SBP_LOWERTRACKHORZ;
+    case kScrollbarVerticalTrack:
+      return std::get<ScrollbarTrackExtraParams>(extra).is_upper
+                 ? SBP_UPPERTRACKVERT
+                 : SBP_LOWERTRACKVERT;
+    case kWindowResizeGripper:
+      // Use the status bar gripper.  There doesn't seem to be a standard
+      // gripper in Windows for the space between scrollbars.  This is pretty
+      // close, but it's supposed to be painted over a status bar.
+      return SP_GRIPPER;
+    case kInnerSpinButton:
+      return std::get<InnerSpinButtonExtraParams>(extra).spin_up ? SPNP_UP
+                                                                 : SPNP_DOWN;
+    case kTabPanelBackground:
+      return TABP_BODY;
+    case kTrackbarThumb:
+      return std::get<TrackbarExtraParams>(extra).vertical ? TKP_THUMBVERT
+                                                           : TKP_THUMBBOTTOM;
+    case kTrackbarTrack:
+      return std::get<TrackbarExtraParams>(extra).vertical ? TKP_TRACKVERT
+                                                           : TKP_TRACK;
+    case kMenuPopupBackground:
+    case kMenuItemBackground:
+    case kScrollbarCorner:
+    case kSliderTrack:
+    case kSliderThumb:
+    case kMaxPart:
+      NOTREACHED();
+  }
 }
 
-void NativeThemeWin::PaintImpl(cc::PaintCanvas* canvas,
-                               const ColorProvider* color_provider,
-                               Part part,
-                               State state,
-                               const gfx::Rect& rect,
-                               const ExtraParams& extra_params,
-                               bool forced_colors,
-                               bool dark_mode,
-                               PreferredContrast contrast,
-                               std::optional<SkColor> accent_color) const {
+int NativeThemeWin::GetWindowsState(Part part,
+                                    State state,
+                                    const ExtraParams& extra) {
   switch (part) {
+    case kScrollbarDownArrow:
+      switch (state) {
+        case kDisabled:
+          return ABS_DOWNDISABLED;
+        case kHovered:
+          return std::get<ScrollbarArrowExtraParams>(extra).is_hovering
+                     ? ABS_DOWNHOVER
+                     : ABS_DOWNHOT;
+        case kNormal:
+          return ABS_DOWNNORMAL;
+        case kPressed:
+          return ABS_DOWNPRESSED;
+        case kNumStates:
+          NOTREACHED();
+      }
+    case kScrollbarLeftArrow:
+      switch (state) {
+        case kDisabled:
+          return ABS_LEFTDISABLED;
+        case kHovered:
+          return std::get<ScrollbarArrowExtraParams>(extra).is_hovering
+                     ? ABS_LEFTHOVER
+                     : ABS_LEFTHOT;
+        case kNormal:
+          return ABS_LEFTNORMAL;
+        case kPressed:
+          return ABS_LEFTPRESSED;
+        case kNumStates:
+          NOTREACHED();
+      }
+    case kScrollbarRightArrow:
+      switch (state) {
+        case kDisabled:
+          return ABS_RIGHTDISABLED;
+        case kHovered:
+          return std::get<ScrollbarArrowExtraParams>(extra).is_hovering
+                     ? ABS_RIGHTHOVER
+                     : ABS_RIGHTHOT;
+        case kNormal:
+          return ABS_RIGHTNORMAL;
+        case kPressed:
+          return ABS_RIGHTPRESSED;
+        case kNumStates:
+          NOTREACHED();
+      }
+    case kScrollbarUpArrow:
+      switch (state) {
+        case kDisabled:
+          return ABS_UPDISABLED;
+        case kHovered:
+          return std::get<ScrollbarArrowExtraParams>(extra).is_hovering
+                     ? ABS_UPHOVER
+                     : ABS_UPHOT;
+        case kNormal:
+          return ABS_UPNORMAL;
+        case kPressed:
+          return ABS_UPPRESSED;
+        case kNumStates:
+          NOTREACHED();
+      }
+    case kCheckbox: {
+      const auto& button = std::get<ButtonExtraParams>(extra);
+      switch (state) {
+        case kDisabled:
+          return button.checked
+                     ? CBS_CHECKEDDISABLED
+                     : (button.indeterminate ? CBS_MIXEDDISABLED
+                                             : CBS_UNCHECKEDDISABLED);
+        case kHovered:
+          return button.checked
+                     ? CBS_CHECKEDHOT
+                     : (button.indeterminate ? CBS_MIXEDHOT : CBS_UNCHECKEDHOT);
+        case kNormal:
+          return button.checked ? CBS_CHECKEDNORMAL
+                                : (button.indeterminate ? CBS_MIXEDNORMAL
+                                                        : CBS_UNCHECKEDNORMAL);
+        case kPressed:
+          return button.checked ? CBS_CHECKEDPRESSED
+                                : (button.indeterminate ? CBS_MIXEDPRESSED
+                                                        : CBS_UNCHECKEDPRESSED);
+        case kNumStates:
+          NOTREACHED();
+      }
+    }
+    case kMenuList:
+      switch (state) {
+        case kDisabled:
+          return CBXS_DISABLED;
+        case kHovered:
+          return CBXS_HOT;
+        case kNormal:
+          return CBXS_NORMAL;
+        case kPressed:
+          return CBXS_PRESSED;
+        case kNumStates:
+          NOTREACHED();
+      }
+    case kTextField:
+      switch (state) {
+        case kDisabled:
+          return ETS_DISABLED;
+        case kHovered:
+          return ETS_HOT;
+        case kNormal: {
+          const auto& text_filed = std::get<TextFieldExtraParams>(extra);
+          if (text_filed.is_read_only) {
+            return ETS_READONLY;
+          }
+          return text_filed.is_focused ? ETS_FOCUSED : ETS_NORMAL;
+        }
+        case kPressed:
+          return ETS_SELECTED;
+        case kNumStates:
+          NOTREACHED();
+      }
+    case kMenuPopupArrow:
+      return (state == kDisabled) ? MSM_DISABLED : MSM_NORMAL;
+    case kMenuCheck: {
+      const auto& menu_check = std::get<MenuCheckExtraParams>(extra);
+      if (state == kDisabled) {
+        return menu_check.is_radio ? MC_BULLETDISABLED : MC_CHECKMARKDISABLED;
+      }
+      return menu_check.is_radio ? MC_BULLETNORMAL : MC_CHECKMARKNORMAL;
+    }
+    case kMenuCheckBackground:
+      return (state == kDisabled) ? MCB_DISABLED : MCB_NORMAL;
+    case kPushButton:
+      switch (state) {
+        case kDisabled:
+          return PBS_DISABLED;
+        case kHovered:
+          return PBS_HOT;
+        case kNormal:
+          return std::get<ButtonExtraParams>(extra).is_default ? PBS_DEFAULTED
+                                                               : PBS_NORMAL;
+        case kPressed:
+          return PBS_PRESSED;
+        case kNumStates:
+          NOTREACHED();
+      }
+    case kRadio: {
+      const auto& button = std::get<ButtonExtraParams>(extra);
+      switch (state) {
+        case kDisabled:
+          return button.checked ? RBS_CHECKEDDISABLED : RBS_UNCHECKEDDISABLED;
+        case kHovered:
+          return button.checked ? RBS_CHECKEDHOT : RBS_UNCHECKEDHOT;
+        case kNormal:
+          return button.checked ? RBS_CHECKEDNORMAL : RBS_UNCHECKEDNORMAL;
+        case kPressed:
+          return button.checked ? RBS_CHECKEDPRESSED : RBS_UNCHECKEDPRESSED;
+        case kNumStates:
+          NOTREACHED();
+      }
+    }
+    case kScrollbarHorizontalGripper:
+    case kScrollbarVerticalGripper:
+    case kScrollbarHorizontalThumb:
+    case kScrollbarVerticalThumb:
+      if ((state == kHovered) &&
+          !std::get<ScrollbarThumbExtraParams>(extra).is_hovering) {
+        return SCRBS_HOT;
+      }
+      [[fallthrough]];
+    case kScrollbarHorizontalTrack:
+    case kScrollbarVerticalTrack:
+      switch (state) {
+        case kDisabled:
+          return SCRBS_DISABLED;
+        case kHovered:
+          return SCRBS_HOVER;
+        case kNormal:
+          return SCRBS_NORMAL;
+        case kPressed:
+          return SCRBS_PRESSED;
+        case kNumStates:
+          NOTREACHED();
+      }
+    case kTrackbarThumb:
+    case kTrackbarTrack:
+      switch (state) {
+        case kDisabled:
+          return TUS_DISABLED;
+        case kHovered:
+          return TUS_HOT;
+        case kNormal:
+          return TUS_NORMAL;
+        case kPressed:
+          return TUS_PRESSED;
+        case kNumStates:
+          NOTREACHED();
+      }
+    case kInnerSpinButton: {
+      const auto& inner_spin = std::get<InnerSpinButtonExtraParams>(extra);
+      switch (state) {
+        case kDisabled:
+          return inner_spin.spin_up ? static_cast<int>(UPS_DISABLED)
+                                    : static_cast<int>(DNS_DISABLED);
+        case kHovered:
+          return inner_spin.spin_up ? static_cast<int>(UPS_HOT)
+                                    : static_cast<int>(DNS_HOT);
+        case kNormal:
+          return inner_spin.spin_up ? static_cast<int>(UPS_NORMAL)
+                                    : static_cast<int>(DNS_NORMAL);
+        case kPressed:
+          return inner_spin.spin_up ? static_cast<int>(UPS_PRESSED)
+                                    : static_cast<int>(DNS_PRESSED);
+        case kNumStates:
+          NOTREACHED();
+      }
+    }
     case kMenuPopupGutter:
-      PaintMenuGutter(canvas, color_provider, rect);
-      return;
     case kMenuPopupSeparator:
-      PaintMenuSeparator(canvas, color_provider,
-                         std::get<MenuSeparatorExtraParams>(extra_params));
-      return;
+    case kProgressBar:
+    case kTabPanelBackground:
+    case kWindowResizeGripper:
+      switch (state) {
+        case kDisabled:
+        case kHovered:
+        case kNormal:
+        case kPressed:
+          return 0;
+        case kNumStates:
+          NOTREACHED();
+      }
     case kMenuPopupBackground:
-      PaintMenuBackground(canvas, color_provider, rect);
-      return;
     case kMenuItemBackground:
-      PaintMenuItemBackground(canvas, color_provider, state, rect,
-                              std::get<MenuItemExtraParams>(extra_params));
-      return;
-    default:
-      PaintIndirect(canvas, part, state, rect, extra_params);
-      return;
+    case kScrollbarCorner:
+    case kSliderTrack:
+    case kSliderThumb:
+    case kMaxPart:
+      NOTREACHED();
+  }
+}
+
+HRESULT NativeThemeWin::PaintFrameControl(HDC hdc,
+                                          const gfx::Rect& rect,
+                                          UINT type,
+                                          UINT state,
+                                          bool is_selected,
+                                          State control_state) const {
+  const int width = rect.width();
+  const int height = rect.height();
+
+  // DrawFrameControl for menu arrow/check wants a monochrome bitmap.
+  base::win::ScopedGDIObject<HBITMAP> mask_bitmap(
+      CreateBitmap(width, height, 1, 1, NULL));
+
+  if (mask_bitmap == NULL) {
+    return E_OUTOFMEMORY;
+  }
+
+  base::win::ScopedCreateDC bitmap_dc(CreateCompatibleDC(NULL));
+  base::win::ScopedSelectObject select_bitmap(bitmap_dc.Get(),
+                                              mask_bitmap.get());
+  RECT local_rect = {0, 0, width, height};
+  DrawFrameControl(bitmap_dc.Get(), &local_rect, type, state);
+
+  // We're going to use BitBlt with a b&w mask. This results in using the dest
+  // dc's text color for the black bits in the mask, and the dest dc's
+  // background color for the white bits in the mask. DrawFrameControl draws the
+  // check in black, and the background in white.
+  int bg_color_key = COLOR_MENU;
+  int text_color_key = COLOR_MENUTEXT;
+  switch (control_state) {
+    case kDisabled:
+      bg_color_key = is_selected ? COLOR_HIGHLIGHT : COLOR_MENU;
+      text_color_key = COLOR_GRAYTEXT;
+      break;
+    case kHovered:
+      bg_color_key = COLOR_HIGHLIGHT;
+      text_color_key = COLOR_HIGHLIGHTTEXT;
+      break;
+    case kNormal:
+      break;
+    case kPressed:
+    case kNumStates:
+      NOTREACHED();
+  }
+  COLORREF old_bg_color = SetBkColor(hdc, GetSysColor(bg_color_key));
+  COLORREF old_text_color = SetTextColor(hdc, GetSysColor(text_color_key));
+  BitBlt(hdc, rect.x(), rect.y(), width, height, bitmap_dc.Get(), 0, 0,
+         SRCCOPY);
+  SetBkColor(hdc, old_bg_color);
+  SetTextColor(hdc, old_text_color);
+
+  return S_OK;
+}
+
+HANDLE NativeThemeWin::GetThemeHandle(ThemeName theme_name) const {
+  if (theme_name < 0 || theme_name >= LAST) {
+    return nullptr;
   }
+
+  if (theme_handles_[theme_name]) {
+    return theme_handles_[theme_name];
+  }
+
+  // Not found, try to load it.
+  HANDLE handle = nullptr;
+  switch (theme_name) {
+    case BUTTON:
+      handle = OpenThemeData(nullptr, L"Button");
+      break;
+    case LIST:
+      handle = OpenThemeData(nullptr, L"Listview");
+      break;
+    case MENU:
+      handle = OpenThemeData(nullptr, L"Menu");
+      break;
+    case MENULIST:
+      handle = OpenThemeData(nullptr, L"Combobox");
+      break;
+    case SCROLLBAR:
+      handle = OpenThemeData(nullptr, base::win::IsDarkModeAvailable()
+                                          ? L"Explorer::Scrollbar"
+                                          : L"Scrollbar");
+      break;
+    case STATUS:
+      handle = OpenThemeData(nullptr, L"Status");
+      break;
+    case TAB:
+      handle = OpenThemeData(nullptr, L"Tab");
+      break;
+    case TEXTFIELD:
+      handle = OpenThemeData(nullptr, L"Edit");
+      break;
+    case TRACKBAR:
+      handle = OpenThemeData(nullptr, L"Trackbar");
+      break;
+    case WINDOW:
+      handle = OpenThemeData(nullptr, L"Window");
+      break;
+    case PROGRESS:
+      handle = OpenThemeData(nullptr, L"Progress");
+      break;
+    case SPIN:
+      handle = OpenThemeData(nullptr, L"Spin");
+      break;
+    case LAST:
+      NOTREACHED();
+  }
+  theme_handles_[theme_name] = handle;
+  return handle;
+}
+
+void NativeThemeWin::RegisterThemeRegkeyObserver() {
+  DCHECK(hkcu_themes_regkey_.Valid());
+  DCHECK(base::SequencedTaskRunner::HasCurrentDefault());
+  hkcu_themes_regkey_.StartWatching(base::BindOnce(
+      [](NativeThemeWin* native_theme) {
+        native_theme->UpdateDarkModeStatus();
+        native_theme->UpdatePrefersReducedTransparency();
+        // RegKey::StartWatching only provides one notification. Reregistration
+        // is required to get future notifications.
+        native_theme->RegisterThemeRegkeyObserver();
+      },
+      base::Unretained(this)));
+}
+
+void NativeThemeWin::RegisterColorFilteringRegkeyObserver() {
+  DCHECK(hkcu_color_filtering_regkey_.Valid());
+  DCHECK(base::SequencedTaskRunner::HasCurrentDefault());
+  hkcu_color_filtering_regkey_.StartWatching(base::BindOnce(
+      [](NativeThemeWin* native_theme) {
+        native_theme->UpdateInvertedColors();
+        // RegKey::StartWatching only provides one notification. Reregistration
+        // is required to get future notifications.
+        native_theme->RegisterColorFilteringRegkeyObserver();
+      },
+      base::Unretained(this)));
 }
 
-void NativeThemeWin::OnToolkitSettingsChanged(bool force_notify) {
-  CloseHandles();
-  NativeTheme::OnToolkitSettingsChanged(force_notify);
+void NativeThemeWin::UpdateDarkModeStatus() {
+  in_dark_mode_ = false;
+  if (hkcu_themes_regkey_.Valid()) {
+    DWORD apps_use_light_theme = 1;
+    hkcu_themes_regkey_.ReadValueDW(L"AppsUseLightTheme",
+                                    &apps_use_light_theme);
+    in_dark_mode_ = (apps_use_light_theme == 0);
+  }
+  set_preferred_color_scheme(CalculatePreferredColorScheme());
+  CloseHandlesInternal();
+  NotifyOnNativeThemeUpdated();
+}
+
+void NativeThemeWin::UpdatePrefersReducedTransparency() {
+  bool prefers_reduced_transparency = false;
+  if (hkcu_themes_regkey_.Valid()) {
+    DWORD enable_transparency = 1;
+    hkcu_themes_regkey_.ReadValueDW(L"EnableTransparency",
+                                    &enable_transparency);
+    prefers_reduced_transparency = (enable_transparency == 0);
+  }
+  set_prefers_reduced_transparency(prefers_reduced_transparency);
+  CloseHandlesInternal();
+  NotifyOnNativeThemeUpdated();
+}
+
+void NativeThemeWin::UpdateInvertedColors() {
+  bool inverted_colors = false;
+  if (hkcu_color_filtering_regkey_.Valid()) {
+    DWORD active = 0;
+    hkcu_color_filtering_regkey_.ReadValueDW(L"Active", &active);
+    if (active == 1) {
+      // 0 = Greyscale
+      // 1 = Invert
+      // 2 = Greyscale Inverted
+      // 3 = Deuteranopia
+      // 4 = Protanopia
+      // 5 = Tritanopia
+      DWORD filter_type = 0;
+      hkcu_color_filtering_regkey_.ReadValueDW(L"FilterType", &filter_type);
+      inverted_colors = (filter_type == 1);
+    }
+  }
+  set_inverted_colors(inverted_colors);
+  CloseHandlesInternal();
+  NotifyOnNativeThemeUpdated();
 }
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_win.h b/ui/native_theme/native_theme_win.h
index f65cbaf56c29c..0dbd40d8e5e0c 100644
--- a/ui/native_theme/native_theme_win.h
+++ b/ui/native_theme/native_theme_win.h
@@ -5,16 +5,42 @@
 #ifndef UI_NATIVE_THEME_NATIVE_THEME_WIN_H_
 #define UI_NATIVE_THEME_NATIVE_THEME_WIN_H_
 
+#include <windows.h>
+
 #include <optional>
 
+#include "base/callback_list.h"
 #include "base/component_export.h"
+#include "base/functional/bind.h"
 #include "base/no_destructor.h"
+#include "base/win/registry.h"
+#include "third_party/skia/include/core/SkColor.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/win/singleton_hwnd.h"
 #include "ui/native_theme/native_theme.h"
 
+class SkCanvas;
+
 namespace ui {
 
 class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeWin : public NativeTheme {
  public:
+  enum ThemeName {
+    BUTTON,
+    LIST,
+    MENU,
+    MENULIST,
+    SCROLLBAR,
+    STATUS,
+    TAB,
+    TEXTFIELD,
+    TRACKBAR,
+    WINDOW,
+    PROGRESS,
+    SPIN,
+    LAST
+  };
+
   NativeThemeWin(const NativeThemeWin&) = delete;
   NativeThemeWin& operator=(const NativeThemeWin&) = delete;
 
@@ -22,30 +48,168 @@ class COMPONENT_EXPORT(NATIVE_THEME) NativeThemeWin : public NativeTheme {
   // for a theme change.
   static void CloseHandles();
 
-  // NativeTheme:
+  // NativeTheme implementation:
   gfx::Size GetPartSize(Part part,
                         State state,
-                        const ExtraParams& extra_params) const override;
+                        const ExtraParams& extra) const override;
+  void Paint(cc::PaintCanvas* canvas,
+             const ui::ColorProvider* color_provider,
+             Part part,
+             State state,
+             const gfx::Rect& rect,
+             const ExtraParams& extra,
+             bool forced_colors,
+             PreferredColorScheme color_scheme,
+             PreferredContrast contrast,
+             const std::optional<SkColor>& accent_color) const override;
+  bool SupportsNinePatch(Part part) const override;
+  gfx::Size GetNinePatchCanvasSize(Part part) const override;
+  gfx::Rect GetNinePatchAperture(Part part) const override;
+
+  PreferredContrast CalculatePreferredContrast() const override;
 
  protected:
+  friend class NativeTheme;
+  friend class base::NoDestructor<NativeThemeWin>;
+
   NativeThemeWin();
   ~NativeThemeWin() override;
 
-  // NativeTheme:
-  void PaintImpl(cc::PaintCanvas* canvas,
-                 const ColorProvider* color_provider,
-                 Part part,
-                 State state,
-                 const gfx::Rect& rect,
-                 const ExtraParams& extra_params,
-                 bool forced_colors,
-                 bool dark_mode,
-                 PreferredContrast contrast,
-                 std::optional<SkColor> accent_color) const override;
-  void OnToolkitSettingsChanged(bool force_notify) override;
+  PreferredColorScheme CalculatePreferredColorScheme() const;
+  void set_in_dark_mode_for_testing(bool in_dark_mode) {
+    in_dark_mode_ = in_dark_mode;
+  }
 
  private:
-  friend class base::NoDestructor<NativeThemeWin>;
+  bool IsUsingHighContrastThemeInternal() const;
+  void CloseHandlesInternal();
+
+  // Called by `hwnd_subscription_`.
+  void OnWndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);
+
+  // Update the locally cached set of system colors.
+  void UpdateSystemColors();
+
+  // Painting functions that paint to PaintCanvas.
+  void PaintMenuSeparator(cc::PaintCanvas* canvas,
+                          const ColorProvider* color_provider,
+                          const MenuSeparatorExtraParams& params) const;
+  void PaintMenuGutter(cc::PaintCanvas* canvas,
+                       const ColorProvider* color_provider,
+                       const gfx::Rect& rect) const;
+  void PaintMenuBackground(cc::PaintCanvas* canvas,
+                           const ColorProvider* color_provider,
+                           const gfx::Rect& rect) const;
+
+  // Paint directly to canvas' HDC.
+  void PaintDirect(SkCanvas* destination_canvas,
+                   HDC hdc,
+                   Part part,
+                   State state,
+                   const gfx::Rect& rect,
+                   const ExtraParams& extra) const;
+
+  // Create a temporary HDC, paint to that, clean up the alpha values in the
+  // temporary HDC, and then blit the result to canvas.  This is to work around
+  // the fact that Windows XP and some classic themes give bogus alpha values.
+  void PaintIndirect(cc::PaintCanvas* destination_canvas,
+                     Part part,
+                     State state,
+                     const gfx::Rect& rect,
+                     const ExtraParams& extra) const;
+
+  // Various helpers to paint specific parts.
+  void PaintButtonClassic(HDC hdc,
+                          Part part,
+                          State state,
+                          RECT* rect,
+                          const ButtonExtraParams& extra) const;
+  void PaintLeftMenuArrowThemed(HDC hdc,
+                                HANDLE handle,
+                                int part_id,
+                                int state_id,
+                                const gfx::Rect& rect) const;
+  void PaintScrollbarArrowClassic(HDC hdc,
+                                  Part part,
+                                  State state,
+                                  RECT* rect) const;
+  void PaintScrollbarTrackClassic(SkCanvas* canvas,
+                                  HDC hdc,
+                                  RECT* rect,
+                                  const ScrollbarTrackExtraParams& extra) const;
+  void PaintHorizontalTrackbarThumbClassic(
+      SkCanvas* canvas,
+      HDC hdc,
+      const RECT& rect,
+      const TrackbarExtraParams& extra) const;
+  void PaintProgressBarOverlayThemed(HDC hdc,
+                                     HANDLE handle,
+                                     RECT* bar_rect,
+                                     RECT* value_rect,
+                                     const ProgressBarExtraParams& extra) const;
+  void PaintTextFieldThemed(HDC hdc,
+                            HANDLE handle,
+                            HBRUSH bg_brush,
+                            int part_id,
+                            int state_id,
+                            RECT* rect,
+                            const TextFieldExtraParams& extra) const;
+  void PaintTextFieldClassic(HDC hdc,
+                             HBRUSH bg_brush,
+                             RECT* rect,
+                             const TextFieldExtraParams& extra) const;
+
+  // Paints a theme part, with support for scene scaling in high-DPI mode.
+  // |theme| is the theme handle. |hdc| is the handle for the device context.
+  // |part_id| is the identifier for the part (e.g. thumb gripper). |state_id|
+  // is the identifier for the rendering state of the part (e.g. hover). |rect|
+  // is the bounds for rendering, expressed in logical coordinates.
+  void PaintScaledTheme(HANDLE theme,
+                        HDC hdc,
+                        int part_id,
+                        int state_id,
+                        const gfx::Rect& rect) const;
+
+  // Get the windows theme name/part/state.  These three helper functions are
+  // used only by GetPartSize(), as each of the corresponding PaintXXX()
+  // methods do further validation of the part and state that is required for
+  // getting the size.
+  static ThemeName GetThemeName(Part part);
+  static int GetWindowsPart(Part part, State state, const ExtraParams& extra);
+  static int GetWindowsState(Part part, State state, const ExtraParams& extra);
+
+  HRESULT PaintFrameControl(HDC hdc,
+                            const gfx::Rect& rect,
+                            UINT type,
+                            UINT state,
+                            bool is_selected,
+                            State control_state) const;
+
+  // Returns a handle to the theme data.
+  HANDLE GetThemeHandle(ThemeName theme_name) const;
+
+  void RegisterThemeRegkeyObserver();
+  void RegisterColorFilteringRegkeyObserver();
+  void UpdateDarkModeStatus();
+  void UpdatePrefersReducedTransparency();
+  void UpdateInvertedColors();
+
+  // Dark Mode/Transparency registry key.
+  base::win::RegKey hkcu_themes_regkey_;
+
+  // Inverted colors registry key
+  base::win::RegKey hkcu_color_filtering_regkey_;
+
+  // A cache of open theme handles.
+  mutable HANDLE theme_handles_[LAST];
+
+  // Color/high contrast mode change observer.
+  base::CallbackListSubscription hwnd_subscription_ =
+      gfx::SingletonHwnd::GetInstance()->RegisterCallback(
+          base::BindRepeating(&NativeThemeWin::OnWndProc,
+                              base::Unretained(this)));
+
+  bool in_dark_mode_ = false;
 };
 
 }  // namespace ui
diff --git a/ui/native_theme/native_theme_win_unittest.cc b/ui/native_theme/native_theme_win_unittest.cc
new file mode 100644
index 0000000000000..c4664e31df171
--- /dev/null
+++ b/ui/native_theme/native_theme_win_unittest.cc
@@ -0,0 +1,124 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/native_theme/native_theme_win.h"
+
+#include <cmath>
+
+#include "base/time/time.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/gfx/color_palette.h"
+
+namespace ui {
+
+using ColorMode = ColorProviderKey::ColorMode;
+using PrefScheme = NativeTheme::PreferredColorScheme;
+using SystemThemeColor = NativeTheme::SystemThemeColor;
+
+class TestNativeThemeWin : public NativeThemeWin {
+ public:
+  TestNativeThemeWin() = default;
+  TestNativeThemeWin& operator=(const TestNativeThemeWin&) = delete;
+
+  ~TestNativeThemeWin() override = default;
+
+  ColorMode GetColorMode() const {
+    return GetColorProviderKey(/*custom_theme=*/nullptr).color_mode;
+  }
+
+  void SetForcedColors(bool forced_colors) {
+    set_forced_colors(forced_colors);
+    UpdateColorSchemeAndContrast();
+  }
+
+  void SetInDarkMode(bool in_dark_mode) {
+    set_in_dark_mode_for_testing(in_dark_mode);
+    UpdateColorSchemeAndContrast();
+  }
+
+  void SetSystemColor(SystemThemeColor system_color, SkColor color) {
+    system_colors_[system_color] = color;
+    UpdateColorSchemeAndContrast();
+  }
+
+ private:
+  void UpdateColorSchemeAndContrast() {
+    set_preferred_color_scheme(CalculatePreferredColorScheme());
+    SetPreferredContrast(CalculatePreferredContrast());
+  }
+};
+
+TEST(NativeThemeWinTest, CalculatePreferredColorScheme) {
+  TestNativeThemeWin theme;
+
+  theme.SetForcedColors(false);
+  theme.SetInDarkMode(true);
+  EXPECT_EQ(theme.preferred_color_scheme(), PrefScheme::kDark);
+
+  theme.SetInDarkMode(false);
+  EXPECT_EQ(theme.preferred_color_scheme(), PrefScheme::kLight);
+
+  theme.SetForcedColors(true);
+  theme.SetSystemColor(SystemThemeColor::kWindow, SK_ColorBLACK);
+  EXPECT_EQ(theme.preferred_color_scheme(), PrefScheme::kDark);
+
+  theme.SetSystemColor(SystemThemeColor::kWindow, SK_ColorWHITE);
+  EXPECT_EQ(theme.preferred_color_scheme(), PrefScheme::kLight);
+
+  theme.SetSystemColor(SystemThemeColor::kWindow, SK_ColorBLUE);
+  EXPECT_EQ(theme.preferred_color_scheme(), PrefScheme::kDark);
+
+  theme.SetSystemColor(SystemThemeColor::kWindow, SK_ColorYELLOW);
+  EXPECT_EQ(theme.preferred_color_scheme(), PrefScheme::kLight);
+
+  theme.SetForcedColors(false);
+  EXPECT_EQ(theme.preferred_color_scheme(), PrefScheme::kLight);
+}
+
+TEST(NativeThemeWinTest, CalculatePreferredContrast) {
+  using PrefContrast = NativeTheme::PreferredContrast;
+
+  TestNativeThemeWin theme;
+
+  theme.SetForcedColors(false);
+  EXPECT_EQ(theme.preferred_contrast(), PrefContrast::kNoPreference);
+
+  theme.SetForcedColors(true);
+  theme.SetSystemColor(SystemThemeColor::kWindow, SK_ColorBLACK);
+  theme.SetSystemColor(SystemThemeColor::kWindowText, SK_ColorWHITE);
+  EXPECT_EQ(theme.preferred_contrast(), PrefContrast::kMore);
+
+  theme.SetSystemColor(SystemThemeColor::kWindow, SK_ColorWHITE);
+  theme.SetSystemColor(SystemThemeColor::kWindowText, SK_ColorBLACK);
+  EXPECT_EQ(theme.preferred_contrast(), PrefContrast::kMore);
+
+  theme.SetSystemColor(SystemThemeColor::kWindowText, SK_ColorRED);
+  EXPECT_EQ(theme.preferred_contrast(), PrefContrast::kCustom);
+
+  theme.SetSystemColor(SystemThemeColor::kWindowText, SK_ColorYELLOW);
+  EXPECT_EQ(theme.preferred_contrast(), PrefContrast::kLess);
+
+  theme.SetForcedColors(false);
+  EXPECT_EQ(theme.preferred_contrast(), PrefContrast::kNoPreference);
+}
+
+TEST(NativeThemeWinTest, TestColorProviderKeyColorMode) {
+  TestNativeThemeWin theme;
+
+  theme.SetForcedColors(false);
+  theme.SetInDarkMode(true);
+  EXPECT_EQ(theme.GetColorMode(), ColorMode::kDark);
+
+  theme.SetInDarkMode(false);
+  EXPECT_EQ(theme.GetColorMode(), ColorMode::kLight);
+
+  theme.SetForcedColors(true);
+  theme.set_preferred_color_scheme(PrefScheme::kDark);
+  EXPECT_EQ(theme.GetColorMode(), ColorMode::kDark);
+
+  theme.set_preferred_color_scheme(PrefScheme::kLight);
+  EXPECT_EQ(theme.GetColorMode(), ColorMode::kLight);
+}
+
+}  // namespace ui
diff --git a/ui/native_theme/os_settings_provider.cc b/ui/native_theme/os_settings_provider.cc
index ce54c02f9e2d5..df5af8f83a14c 100644
--- a/ui/native_theme/os_settings_provider.cc
+++ b/ui/native_theme/os_settings_provider.cc
@@ -6,8 +6,6 @@
 
 #include <array>
 #include <forward_list>
-#include <optional>
-#include <tuple>
 #include <utility>
 
 #include "base/callback_list.h"
@@ -18,19 +16,10 @@
 #include "base/time/time.h"
 #include "base/types/cxx23_to_underlying.h"
 #include "build/build_config.h"
-#include "third_party/skia/include/core/SkColor.h"
-#include "ui/color/color_provider_key.h"
-#include "ui/gfx/color_conversions.h"
-#include "ui/gfx/color_utils.h"
-#include "ui/native_theme/native_theme.h"
 
 // `OsSettingsProviderImpl` is an alias to a forward-declared type; to construct
 // it in `Get()` below, we must have the full type definition.
-#if BUILDFLAG(IS_ANDROID)
-#include "ui/native_theme/os_settings_provider_android.h"
-#elif BUILDFLAG(IS_CHROMEOS)
-#include "ui/native_theme/os_settings_provider_ash.h"
-#elif BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_MAC)
 #include "ui/native_theme/os_settings_provider_mac.h"
 #elif BUILDFLAG(IS_WIN)
 #include "base/win/win_util.h"
@@ -63,9 +52,7 @@ std::forward_list<OsSettingsProvider*>& GetOsSettingsProviders(
 // not a non-static member of `OsSettingsProvider` since callers of
 // `RegisterCallback` should be agnostic to changes in the active provider (e.g.
 // when tests override it).
-using CallbackList =
-    base::RepeatingCallbackList<OsSettingsProvider::SettingsChangedCallbackT>;
-CallbackList* GetOsSettingsChangedCallbacks() {
+base::RepeatingClosureList* GetOsSettingsChangedCallbacks() {
   // All `OsSettingsProvider`s must access on the same thread to avoid data
   // races on the list below.
 #if DCHECK_IS_ON()  // Guard to avoid assertion failure from `NoDestructor`.
@@ -73,7 +60,7 @@ CallbackList* GetOsSettingsChangedCallbacks() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(*s_sequence_checker);
 #endif
 
-  static base::NoDestructor<CallbackList> s_callbacks;
+  static base::NoDestructor<base::RepeatingClosureList> s_callbacks;
   return s_callbacks.get();
 }
 
@@ -138,122 +125,18 @@ OsSettingsProvider& OsSettingsProvider::Get() {
 // static
 base::CallbackListSubscription
 OsSettingsProvider::RegisterOsSettingsChangedCallback(
-    base::RepeatingCallback<SettingsChangedCallbackT> cb) {
+    base::RepeatingClosure cb) {
   return GetOsSettingsChangedCallbacks()->Add(std::move(cb));
 }
 
-bool OsSettingsProvider::DarkColorSchemeAvailable() const {
-  return true;
-}
-
-NativeTheme::PreferredColorScheme OsSettingsProvider::PreferredColorScheme()
-    const {
-  if (ForcedColorsActive()) {
-    // According to the spec, the preferred color scheme for web content is
-    // "dark" if the Canvas color has L<33% and "light" if L>67%, where "L" is
-    // LAB lightness. The Canvas color is mapped to the Window system color.
-    // https://www.w3.org/TR/css-color-adjust-1/#forced
-    if (const auto bg_color = Color(ColorId::kWindow)) {
-      const SkColor srgb_legacy = bg_color.value();
-      const auto [r, g, b] = gfx::SRGBLegacyToSRGB(SkColorGetR(srgb_legacy),
-                                                   SkColorGetG(srgb_legacy),
-                                                   SkColorGetB(srgb_legacy));
-      const auto [x, y, z] = gfx::SRGBToXYZD50(r, g, b);
-      const float lab_lightness = std::get<0>(gfx::XYZD50ToLab(x, y, z));
-      if (lab_lightness < 33.0f) {
-        return NativeTheme::PreferredColorScheme::kDark;
-      }
-      if (lab_lightness > 67.0f) {
-        return NativeTheme::PreferredColorScheme::kLight;
-      }
-    }
-  }
-
-  return NativeTheme::PreferredColorScheme::kNoPreference;
-}
-
-ColorProviderKey::UserColorSource OsSettingsProvider::PreferredColorSource()
-    const {
-  return ColorProviderKey::UserColorSource::kAccent;
-}
-
-NativeTheme::PreferredContrast OsSettingsProvider::PreferredContrast() const {
-  if (ForcedColorsActive()) {
-    // TODO(sartang@microsoft.com): Update the spec page at
-    // https://www.w3.org/TR/css-color-adjust-1/#forced, it currently does not
-    // mention the relation between forced-colors-active and prefers-contrast.
-    //
-    // According to spec [1], "in addition to forced-colors: active, the user
-    // agent must also match one of prefers-contrast: more or prefers-contrast:
-    // less if it can determine that the forced color palette chosen by the user
-    // has a particularly high or low contrast, and must make prefers-contrast:
-    // custom match otherwise".
-    //
-    // Using WCAG definitions [2], we have decided to match 'more' in Forced
-    // Colors Mode if the contrast ratio between the foreground and background
-    // color is 7:1 or greater.
-    //
-    // "A contrast ratio of 3:1 is the minimum level recommended by
-    // [[ISO-9241-3]] and [[ANSI-HFES-100-1988]] for standard text and
-    // vision"[2]. Given this, we will start by matching to 'less' in Forced
-    // Colors Mode if the contrast ratio between the foreground and background
-    // color is 2.5:1 or less.
-    //
-    // These ratios will act as an experimental baseline that we can adjust
-    // based on user feedback.
-    //
-    // [1]
-    // https://drafts.csswg.org/mediaqueries-5/#valdef-media-forced-colors-active
-    // [2] https://www.w3.org/WAI/WCAG21/Understanding/contrast-enhanced
-    if (const auto bg_color = Color(ColorId::kWindow),
-        fg_color = Color(ColorId::kWindowText);
-        bg_color.has_value() && fg_color.has_value()) {
-      const float contrast_ratio =
-          color_utils::GetContrastRatio(bg_color.value(), fg_color.value());
-      if (contrast_ratio >= 7) {
-        return NativeTheme::PreferredContrast::kMore;
-      }
-      return contrast_ratio <= 2.5 ? NativeTheme::PreferredContrast::kLess
-                                   : NativeTheme::PreferredContrast::kCustom;
-    }
-  }
-
-  return NativeTheme::PreferredContrast::kNoPreference;
-}
-
-bool OsSettingsProvider::PrefersReducedTransparency() const {
-  return false;
-}
-
-bool OsSettingsProvider::PrefersInvertedColors() const {
-  return false;
-}
-
-bool OsSettingsProvider::ForcedColorsActive() const {
-  return false;
-}
-
-std::optional<SkColor> OsSettingsProvider::AccentColor() const {
-  return std::nullopt;
-}
-
-std::optional<SkColor> OsSettingsProvider::Color(ColorId color_id) const {
-  return std::nullopt;
-}
-
-std::optional<ColorProviderKey::SchemeVariant>
-OsSettingsProvider::SchemeVariant() const {
-  return std::nullopt;
-}
-
 base::TimeDelta OsSettingsProvider::CaretBlinkInterval() const {
   return kDefaultCaretBlinkInterval;
 }
 
-void OsSettingsProvider::NotifyOnSettingsChanged(bool force_notify) {
+void OsSettingsProvider::NotifyOnSettingsChanged() {
   // Don't notify if this provider isn't the active one.
   if (&Get() == this) {
-    GetOsSettingsChangedCallbacks()->Notify(force_notify);
+    GetOsSettingsChangedCallbacks()->Notify();
   }
 }
 
diff --git a/ui/native_theme/os_settings_provider.h b/ui/native_theme/os_settings_provider.h
index 3f737b20fac60..cbe105e0b3d53 100644
--- a/ui/native_theme/os_settings_provider.h
+++ b/ui/native_theme/os_settings_provider.h
@@ -12,19 +12,10 @@
 #include "base/functional/callback.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
-#include "third_party/skia/include/core/SkColor.h"
-#include "ui/color/color_provider_key.h"
-#include "ui/native_theme/native_theme.h"
 
 namespace ui {
 
-#if BUILDFLAG(IS_ANDROID)
-class OsSettingsProviderAndroid;
-using OsSettingsProviderImpl = OsSettingsProviderAndroid;
-#elif BUILDFLAG(IS_CHROMEOS)
-class OsSettingsProviderAsh;
-using OsSettingsProviderImpl = OsSettingsProviderAsh;
-#elif BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_MAC)
 class OsSettingsProviderMac;
 using OsSettingsProviderImpl = OsSettingsProviderMac;
 #elif BUILDFLAG(IS_WIN)
@@ -39,20 +30,10 @@ using OsSettingsProviderImpl = OsSettingsProvider;
 // Callers should use `Get()` to obtain the current instance.
 class COMPONENT_EXPORT(NATIVE_THEME) OsSettingsProvider {
  public:
-  using SettingsChangedCallbackT = void(bool force_notify);
-
   // Higher-numbered (i.e. higher-priority) providers override lower-priority
   // ones. Within a priority class, the most-recently-created provider wins.
   enum class PriorityLevel { kProduction = 0, kTesting, kLast = kTesting };
 
-  enum class ColorId {
-    kButtonFace,
-    kButtonHighlight,
-    kScrollbar,
-    kWindow,
-    kWindowText,
-  };
-
   // The caret blink interval reported when the OS provides no value.
   static constexpr auto kDefaultCaretBlinkInterval = base::Milliseconds(500);
 
@@ -90,55 +71,7 @@ class COMPONENT_EXPORT(NATIVE_THEME) OsSettingsProvider {
   // not affect the default `ColorProviderKey`, but affects the values of colors
   // inside that key's provider, would set this to `true`.
   static base::CallbackListSubscription RegisterOsSettingsChangedCallback(
-      base::RepeatingCallback<SettingsChangedCallbackT> cb);
-
-  // Returns whether the dark color scheme is available at an OS level.
-  // NOTE: Even if this is false, it may be reasonable for Chrome to use a dark
-  // theme; see comments on `PreferredColorScheme()` below.
-  virtual bool DarkColorSchemeAvailable() const;
-
-  // Returns preferred color scheme based on OS-level factors, or
-  // `kNoPreference` if not set/applicable. This is not affected by e.g.
-  // `switches::kForceDarkMode`; that should be handled at the `NativeTheme`
-  // (i.e. caller) level.
-  // NOTE: It's possible for this to be `kDark` even if
-  // `DarkColorSchemeAvailable()` returns false, e.g. when the OS has no notion
-  // of a native "dark scheme" but is using colors that correspond to Chrome
-  // using a dark theme. A historical example would have been the "high contrast
-  // black" theme in old versions of Windows.
-  virtual NativeTheme::PreferredColorScheme PreferredColorScheme() const;
-
-  // Returns the appropriate material color palette source for this OS.
-  virtual ColorProviderKey::UserColorSource PreferredColorSource() const;
-
-  // Returns OS-level preferred contrast, or `kNoPreference` if not
-  // set/applicable. This is not affected by e.g.
-  // `switches::kForceHighContrast`; that should be handled at the `NativeTheme`
-  // (i.e. caller) level.
-  virtual NativeTheme::PreferredContrast PreferredContrast() const;
-
-  // Returns whether the OS prefers reduced transparency.
-  virtual bool PrefersReducedTransparency() const;
-
-  // Returns whether the OS prefers inverted colors.
-  virtual bool PrefersInvertedColors() const;
-
-  // Returns whether forced colors are active at the OS level. This implies that
-  // various methods above should check `Color()` to decide how to behave. (They
-  // do not do so by default because when forced colors are not active, system
-  // colors may give an incomplete or incorrect picture of desired behavior.)
-  // This is not affected by e.g. "page colors"; that should be handled at the
-  // `NativeTheme` (i.e. caller) level.
-  virtual bool ForcedColorsActive() const;
-
-  // Returns OS-level accent color, if any.
-  virtual std::optional<SkColor> AccentColor() const;
-
-  // Returns OS-level colors, if available.
-  virtual std::optional<SkColor> Color(ColorId color_id) const;
-
-  // Returns OS' current scheme variant, if any.
-  virtual std::optional<ColorProviderKey::SchemeVariant> SchemeVariant() const;
+      base::RepeatingClosure cb);
 
   // Returns the interval between caret blinks. If this is zero, the caret will
   // not blink.
@@ -146,7 +79,7 @@ class COMPONENT_EXPORT(NATIVE_THEME) OsSettingsProvider {
 
  protected:
   // Invokes all registered callbacks.
-  void NotifyOnSettingsChanged(bool force_notify = false);
+  void NotifyOnSettingsChanged();
 
  private:
   PriorityLevel priority_level_;
diff --git a/ui/native_theme/os_settings_provider_mac.h b/ui/native_theme/os_settings_provider_mac.h
index f9a2667007e87..ff9696bcf549a 100644
--- a/ui/native_theme/os_settings_provider_mac.h
+++ b/ui/native_theme/os_settings_provider_mac.h
@@ -21,10 +21,6 @@ class COMPONENT_EXPORT(NATIVE_THEME) OsSettingsProviderMac
   ~OsSettingsProviderMac() override;
 
   // OsSettingsProvider:
-  NativeTheme::PreferredColorScheme PreferredColorScheme() const override;
-  NativeTheme::PreferredContrast PreferredContrast() const override;
-  bool PrefersReducedTransparency() const override;
-  bool PrefersInvertedColors() const override;
   base::TimeDelta CaretBlinkInterval() const override;
 
  private:
diff --git a/ui/native_theme/os_settings_provider_mac.mm b/ui/native_theme/os_settings_provider_mac.mm
index 2f22d35cfcb36..ccd220cb9877e 100644
--- a/ui/native_theme/os_settings_provider_mac.mm
+++ b/ui/native_theme/os_settings_provider_mac.mm
@@ -9,49 +9,14 @@
 
 #include <optional>
 
+#include "base/no_destructor.h"
 #include "ui/base/cocoa/defaults_utils.h"
-#include "ui/native_theme/native_theme.h"
 #include "ui/native_theme/os_settings_provider_mac.h"
 
-// Helper object to respond to light mode/dark mode changeovers.
-@interface EffectiveAppearanceObserver : NSObject
-@end
-
-@implementation EffectiveAppearanceObserver {
-  void (^_handler)() __strong;
-}
-
-- (instancetype)initWithHandler:(void (^)())handler {
-  self = [super init];
-  if (self) {
-    _handler = handler;
-    [NSApp addObserver:self
-            forKeyPath:@"effectiveAppearance"
-               options:0
-               context:nullptr];
-  }
-  return self;
-}
-
-- (void)dealloc {
-  [NSApp removeObserver:self forKeyPath:@"effectiveAppearance"];
-}
-
-- (void)observeValueForKeyPath:(NSString*)forKeyPath
-                      ofObject:(id)object
-                        change:(NSDictionary*)change
-                       context:(void*)context {
-  _handler();
-}
-
-@end
-
 namespace ui {
 
 struct OsSettingsProviderMac::ObjCMembers {
   id __strong non_blinking_cursor_token;
-  id __strong display_accessibility_notification_token;
-  EffectiveAppearanceObserver* __strong appearance_observer;
 };
 
 OsSettingsProviderMac::OsSettingsProviderMac()
@@ -70,59 +35,15 @@ OsSettingsProviderMac::OsSettingsProviderMac()
                       provider->NotifyOnSettingsChanged();
                     }];
   }
-
-  objc_members_->display_accessibility_notification_token =
-      [NSWorkspace.sharedWorkspace.notificationCenter
-          addObserverForName:
-              NSWorkspaceAccessibilityDisplayOptionsDidChangeNotification
-                      object:nil
-                       queue:nil
-                  usingBlock:^(NSNotification* notification) {
-                    provider->NotifyOnSettingsChanged();
-                  }];
-
-  objc_members_->appearance_observer =
-      [[EffectiveAppearanceObserver alloc] initWithHandler:^{
-        provider->NotifyOnSettingsChanged();
-      }];
 }
 
 OsSettingsProviderMac::~OsSettingsProviderMac() {
-  [NSNotificationCenter.defaultCenter
-      removeObserver:objc_members_->display_accessibility_notification_token];
   if (@available(macOS 15.0, *)) {
     [NSNotificationCenter.defaultCenter
         removeObserver:objc_members_->non_blinking_cursor_token];
   }
 }
 
-NativeTheme::PreferredColorScheme OsSettingsProviderMac::PreferredColorScheme()
-    const {
-  NSAppearanceName appearance =
-      [NSApp.effectiveAppearance bestMatchFromAppearancesWithNames:@[
-        NSAppearanceNameAqua, NSAppearanceNameDarkAqua
-      ]];
-  return [appearance isEqual:NSAppearanceNameDarkAqua]
-             ? NativeTheme::PreferredColorScheme::kDark
-             : NativeTheme::PreferredColorScheme::kLight;
-}
-
-NativeTheme::PreferredContrast OsSettingsProviderMac::PreferredContrast()
-    const {
-  return NSWorkspace.sharedWorkspace.accessibilityDisplayShouldIncreaseContrast
-             ? NativeTheme::PreferredContrast::kMore
-             : OsSettingsProvider::PreferredContrast();
-}
-
-bool OsSettingsProviderMac::PrefersReducedTransparency() const {
-  return NSWorkspace.sharedWorkspace
-      .accessibilityDisplayShouldReduceTransparency;
-}
-
-bool OsSettingsProviderMac::PrefersInvertedColors() const {
-  return NSWorkspace.sharedWorkspace.accessibilityDisplayShouldInvertColors;
-}
-
 base::TimeDelta OsSettingsProviderMac::CaretBlinkInterval() const {
   if (@available(macOS 15.0, *)) {
     if (AXPrefersNonBlinkingTextInsertionIndicator()) {
@@ -132,7 +53,7 @@ base::TimeDelta OsSettingsProviderMac::CaretBlinkInterval() const {
 
   // If there's insertion point flash rate info in NSUserDefaults, use the
   // blink period derived from that.
-  return TextInsertionCaretBlinkPeriodFromDefaults().value_or(
+  return ui::TextInsertionCaretBlinkPeriodFromDefaults().value_or(
       OsSettingsProvider::CaretBlinkInterval());
 }
 
diff --git a/ui/native_theme/os_settings_provider_win.cc b/ui/native_theme/os_settings_provider_win.cc
index 264d6863917ff..d736f83890e1a 100644
--- a/ui/native_theme/os_settings_provider_win.cc
+++ b/ui/native_theme/os_settings_provider_win.cc
@@ -6,117 +6,15 @@
 
 #include <windows.h>
 
-#include <array>
-#include <optional>
-#include <utility>
-
-#include "base/check.h"
-#include "base/containers/flat_map.h"
-#include "base/functional/bind.h"
-#include "base/metrics/histogram_functions.h"
-#include "base/task/sequenced_task_runner.h"
 #include "base/time/time.h"
-#include "base/win/dark_mode_support.h"
-#include "base/win/registry.h"
-#include "third_party/skia/include/core/SkColor.h"
-#include "ui/color/win/accent_color_observer.h"
-#include "ui/color/win/native_color_mixers_win.h"
-#include "ui/native_theme/native_theme.h"
 
 namespace ui {
 
 OsSettingsProviderWin::OsSettingsProviderWin()
-    : OsSettingsProvider(PriorityLevel::kProduction) {
-  // If there's no sequenced task runner handle, we can't be called back for
-  // registry changes. This generally happens in tests.
-  const bool observers_can_operate =
-      base::SequencedTaskRunner::HasCurrentDefault();
-
-  // Set initial state, and register for future changes if applicable.
-  if (hkcu_themes_regkey_.Open(
-          HKEY_CURRENT_USER,
-          L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize",
-          KEY_READ | KEY_NOTIFY) == ERROR_SUCCESS) {
-    UpdateForThemesRegkey();
-    if (observers_can_operate) {
-      RegisterThemesRegkeyObserver();
-    }
-  }
-  if (hkcu_color_filtering_regkey_.Open(
-          HKEY_CURRENT_USER, L"Software\\Microsoft\\ColorFiltering",
-          KEY_READ | KEY_NOTIFY) == ERROR_SUCCESS) {
-    UpdateForColorFilteringRegkey();
-    if (observers_can_operate) {
-      RegisterColorFilteringRegkeyObserver();
-    }
-  }
-  UpdateColors();
-
-  // Histogram high contrast state.
-  // NOTE: Reported in metrics; do not reorder, add additional values at end.
-  enum class HighContrastColorScheme {
-    kNone = 0,
-    kDark = 1,
-    kLight = 2,
-    kMaxValue = kLight,
-  };
-  auto color_scheme = HighContrastColorScheme::kNone;
-  if (PreferredContrast() == NativeTheme::PreferredContrast::kMore) {
-    color_scheme =
-        (PreferredColorScheme() == NativeTheme::PreferredColorScheme::kDark)
-            ? HighContrastColorScheme::kDark
-            : HighContrastColorScheme::kLight;
-  }
-  base::UmaHistogramEnumeration("Accessibility.WinHighContrastTheme",
-                                color_scheme);
-}
+    : OsSettingsProvider(PriorityLevel::kProduction) {}
 
 OsSettingsProviderWin::~OsSettingsProviderWin() = default;
 
-bool OsSettingsProviderWin::DarkColorSchemeAvailable() const {
-  return base::win::IsDarkModeAvailable();
-}
-
-NativeTheme::PreferredColorScheme OsSettingsProviderWin::PreferredColorScheme()
-    const {
-  if (const NativeTheme::PreferredColorScheme preferred_color_scheme =
-          OsSettingsProvider::PreferredColorScheme();
-      preferred_color_scheme !=
-      NativeTheme::PreferredColorScheme::kNoPreference) {
-    return preferred_color_scheme;
-  }
-
-  return in_dark_mode_ ? NativeTheme::PreferredColorScheme::kDark
-                       : NativeTheme::PreferredColorScheme::kLight;
-}
-
-ColorProviderKey::UserColorSource OsSettingsProviderWin::PreferredColorSource()
-    const {
-  return ColorProviderKey::UserColorSource::kBaseline;
-}
-
-bool OsSettingsProviderWin::PrefersReducedTransparency() const {
-  return prefers_reduced_transparency_;
-}
-
-bool OsSettingsProviderWin::PrefersInvertedColors() const {
-  return prefers_inverted_colors_;
-}
-
-bool OsSettingsProviderWin::ForcedColorsActive() const {
-  return forced_colors_active_;
-}
-
-std::optional<SkColor> OsSettingsProviderWin::AccentColor() const {
-  return accent_color_;
-}
-
-std::optional<SkColor> OsSettingsProviderWin::Color(ColorId color_id) const {
-  const auto entry = colors_.find(color_id);
-  return (entry == colors_.end()) ? std::nullopt
-                                  : std::make_optional(entry->second);
-}
-
 base::TimeDelta OsSettingsProviderWin::CaretBlinkInterval() const {
   // Unfortunately Windows does not seem to have any way to monitor changes to
   // this value; MSDN suggests apps "occasionally check the cursor settings —
@@ -133,117 +31,4 @@ base::TimeDelta OsSettingsProviderWin::CaretBlinkInterval() const {
                                         : base::Milliseconds(caret_blink_time);
 }
 
-void OsSettingsProviderWin::RegisterThemesRegkeyObserver() {
-  CHECK(hkcu_themes_regkey_.Valid());
-  CHECK(base::SequencedTaskRunner::HasCurrentDefault());
-  hkcu_themes_regkey_.StartWatching(base::BindOnce(
-      [](OsSettingsProviderWin* provider) {
-        const NativeTheme::PreferredColorScheme old_preferred_color_scheme =
-            provider->PreferredColorScheme();
-        const bool old_prefers_reduced_transparency =
-            provider->PrefersReducedTransparency();
-        provider->UpdateForThemesRegkey();
-        if (provider->PreferredColorScheme() != old_preferred_color_scheme ||
-            provider->PrefersReducedTransparency() !=
-                old_prefers_reduced_transparency) {
-          provider->NotifyOnSettingsChanged();
-        }
-
-        // `StartWatching()`'s callback is one-shot and must be re-registered
-        // for future notifications.
-        provider->RegisterThemesRegkeyObserver();
-      },
-      base::Unretained(this)));
-}
-
-void OsSettingsProviderWin::RegisterColorFilteringRegkeyObserver() {
-  CHECK(hkcu_color_filtering_regkey_.Valid());
-  CHECK(base::SequencedTaskRunner::HasCurrentDefault());
-  hkcu_color_filtering_regkey_.StartWatching(base::BindOnce(
-      [](OsSettingsProviderWin* provider) {
-        const bool old_prefers_inverted_colors =
-            provider->PrefersInvertedColors();
-        provider->UpdateForColorFilteringRegkey();
-        if (provider->PrefersInvertedColors() != old_prefers_inverted_colors) {
-          provider->NotifyOnSettingsChanged();
-        }
-
-        // `StartWatching()`'s callback is one-shot and must be re-registered
-        // for future notifications.
-        provider->RegisterColorFilteringRegkeyObserver();
-      },
-      base::Unretained(this)));
-}
-
-void OsSettingsProviderWin::UpdateForThemesRegkey() {
-  CHECK(hkcu_themes_regkey_.Valid());
-
-  DWORD apps_use_light_theme = 1;
-  hkcu_themes_regkey_.ReadValueDW(L"AppsUseLightTheme", &apps_use_light_theme);
-  in_dark_mode_ = !apps_use_light_theme;
-
-  DWORD enable_transparency = 1;
-  hkcu_themes_regkey_.ReadValueDW(L"EnableTransparency", &enable_transparency);
-  prefers_reduced_transparency_ = !enable_transparency;
-}
-
-void OsSettingsProviderWin::UpdateForColorFilteringRegkey() {
-  CHECK(hkcu_color_filtering_regkey_.Valid());
-
-  DWORD active = 0, filter_type = 0;
-  hkcu_color_filtering_regkey_.ReadValueDW(L"Active", &active);
-  if (active == 1) {
-    hkcu_color_filtering_regkey_.ReadValueDW(L"FilterType", &filter_type);
-  }
-  // 0 = Greyscale
-  // 1 = Invert
-  // 2 = Greyscale Inverted
-  // 3 = Deuteranopia
-  // 4 = Protanopia
-  // 5 = Tritanopia
-  prefers_inverted_colors_ = filter_type == 1;
-}
-
-void OsSettingsProviderWin::OnAccentColorMaybeChanged() {
-  const auto accent_color = AccentColorObserver::Get()->accent_color();
-  if (std::exchange(accent_color_, accent_color) != accent_color) {
-    NotifyOnSettingsChanged();
-  }
-}
-
-void OsSettingsProviderWin::UpdateColors() {
-  static constexpr auto kColors =
-      std::to_array<std::pair<ColorId, ui::ColorId>>(
-          {{ColorId::kButtonFace, kColorNativeBtnFace},
-           {ColorId::kButtonHighlight, kColorNativeBtnHighlight},
-           {ColorId::kScrollbar, kColorNativeScrollbar},
-           {ColorId::kWindow, kColorNativeWindow},
-           {ColorId::kWindowText, kColorNativeWindowText}});
-  const auto sys_colors = GetCurrentSysColors();
-  for (const auto& entry : kColors) {
-    colors_[entry.first] = sys_colors.at(entry.second);
-  }
-}
-
-void OsSettingsProviderWin::OnWndProc(HWND hwnd,
-                                      UINT message,
-                                      WPARAM wparam,
-                                      LPARAM lparam) {
-  if (message == WM_SYSCOLORCHANGE) {
-    UpdateColors();
-    if (ForcedColorsActive()) {
-      NotifyOnSettingsChanged(true);
-    }
-  } else if (message == WM_SETTINGCHANGE && wparam == SPI_SETHIGHCONTRAST) {
-    if (HIGHCONTRAST result = {.cbSize = sizeof(HIGHCONTRAST)};
-        SystemParametersInfo(SPI_GETHIGHCONTRAST, result.cbSize, &result, 0)) {
-      const bool old_forced_colors_active = ForcedColorsActive();
-      forced_colors_active_ = !!(result.dwFlags & HCF_HIGHCONTRASTON);
-      if (ForcedColorsActive() != old_forced_colors_active) {
-        NotifyOnSettingsChanged();
-      }
-    }
-  }
-}
-
 }  // namespace ui
diff --git a/ui/native_theme/os_settings_provider_win.h b/ui/native_theme/os_settings_provider_win.h
index a701d5444b160..c31976123001d 100644
--- a/ui/native_theme/os_settings_provider_win.h
+++ b/ui/native_theme/os_settings_provider_win.h
@@ -5,14 +5,7 @@
 #ifndef UI_NATIVE_THEME_OS_SETTINGS_PROVIDER_WIN_H_
 #define UI_NATIVE_THEME_OS_SETTINGS_PROVIDER_WIN_H_
 
-#include "base/callback_list.h"
 #include "base/component_export.h"
-#include "base/containers/flat_map.h"
-#include "base/functional/bind.h"
-#include "base/win/registry.h"
-#include "third_party/skia/include/core/SkColor.h"
-#include "ui/color/win/accent_color_observer.h"
-#include "ui/gfx/win/singleton_hwnd.h"
 #include "ui/native_theme/os_settings_provider.h"
 
 namespace ui {
@@ -25,59 +18,7 @@ class COMPONENT_EXPORT(NATIVE_THEME) OsSettingsProviderWin
   OsSettingsProviderWin& operator=(const OsSettingsProviderWin&) = delete;
   ~OsSettingsProviderWin() override;
 
-  bool DarkColorSchemeAvailable() const override;
-  NativeTheme::PreferredColorScheme PreferredColorScheme() const override;
-  ColorProviderKey::UserColorSource PreferredColorSource() const override;
-  bool PrefersReducedTransparency() const override;
-  bool PrefersInvertedColors() const override;
-  bool ForcedColorsActive() const override;
-  std::optional<SkColor> AccentColor() const override;
-  std::optional<SkColor> Color(ColorId color_id) const override;
   base::TimeDelta CaretBlinkInterval() const override;
-
- private:
-  // Registers an observer to monitor the respective registry keys.
-  void RegisterThemesRegkeyObserver();
-  void RegisterColorFilteringRegkeyObserver();
-
-  // Updates values affected by the respective registry keys.
-  void UpdateForThemesRegkey();
-  void UpdateForColorFilteringRegkey();
-
-  // Updates `accent_color_`. If it changed, notifies callbacks.
-  void OnAccentColorMaybeChanged();
-
-  // Updates the values in `colors_`.
-  void UpdateColors();
-
-  // Called by `singleton_hwnd_observer_`.
-  void OnWndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);
-
-  // Color/high contrast mode change subscription.
-  base::CallbackListSubscription hwnd_subscription_ =
-      gfx::SingletonHwnd::GetInstance()->RegisterCallback(
-          base::BindRepeating(&OsSettingsProviderWin::OnWndProc,
-                              base::Unretained(this)));
-
-  // Dark Mode/Transparency registry key.
-  base::win::RegKey hkcu_themes_regkey_;
-
-  // Inverted colors registry key.
-  base::win::RegKey hkcu_color_filtering_regkey_;
-
-  // Accent color subscription.
-  base::CallbackListSubscription accent_color_subscription_ =
-      AccentColorObserver::Get()->Subscribe(
-          base::BindRepeating(&OsSettingsProviderWin::OnAccentColorMaybeChanged,
-                              base::Unretained(this)));
-
-  bool in_dark_mode_ = false;
-  bool prefers_reduced_transparency_ = false;
-  bool prefers_inverted_colors_ = false;
-  bool forced_colors_active_ = false;
-  std::optional<SkColor> accent_color_ =
-      AccentColorObserver::Get()->accent_color();
-  base::flat_map<ColorId, SkColor> colors_;
 };
 
 }  // namespace ui
diff --git a/ui/native_theme/test_native_theme.cc b/ui/native_theme/test_native_theme.cc
new file mode 100644
index 0000000000000..b9c01793d8d5d
--- /dev/null
+++ b/ui/native_theme/test_native_theme.cc
@@ -0,0 +1,46 @@
+// Copyright 2018 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/native_theme/test_native_theme.h"
+
+namespace ui {
+
+TestNativeTheme::TestNativeTheme() = default;
+TestNativeTheme::~TestNativeTheme() = default;
+
+gfx::Size TestNativeTheme::GetPartSize(Part part,
+                                       State state,
+                                       const ExtraParams& extra) const {
+  return gfx::Size();
+}
+
+void TestNativeTheme::Paint(cc::PaintCanvas* canvas,
+                            const ui::ColorProvider* color_provider,
+                            Part part,
+                            State state,
+                            const gfx::Rect& rect,
+                            const ExtraParams& extra,
+                            bool forced_colors,
+                            PreferredColorScheme color_scheme,
+                            PreferredContrast contrast,
+                            const std::optional<SkColor>& accent_color) const {}
+
+bool TestNativeTheme::SupportsNinePatch(Part part) const {
+  return false;
+}
+
+gfx::Size TestNativeTheme::GetNinePatchCanvasSize(Part part) const {
+  return gfx::Size();
+}
+
+gfx::Rect TestNativeTheme::GetNinePatchAperture(Part part) const {
+  return gfx::Rect();
+}
+
+void TestNativeTheme::SetPreferredColorScheme(
+    PreferredColorScheme color_scheme) {
+  set_preferred_color_scheme(color_scheme);
+}
+
+}  // namespace ui
diff --git a/ui/native_theme/test_native_theme.h b/ui/native_theme/test_native_theme.h
new file mode 100644
index 0000000000000..cf2ffd0dafb5b
--- /dev/null
+++ b/ui/native_theme/test_native_theme.h
@@ -0,0 +1,45 @@
+// Copyright 2018 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_NATIVE_THEME_TEST_NATIVE_THEME_H_
+#define UI_NATIVE_THEME_TEST_NATIVE_THEME_H_
+
+#include "base/component_export.h"
+#include "ui/native_theme/native_theme.h"
+
+namespace ui {
+
+class COMPONENT_EXPORT(NATIVE_THEME) TestNativeTheme : public NativeTheme {
+ public:
+  TestNativeTheme();
+
+  TestNativeTheme(const TestNativeTheme&) = delete;
+  TestNativeTheme& operator=(const TestNativeTheme&) = delete;
+
+  ~TestNativeTheme() override;
+
+  // NativeTheme:
+  gfx::Size GetPartSize(Part part,
+                        State state,
+                        const ExtraParams& extra) const override;
+  void Paint(cc::PaintCanvas* canvas,
+             const ui::ColorProvider* color_provider,
+             Part part,
+             State state,
+             const gfx::Rect& rect,
+             const ExtraParams& extra,
+             bool forced_colors,
+             PreferredColorScheme color_scheme,
+             PreferredContrast contrast,
+             const std::optional<SkColor>& accent_color) const override;
+  bool SupportsNinePatch(Part part) const override;
+  gfx::Size GetNinePatchCanvasSize(Part part) const override;
+  gfx::Rect GetNinePatchAperture(Part part) const override;
+
+  void SetPreferredColorScheme(PreferredColorScheme color_scheme);
+};
+
+}  // namespace ui
+
+#endif  // UI_NATIVE_THEME_TEST_NATIVE_THEME_H_
diff --git a/ui/qt/native_theme_qt.cc b/ui/qt/native_theme_qt.cc
index abbb52cf5c624..62c87027b092e 100644
--- a/ui/qt/native_theme_qt.cc
+++ b/ui/qt/native_theme_qt.cc
@@ -27,8 +27,12 @@ NativeThemeQt::NativeThemeQt(QtInterface* shim)
 
 NativeThemeQt::~NativeThemeQt() = default;
 
-void NativeThemeQt::OnQtThemeChanged() {
-  OnToolkitSettingsChanged(false);
+void NativeThemeQt::ThemeChanged(bool prefer_dark_theme) {
+  set_preferred_color_scheme(
+      (IsForcedDarkMode() || prefer_dark_theme)
+          ? ui::NativeTheme::PreferredColorScheme::kDark
+          : ui::NativeTheme::PreferredColorScheme::kLight);
+  NotifyOnNativeThemeUpdated();
 }
 
 DISABLE_CFI_VCALL
@@ -36,11 +40,11 @@ void NativeThemeQt::PaintFrameTopArea(
     cc::PaintCanvas* canvas,
     State state,
     const gfx::Rect& rect,
-    const FrameTopAreaExtraParams& extra_params) const {
+    const FrameTopAreaExtraParams& frame_top_area) const {
   auto image = shim_->DrawHeader(
-      rect.width(), rect.height(), extra_params.default_background_color,
-      extra_params.is_active ? ColorState::kNormal : ColorState::kInactive,
-      extra_params.use_custom_frame);
+      rect.width(), rect.height(), frame_top_area.default_background_color,
+      frame_top_area.is_active ? ColorState::kNormal : ColorState::kInactive,
+      frame_top_area.use_custom_frame);
   SkImageInfo image_info = SkImageInfo::Make(
       image.width, image.height, kBGRA_8888_SkColorType, kPremul_SkAlphaType);
   SkBitmap bitmap;
diff --git a/ui/qt/native_theme_qt.h b/ui/qt/native_theme_qt.h
index 80530ffbc7eda..33274152abcbd 100644
--- a/ui/qt/native_theme_qt.h
+++ b/ui/qt/native_theme_qt.h
@@ -19,8 +19,7 @@ class NativeThemeQt : public ui::NativeThemeAura {
   NativeThemeQt& operator=(const NativeThemeQt&) = delete;
   ~NativeThemeQt() override;
 
-  // Updates toolkit-related settings.
-  void OnQtThemeChanged();
+  void ThemeChanged(bool prefer_dark_theme);
 
  protected:
   // ui::NativeThemeAura:
@@ -28,7 +27,7 @@ class NativeThemeQt : public ui::NativeThemeAura {
       cc::PaintCanvas* canvas,
       State state,
       const gfx::Rect& rect,
-      const FrameTopAreaExtraParams& extra_params) const override;
+      const FrameTopAreaExtraParams& frame_top_area) const override;
 
  private:
   // IMPORTANT NOTE: All members that use `shim_` must be decorated with
diff --git a/ui/qt/os_settings_provider_qt.cc b/ui/qt/os_settings_provider_qt.cc
index 958079ed56a9a..fe49966171052 100644
--- a/ui/qt/os_settings_provider_qt.cc
+++ b/ui/qt/os_settings_provider_qt.cc
@@ -6,8 +6,6 @@
 
 #include "base/memory/raw_ptr.h"
 #include "base/time/time.h"
-#include "ui/gfx/color_utils.h"
-#include "ui/native_theme/native_theme.h"
 #include "ui/qt/qt_interface.h"
 
 namespace qt {
@@ -17,15 +15,6 @@ OsSettingsProviderQt::OsSettingsProviderQt(QtInterface* shim)
 
 OsSettingsProviderQt::~OsSettingsProviderQt() = default;
 
-DISABLE_CFI_VCALL
-ui::NativeTheme::PreferredColorScheme
-OsSettingsProviderQt::PreferredColorScheme() const {
-  return color_utils::IsDark(
-             shim_->GetColor(ColorType::kWindowBg, ColorState::kNormal))
-             ? ui::NativeTheme::PreferredColorScheme::kDark
-             : ui::NativeTheme::PreferredColorScheme::kLight;
-}
-
 DISABLE_CFI_VCALL
 base::TimeDelta OsSettingsProviderQt::CaretBlinkInterval() const {
   // Unfortunately Qt does not seem to have any way to monitor changes to this
diff --git a/ui/qt/os_settings_provider_qt.h b/ui/qt/os_settings_provider_qt.h
index 1f8ddb34f9295..2846108bbdd03 100644
--- a/ui/qt/os_settings_provider_qt.h
+++ b/ui/qt/os_settings_provider_qt.h
@@ -19,7 +19,6 @@ class OsSettingsProviderQt : public ui::OsSettingsProvider {
   ~OsSettingsProviderQt() override;
 
   // ui::OsSettingsProvider:
-  ui::NativeTheme::PreferredColorScheme PreferredColorScheme() const override;
   base::TimeDelta CaretBlinkInterval() const override;
 
  private:
diff --git a/ui/qt/qt_ui.cc b/ui/qt/qt_ui.cc
index f97d312b78a72..12a6c16e60cd1 100644
--- a/ui/qt/qt_ui.cc
+++ b/ui/qt/qt_ui.cc
@@ -355,9 +355,10 @@ std::vector<std::string> QtUi::GetCmdLineFlagsForCopy() const {
                         base::NumberToString(qt_version_)})};
 }
 
+DISABLE_CFI_VCALL
 bool QtUi::PreferDarkTheme() const {
-  return native_theme_->preferred_color_scheme() ==
-         ui::NativeTheme::PreferredColorScheme::kDark;
+  return color_utils::IsDark(
+      shim_->GetColor(ColorType::kWindowBg, ColorState::kNormal));
 }
 
 DISABLE_CFI_VCALL
@@ -368,7 +369,7 @@ void QtUi::SetDarkTheme(bool dark) {
 DISABLE_CFI_VCALL
 void QtUi::SetAccentColor(std::optional<SkColor> accent_color) {
   accent_color_ = accent_color;
-  native_theme_->NotifyOnNativeThemeUpdated();
+  ThemeChanged();
 }
 
 DISABLE_CFI_VCALL
@@ -444,7 +445,7 @@ void QtUi::FontChanged() {
 }
 
 void QtUi::ThemeChanged() {
-  native_theme_->OnQtThemeChanged();
+  native_theme_->ThemeChanged(PreferDarkTheme());
 }
 
 void QtUi::ScaleFactorMaybeChanged() {
diff --git a/ui/views/animation/ink_drop_impl_unittest.cc b/ui/views/animation/ink_drop_impl_unittest.cc
index 7a98e1dd0194b..f410965587d34 100644
--- a/ui/views/animation/ink_drop_impl_unittest.cc
+++ b/ui/views/animation/ink_drop_impl_unittest.cc
@@ -14,8 +14,7 @@
 #include "ui/compositor/scoped_animation_duration_scale_mode.h"
 #include "ui/gfx/animation/animation.h"
 #include "ui/gfx/animation/animation_test_api.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
-#include "ui/native_theme/native_theme.h"
+#include "ui/native_theme/test_native_theme.h"
 #include "ui/views/animation/ink_drop.h"
 #include "ui/views/animation/ink_drop_ripple.h"
 #include "ui/views/animation/test/ink_drop_impl_test_api.h"
@@ -292,14 +291,15 @@ TEST_F(InkDropImplTest, RippleAndHighlightRecreatedOnSizeChange) {
 // Make sure the InkDropRipple and InkDropHighlight get recreated when the host
 // theme changes.
 TEST_F(InkDropImplTest, RippleAndHighlightRecreatedOnHostThemeChange) {
-  ui::MockOsSettingsProvider os_settings_provider;
   test_api().SetShouldHighlight(true);
   ink_drop()->AnimateToState(InkDropState::ACTIVATED);
   EXPECT_EQ(1, ink_drop_host()->num_ink_drop_ripples_created());
   EXPECT_EQ(1, ink_drop_host()->num_ink_drop_highlights_created());
 
-  os_settings_provider.SetPreferredColorScheme(
+  ui::TestNativeTheme native_theme;
+  native_theme.SetPreferredColorScheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
+  widget()->SetNativeThemeForTest(&native_theme);
   EXPECT_EQ(2, ink_drop_host()->num_ink_drop_ripples_created());
   EXPECT_EQ(2, ink_drop_host()->num_ink_drop_highlights_created());
   DestroyWidget();
diff --git a/ui/views/animation/ink_drop_util.cc b/ui/views/animation/ink_drop_util.cc
index 6817b64bdb48a..6e9b5c6a20151 100644
--- a/ui/views/animation/ink_drop_util.cc
+++ b/ui/views/animation/ink_drop_util.cc
@@ -60,8 +60,7 @@ bool UsingPlatformHighContrastInkDrop(const View* view) {
   }
   const ui::NativeTheme* const native_theme = view->GetNativeTheme();
   CHECK(native_theme);
-  return native_theme->forced_colors() !=
-             ui::ColorProviderKey::ForcedColors::kNone &&
+  return native_theme->forced_colors() &&
          native_theme->preferred_contrast() ==
              ui::NativeTheme::PreferredContrast::kMore &&
          base::FeatureList::IsEnabled(
diff --git a/ui/views/controls/button/label_button_label_unittest.cc b/ui/views/controls/button/label_button_label_unittest.cc
index 79057d1723df0..ea4f76f6778e1 100644
--- a/ui/views/controls/button/label_button_label_unittest.cc
+++ b/ui/views/controls/button/label_button_label_unittest.cc
@@ -13,7 +13,6 @@
 #include "ui/color/color_id.h"
 #include "ui/color/color_provider.h"
 #include "ui/color/color_variant.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
 #include "ui/views/test/views_test_base.h"
 
@@ -53,6 +52,8 @@ class LabelButtonLabelTest : public ViewsTestBase {
     ViewsTestBase::SetUp();
 
     widget_ = CreateTestWidget(Widget::InitParams::CLIENT_OWNS_WIDGET);
+    widget_->GetNativeTheme()->set_preferred_color_scheme(
+        ui::NativeTheme::PreferredColorScheme::kLight);
 
     widget_->SetContentsView(
         std::make_unique<TestLabel>(&last_color_, &last_requested_color_));
@@ -64,9 +65,11 @@ class LabelButtonLabelTest : public ViewsTestBase {
     ViewsTestBase::TearDown();
   }
 
- protected:
-  ui::MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
+  void SetPreferredColorScheme(
+      ui::NativeTheme::PreferredColorScheme color_scheme) {
+    ui::NativeTheme* native_theme = widget_->GetNativeTheme();
+    native_theme->set_preferred_color_scheme(color_scheme);
+    native_theme->NotifyOnNativeThemeUpdated();
   }
 
   TestLabel* label() {
@@ -79,7 +82,6 @@ class LabelButtonLabelTest : public ViewsTestBase {
   }
 
  private:
-  ui::MockOsSettingsProvider os_settings_provider_;
   std::unique_ptr<views::Widget> widget_;
   SkColor last_color_ = gfx::kPlaceholderColor;
   std::optional<ui::ColorVariant> last_requested_color_;
@@ -98,8 +100,7 @@ TEST_F(LabelButtonLabelTest, Colors) {
       label()->GetColorProvider()->GetColor(ui::kColorLabelForegroundDisabled);
   EXPECT_EQ(default_theme_disabled_color, last_color());
 
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kDark);
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kDark);
 
   SkColor dark_theme_disabled_color =
       label()->GetColorProvider()->GetColor(ui::kColorLabelForegroundDisabled);
@@ -126,8 +127,7 @@ TEST_F(LabelButtonLabelTest, Colors) {
   EXPECT_EQ(SK_ColorMAGENTA, last_color());
 
   // Disabled still overridden after a theme change.
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kLight);
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_EQ(SK_ColorMAGENTA, last_color());
 
   // The enabled color still gets its value from the theme.
@@ -160,8 +160,7 @@ TEST_F(LabelButtonLabelTest, ColorIds) {
             label()->GetColorProvider()->GetColor(ui::kColorBadgeBackground));
 
   // Still overridden after a theme change.
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kDark);
+  SetPreferredColorScheme(ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_EQ(last_requested_color(), ui::kColorBadgeBackground);
   EXPECT_EQ(last_color(),
             label()->GetColorProvider()->GetColor(ui::kColorBadgeBackground));
diff --git a/ui/views/controls/button/label_button_unittest.cc b/ui/views/controls/button/label_button_unittest.cc
index 95f4de981afe3..689868af8fc3e 100644
--- a/ui/views/controls/button/label_button_unittest.cc
+++ b/ui/views/controls/button/label_button_unittest.cc
@@ -30,7 +30,6 @@
 #include "ui/gfx/geometry/vector2d.h"
 #include "ui/gfx/image/image_unittest_util.h"
 #include "ui/gfx/text_utils.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
 #include "ui/views/accessibility/view_accessibility.h"
 #include "ui/views/animation/ink_drop.h"
@@ -84,6 +83,10 @@ class LabelButtonTest : public test::WidgetTest {
     // used (which could be derived from the Widget's NativeTheme).
     test_widget_ = CreateTopLevelPlatformWidget();
 
+    // The test code below is not prepared to handle dark mode.
+    test_widget_->GetNativeTheme()->set_preferred_color_scheme(
+        ui::NativeTheme::PreferredColorScheme::kLight);
+
     // Ensure the Widget is active, since LabelButton appearance in inactive
     // Windows is platform-dependent.
     test_widget_->Show();
@@ -120,11 +123,14 @@ class LabelButtonTest : public test::WidgetTest {
     WidgetTest::TearDown();
   }
 
- protected:
-  ui::MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
+  void UseDarkColors() {
+    ui::NativeTheme* native_theme = test_widget_->GetNativeTheme();
+    native_theme->set_preferred_color_scheme(
+        ui::NativeTheme::PreferredColorScheme::kDark);
+    native_theme->NotifyOnNativeThemeUpdated();
   }
 
+ protected:
   TestLabelButton* button() {
     return static_cast<TestLabelButton*>(
         test_widget_->GetContentsView()->GetViewByID(1));
@@ -135,7 +141,6 @@ class LabelButtonTest : public test::WidgetTest {
   SkColor styled_highlight_text_color_ = 0;
 
  private:
-  ui::MockOsSettingsProvider os_settings_provider_;
   raw_ptr<Widget> test_widget_ = nullptr;
 };
 
@@ -744,8 +749,7 @@ TEST_F(LabelButtonTest, SetEnabledTextColorsResetsToThemeColors) {
 
   // Toggle dark mode. This should not replace the enabled text color as it's
   // been manually overridden above.
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kDark);
+  UseDarkColors();
   EXPECT_EQ(kReplacementColor, button()->label()->GetEnabledColor());
 
   // Removing the enabled text color restore colors from the new theme, not
@@ -767,8 +771,7 @@ TEST_F(LabelButtonTest, SetEnabledTextColorIds) {
 
   // Toggle dark mode. This should not replace the enabled text color as it's
   // been manually overridden above.
-  os_settings_provider().SetPreferredColorScheme(
-      ui::NativeTheme::PreferredColorScheme::kDark);
+  UseDarkColors();
   EXPECT_EQ(button()->label()->GetRequestedEnabledColor(), ui::kColorAccent);
   EXPECT_EQ(button()->label()->GetEnabledColor(),
             button()->GetColorProvider()->GetColor(ui::kColorAccent));
diff --git a/ui/views/controls/styled_label_unittest.cc b/ui/views/controls/styled_label_unittest.cc
index d4f06a81686cc..8636865b62e13 100644
--- a/ui/views/controls/styled_label_unittest.cc
+++ b/ui/views/controls/styled_label_unittest.cc
@@ -24,8 +24,6 @@
 #include "ui/base/ui_base_switches.h"
 #include "ui/gfx/font_list.h"
 #include "ui/gfx/text_constants.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
-#include "ui/native_theme/native_theme.h"
 #include "ui/views/accessibility/view_accessibility.h"
 #include "ui/views/border.h"
 #include "ui/views/controls/link.h"
@@ -96,9 +94,6 @@ class StyledLabelInWidgetTest : public ViewsTestBase {
     ViewsTestBase::TearDown();
   }
 
-  ui::MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
-  }
   Widget* widget() const { return widget_.get(); }
 
   StyledLabel* InitStyledLabel(const std::string& ascii_text) {
@@ -110,7 +105,6 @@ class StyledLabelInWidgetTest : public ViewsTestBase {
   }
 
  private:
-  ui::MockOsSettingsProvider os_settings_provider_;
   std::unique_ptr<Widget> widget_;
 };
 
@@ -381,6 +375,12 @@ TEST_F(StyledLabelInWidgetTest, Color) {
   styled->SetBounds(0, 0, 1000, 1000);
   test::RunScheduledLayout(styled);
 
+  // The code below is not prepared to deal with dark mode.
+  auto* const native_theme = widget()->GetNativeTheme();
+  native_theme->set_preferred_color_scheme(
+      ui::NativeTheme::PreferredColorScheme::kLight);
+  native_theme->NotifyOnNativeThemeUpdated();
+
   auto* container = widget()->GetContentsView();
   // Obtain the default text color for a label.
   Label* label =
@@ -439,13 +439,16 @@ TEST_F(StyledLabelInWidgetTest, SetBackgroundColorIdReactsToThemeChange) {
   test::RunScheduledLayout(styled);
 
   ASSERT_THAT(styled->children(), SizeIs(1u));
-  os_settings_provider().SetPreferredColorScheme(
+  auto* const native_theme = widget()->GetNativeTheme();
+  native_theme->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
+  native_theme->NotifyOnNativeThemeUpdated();
   EXPECT_EQ(widget()->GetColorProvider()->GetColor(ui::kColorDialogBackground),
             LabelAt(styled, 0)->GetBackgroundColor());
 
-  os_settings_provider().SetPreferredColorScheme(
+  native_theme->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kLight);
+  native_theme->NotifyOnNativeThemeUpdated();
   EXPECT_EQ(widget()->GetColorProvider()->GetColor(ui::kColorDialogBackground),
             LabelAt(styled, 0)->GetBackgroundColor());
 
@@ -453,8 +456,9 @@ TEST_F(StyledLabelInWidgetTest, SetBackgroundColorIdReactsToThemeChange) {
   EXPECT_EQ(widget()->GetColorProvider()->GetColor(ui::kColorAlertHighSeverity),
             LabelAt(styled, 0)->GetBackgroundColor());
 
-  os_settings_provider().SetPreferredColorScheme(
+  native_theme->set_preferred_color_scheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
+  native_theme->NotifyOnNativeThemeUpdated();
   EXPECT_EQ(widget()->GetColorProvider()->GetColor(ui::kColorAlertHighSeverity),
             LabelAt(styled, 0)->GetBackgroundColor());
 }
diff --git a/ui/views/widget/widget.cc b/ui/views/widget/widget.cc
index 5c1709ba25c80..b95e407b8dc1a 100644
--- a/ui/views/widget/widget.cc
+++ b/ui/views/widget/widget.cc
@@ -1709,6 +1709,12 @@ void Widget::NotifyPaintAsActiveChanged() {
 }
 
 void Widget::SetNativeTheme(ui::NativeTheme* native_theme) {
+  // If `native_theme_` has been set for testing ensure the theme instance is
+  // not reset.
+  if (native_theme_set_for_testing_) {
+    return;
+  }
+
   const bool is_update = native_theme_ && (native_theme_ != native_theme);
   native_theme_ = native_theme;
   native_theme_observation_.Reset();
diff --git a/ui/views/widget/widget.h b/ui/views/widget/widget.h
index 956557aa405cc..f6014bf64ca08 100644
--- a/ui/views/widget/widget.h
+++ b/ui/views/widget/widget.h
@@ -1436,6 +1436,12 @@ class VIEWS_EXPORT Widget : public internal::NativeWidgetDelegate,
       ui::ColorProviderKey::ColorMode color_mode,
       ui::ColorProviderKey::ForcedColors forced_colors) const override;
 
+  // Set the native theme from which this widget gets color from for testing.
+  void SetNativeThemeForTest(ui::NativeTheme* native_theme) {
+    SetNativeTheme(native_theme);
+    native_theme_set_for_testing_ = true;
+  }
+
   ui::ColorProviderKey GetColorProviderKeyForTesting() const;
 
   // Causes IsFullscreen() to also check parent state, since this widget is
@@ -1749,6 +1755,11 @@ class VIEWS_EXPORT Widget : public internal::NativeWidgetDelegate,
   // If nullptr, defaults to use the regular native theme.
   raw_ptr<ui::NativeTheme> native_theme_ = nullptr;
 
+  // A flag that prevents the widget from updating its instance of
+  // `native_theme_`. This is necessary during testing as theme updates may
+  // trigger a reset of the explicitly set test theme.
+  bool native_theme_set_for_testing_ = false;
+
   // By default, widgets are assumed to correspond to windows. If a parent
   // widget is fullscreen, then the child widget is a popup which is not
   // fullscreen. However, on macOS some child widgets logically correspond to
diff --git a/ui/views/widget/widget_unittest.cc b/ui/views/widget/widget_unittest.cc
index ae92ccd3b5e21..8ea278b16b961 100644
--- a/ui/views/widget/widget_unittest.cc
+++ b/ui/views/widget/widget_unittest.cc
@@ -47,8 +47,8 @@
 #include "ui/gfx/color_palette.h"
 #include "ui/gfx/geometry/point.h"
 #include "ui/gfx/native_ui_types.h"
-#include "ui/native_theme/mock_os_settings_provider.h"
 #include "ui/native_theme/native_theme.h"
+#include "ui/native_theme/test_native_theme.h"
 #include "ui/views/bubble/bubble_dialog_delegate_view.h"
 #include "ui/views/buildflags.h"
 #include "ui/views/controls/button/label_button.h"
@@ -378,11 +378,6 @@ class WidgetColorModeTest : public WidgetTest {
     WidgetTest::TearDown();
   }
 
- protected:
-  ui::MockOsSettingsProvider& os_settings_provider() {
-    return os_settings_provider_;
-  }
-
  private:
   static void AddColor(ui::ColorProvider* provider,
                        const ui::ColorProviderKey& key) {
@@ -391,15 +386,15 @@ class WidgetColorModeTest : public WidgetTest {
         key.color_mode == ui::ColorProviderKey::ColorMode::kDark ? kDarkColor
                                                                  : kLightColor};
   }
-
-  ui::MockOsSettingsProvider os_settings_provider_;
 };
 
 TEST_F(WidgetColorModeTest, ColorModeOverride_NoOverride) {
+  ui::TestNativeTheme test_theme;
   std::unique_ptr<Widget> widget = base::WrapUnique(
       CreateTopLevelPlatformWidget(Widget::InitParams::CLIENT_OWNS_WIDGET));
-  os_settings_provider().SetPreferredColorScheme(
+  test_theme.SetPreferredColorScheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
+  widget->SetNativeThemeForTest(&test_theme);
 
   widget->SetColorModeOverride(std::nullopt);
   // Verify that we resolve the dark color when we don't override color mode.
@@ -408,8 +403,12 @@ TEST_F(WidgetColorModeTest, ColorModeOverride_NoOverride) {
 }
 
 TEST_F(WidgetColorModeTest, ColorModeOverride_DarkOverride) {
+  ui::TestNativeTheme test_theme;
   std::unique_ptr<Widget> widget = base::WrapUnique(
       CreateTopLevelPlatformWidget(Widget::InitParams::CLIENT_OWNS_WIDGET));
+  test_theme.SetPreferredColorScheme(
+      ui::NativeTheme::PreferredColorScheme::kLight);
+  widget->SetNativeThemeForTest(&test_theme);
 
   widget->SetColorModeOverride(ui::ColorProviderKey::ColorMode::kDark);
   // Verify that we resolve the light color even though the theme is dark.
@@ -418,10 +417,12 @@ TEST_F(WidgetColorModeTest, ColorModeOverride_DarkOverride) {
 }
 
 TEST_F(WidgetColorModeTest, ColorModeOverride_LightOverride) {
+  ui::TestNativeTheme test_theme;
   std::unique_ptr<Widget> widget = base::WrapUnique(
       CreateTopLevelPlatformWidget(Widget::InitParams::CLIENT_OWNS_WIDGET));
-  os_settings_provider().SetPreferredColorScheme(
+  test_theme.SetPreferredColorScheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
+  widget->SetNativeThemeForTest(&test_theme);
 
   widget->SetColorModeOverride(ui::ColorProviderKey::ColorMode::kLight);
   // Verify that we resolve the light color even though the theme is dark.
@@ -431,10 +432,12 @@ TEST_F(WidgetColorModeTest, ColorModeOverride_LightOverride) {
 
 TEST_F(WidgetColorModeTest, ChildInheritsColorMode_NoOverrides) {
   // Create the parent widget and set the native theme to dark.
+  ui::TestNativeTheme test_theme;
   std::unique_ptr<Widget> widget = base::WrapUnique(
       CreateTopLevelPlatformWidget(Widget::InitParams::CLIENT_OWNS_WIDGET));
-  os_settings_provider().SetPreferredColorScheme(
+  test_theme.SetPreferredColorScheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
+  widget->SetNativeThemeForTest(&test_theme);
 
   // Create the child widget.
   std::unique_ptr<Widget> widget_child =
@@ -450,8 +453,9 @@ TEST_F(WidgetColorModeTest, ChildInheritsColorMode_NoOverrides) {
   EXPECT_EQ(kDarkColor,
             widget_child->GetColorProvider()->GetColor(ui::kColorSysPrimary));
 
-  // Set the OS to light. The child should inherit the color mode of the parent.
-  os_settings_provider().SetPreferredColorScheme(
+  // Set the parent's native theme to light. The child should inherit the color
+  // mode of the parent.
+  test_theme.SetPreferredColorScheme(
       ui::NativeTheme::PreferredColorScheme::kLight);
   EXPECT_EQ(kLightColor,
             widget->GetColorProvider()->GetColor(ui::kColorSysPrimary));
@@ -461,10 +465,12 @@ TEST_F(WidgetColorModeTest, ChildInheritsColorMode_NoOverrides) {
 
 TEST_F(WidgetColorModeTest, ChildInheritsColorMode_Overrides) {
   // Create the parent widget and set the native theme to dark.
+  ui::TestNativeTheme test_theme;
   std::unique_ptr<Widget> widget = base::WrapUnique(
       CreateTopLevelPlatformWidget(Widget::InitParams::CLIENT_OWNS_WIDGET));
-  os_settings_provider().SetPreferredColorScheme(
+  test_theme.SetPreferredColorScheme(
       ui::NativeTheme::PreferredColorScheme::kDark);
+  widget->SetNativeThemeForTest(&test_theme);
 
   // Create the child widget.
   std::unique_ptr<Widget> widget_child =
@@ -1704,7 +1710,8 @@ TEST_P(WidgetWithDestroyedNativeViewOrNativeWidgetTest, OnNativeFocus) {
 }
 
 TEST_P(WidgetWithDestroyedNativeViewOrNativeWidgetTest, OnNativeThemeUpdated) {
-  widget()->OnNativeThemeUpdated(ui::NativeTheme::GetInstanceForNativeUi());
+  ui::TestNativeTheme theme;
+  widget()->OnNativeThemeUpdated(&theme);
 }
 
 TEST_P(WidgetWithDestroyedNativeViewOrNativeWidgetTest,
