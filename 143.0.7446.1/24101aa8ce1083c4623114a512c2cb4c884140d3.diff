diff --git a/base/process/memory.h b/base/process/memory.h
index b8147f0c93237..5d11d4a1560b1 100644
--- a/base/process/memory.h
+++ b/base/process/memory.h
@@ -100,14 +100,6 @@ struct UncheckedFreeDeleter {
   inline void operator()(void* ptr) const { UncheckedFree(ptr); }
 };
 
-#if BUILDFLAG(IS_WIN)
-// As above, but allocates/frees an aligned region of memory.
-[[nodiscard]] BASE_EXPORT bool UncheckedAlignedAlloc(size_t size,
-                                                     size_t alignment,
-                                                     void** result);
-BASE_EXPORT void UncheckedAlignedFree(void* ptr);
-#endif  // BUILDFLAG(IS_WIN)
-
 }  // namespace base
 
 #endif  // BASE_PROCESS_MEMORY_H_
diff --git a/base/process/memory_unittest.cc b/base/process/memory_unittest.cc
index a2222b8716411..403521f711baa 100644
--- a/base/process/memory_unittest.cc
+++ b/base/process/memory_unittest.cc
@@ -715,23 +715,6 @@ TEST_F(OutOfMemoryHandledTest, UncheckedCalloc) {
   EXPECT_TRUE(ptr == nullptr);
 }
 
-#if BUILDFLAG(IS_WIN)
-TEST_F(OutOfMemoryHandledTest, UncheckedAlignedAlloc) {
-  static constexpr size_t kAlignment = 32;
-  void* ptr;
-  EXPECT_TRUE(base::UncheckedAlignedAlloc(kSafeMallocSize, kAlignment, &ptr));
-  EXPECT_TRUE(ptr != nullptr);
-  EXPECT_TRUE(base::IsAligned(ptr, 32));
-  base::UncheckedAlignedFree(ptr);
-
-  // test_size_ is too big for the aligned case. Scale it back a bit.
-  const size_t test_size =
-      std::numeric_limits<std::ptrdiff_t>::max() - 3 * base::GetPageSize();
-  EXPECT_FALSE(base::UncheckedAlignedAlloc(test_size, kAlignment, &ptr));
-  EXPECT_TRUE(ptr == nullptr);
-}
-#endif  // BUILDFLAG(IS_WIN)
-
 #endif  // BUILDFLAG(IS_ANDROID)
 #endif  // !BUILDFLAG(IS_OPENBSD) && PA_BUILDFLAG(USE_ALLOCATOR_SHIM) &&
         // !defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
diff --git a/base/process/memory_win.cc b/base/process/memory_win.cc
index 06ad566d4e60d..2730c7d7d9443 100644
--- a/base/process/memory_win.cc
+++ b/base/process/memory_win.cc
@@ -72,24 +72,4 @@ void UncheckedFree(void* ptr) {
 #endif  // PA_BUILDFLAG(USE_ALLOCATOR_SHIM)
 }
 
-bool UncheckedAlignedAlloc(size_t size, size_t alignment, void** result) {
-#if PA_BUILDFLAG(USE_ALLOCATOR_SHIM)
-  // Reach PartitionAlloc's allocator_shim::internal::AlignedAllocUnchecked by
-  // way of the shims when available.
-  *result = allocator_shim::UncheckedAlignedAlloc(size, alignment);
-#else
-  // Fall-back to the UCRT's _aligned_malloc otherwise.
-  *result = _aligned_malloc(size, alignment);
-#endif  // PA_BUILDFLAG(USE_ALLOCATOR_SHIM)
-  return *result != NULL;
-}
-
-void UncheckedAlignedFree(void* ptr) {
-#if PA_BUILDFLAG(USE_ALLOCATOR_SHIM)
-  allocator_shim::UncheckedAlignedFree(ptr);
-#else
-  _aligned_free(ptr);
-#endif  // PA_BUILDFLAG(USE_ALLOCATOR_SHIM)
-}
-
 }  // namespace base
diff --git a/chrome/installer/util/BUILD.gn b/chrome/installer/util/BUILD.gn
index fce0a3a5c2771..421d9eb624e64 100644
--- a/chrome/installer/util/BUILD.gn
+++ b/chrome/installer/util/BUILD.gn
@@ -16,8 +16,6 @@ if (is_win) {
       "lzma_util.h",
       "self_cleaning_temp_dir.cc",
       "self_cleaning_temp_dir.h",
-      "unbuffered_file_writer.cc",
-      "unbuffered_file_writer.h",
     ]
     deps = [ "//third_party/lzma_sdk/google:seven_zip_reader" ]
     public_deps = [
@@ -345,7 +343,6 @@ if (is_win) {
       "self_cleaning_temp_dir_unittest.cc",
       "set_reg_value_work_item_unittest.cc",
       "shell_util_unittest.cc",
-      "unbuffered_file_writer_unittest.cc",
       "work_item_list_unittest.cc",
       "work_item_mocks.cc",
       "work_item_mocks.h",
diff --git a/chrome/installer/util/lzma_util.cc b/chrome/installer/util/lzma_util.cc
index 0a2ab5373fa8d..f53810a95f908 100644
--- a/chrome/installer/util/lzma_util.cc
+++ b/chrome/installer/util/lzma_util.cc
@@ -14,16 +14,12 @@
 #include <ntstatus.h>
 #include <stddef.h>
 
-#include <memory>
 #include <set>
-#include <utility>
 
-#include "base/containers/span.h"
 #include "base/files/file_util.h"
+#include "base/files/memory_mapped_file.h"
 #include "base/logging.h"
 #include "base/memory/raw_ptr.h"
-#include "base/types/expected_macros.h"
-#include "chrome/installer/util/unbuffered_file_writer.h"
 #include "third_party/lzma_sdk/google/seven_zip_reader.h"
 
 namespace {
@@ -56,10 +52,8 @@ class SevenZipDelegateImpl : public seven_zip::Delegate {
 
   std::set<base::FilePath> directories_created_;
   std::optional<DWORD> error_code_;
-
-  // The file to which the current entry will be written.
-  std::optional<installer::UnbufferedFileWriter> current_file_;
-
+  base::File current_file_;
+  std::optional<base::MemoryMappedFile> mapped_file_;
   UnPackStatus unpack_error_ = UNPACK_NO_ERROR;
 };
 
@@ -151,18 +145,39 @@ bool SevenZipDelegateImpl::OnEntry(const seven_zip::EntryInfo& entry,
 
   CreateDirectory(file_path.DirName());
 
-  ASSIGN_OR_RETURN(
-      current_file_,
-      installer::UnbufferedFileWriter::Create(file_path, entry.file_size),
-      [this](DWORD error) {
-        error_code_ = error;
-        PLOG(ERROR) << "Invalid file";
-        unpack_error_ = UNPACK_CREATE_FILE_ERROR;
-        return false;
-      });
+  current_file_ =
+      base::File(file_path, base::File::FLAG_CREATE_ALWAYS |
+                                base::File::FLAG_READ | base::File::FLAG_WRITE |
+                                base::File::FLAG_WIN_EXCLUSIVE_READ |
+                                base::File::FLAG_WIN_EXCLUSIVE_WRITE |
+                                base::File::FLAG_CAN_DELETE_ON_CLOSE |
+                                base::File::FLAG_WIN_SHARE_DELETE);
+  if (!current_file_.IsValid()) {
+    PLOG(ERROR) << "Invalid file";
+    error_code_ = ::GetLastError();
+    unpack_error_ = UNPACK_CREATE_FILE_ERROR;
+    return false;
+  }
 
-  // Return a view into the writer's output buffer.
-  output = current_file_->write_buffer().first(entry.file_size);
+  // The target file is deleted by default unless extracting succeeds.
+  current_file_.DeleteOnClose(true);
+
+  if (entry.file_size > 0) {
+    mapped_file_.emplace();
+    bool mapped_file_ok = mapped_file_->Initialize(
+        current_file_.Duplicate(), {0, static_cast<size_t>(entry.file_size)},
+        base::MemoryMappedFile::READ_WRITE_EXTEND);
+    if (!mapped_file_ok) {
+      PLOG(ERROR) << "Can't map file to memory";
+      error_code_ = ::GetLastError();
+      unpack_error_ = UNPACK_ALLOCATE_ERROR;
+      return false;
+    }
+
+    output = base::span<uint8_t>(mapped_file_->data(), mapped_file_->length());
+  } else {
+    output = base::span<uint8_t>();
+  }
 
   // Clear the last error code before the entry is extracted to reduce the
   // likelihood that it will hold an unrelated error code in case extraction
@@ -175,8 +190,8 @@ bool SevenZipDelegateImpl::OnEntry(const seven_zip::EntryInfo& entry,
 bool SevenZipDelegateImpl::EntryDone(seven_zip::Result result,
                                      const seven_zip::EntryInfo& entry) {
   // Take ownership of `current_file_` so that it is always closed when this
-  // function exits
-  auto current_file = *std::move(current_file_);
+  // function exits.
+  base::File current_file = std::move(current_file_);
 
   if (result != seven_zip::Result::kSuccess) {
     auto error_code = ::GetLastError();
@@ -209,26 +224,35 @@ bool SevenZipDelegateImpl::EntryDone(seven_zip::Result result,
         break;
     }
 
+    mapped_file_.reset();
     return false;
   }
 
-  // The writer's buffer now holds the entire entry.
-  current_file.Advance(entry.file_size);
-
-  // Commit the file, which sizes it appropriately and sets the last-modified
-  // time.
-  // TODO(crbug.com/394631579): Monitor UnbufferedFileWriter error metrics to
-  // see if/what errors are happening in the field. Consider using a retry loop
-  // here based on the data.
-  RETURN_IF_ERROR(current_file.Commit(entry.last_modified_time.is_null()
-                                          ? std::nullopt
-                                          : std::optional<base::Time>(
-                                                entry.last_modified_time)),
-                  [this](DWORD error) {
-                    error_code_ = error;
-                    unpack_error_ = UNPACK_EXTRACT_ERROR;
-                    return false;
-                  });
+  if (mapped_file_) {
+    // Modified pages are not written to disk until they're evicted from the
+    // working set. Explicitly kick off the write to disk now
+    // (asynchronously) to improve the odds that the file's contents are
+    // on-disk when another process (such as chrome.exe) would like to use
+    // them.
+    ::FlushViewOfFile(mapped_file_->data(), 0);
+    // Unmap the target file from the process's address space.
+    mapped_file_.reset();
+    // Flush to avoid odd behavior, such as the bug in Windows 7 through
+    // Windows 10 1809 for PE files described in
+    // https://randomascii.wordpress.com/2018/02/25/compiler-bug-linker-bug-windows-kernel-bug/.
+    // We've also observed oddly empty files on other Windows versions, so
+    // this is unconditional.
+    current_file.Flush();
+  }
+
+  // On success, `current_file` is kept.
+  current_file.DeleteOnClose(false);
+
+  if (!entry.last_modified_time.is_null()) {
+    FILETIME filetime = entry.last_modified_time.ToFileTime();
+    // Make a best-effort attempt to set the file time.
+    SetFileTime(current_file.GetPlatformFile(), nullptr, nullptr, &filetime);
+  }
 
   return true;
 }
diff --git a/chrome/installer/util/lzma_util.h b/chrome/installer/util/lzma_util.h
index 7d797887e412b..6cd4296d65d55 100644
--- a/chrome/installer/util/lzma_util.h
+++ b/chrome/installer/util/lzma_util.h
@@ -32,11 +32,10 @@ enum UnPackStatus {
   UNPACK_STATUS_COUNT,
 };
 
-// Unpacks the contents of `archive` into `output_dir`. `output_file`, if not
+// Unpacks the contents of |archive| into |output_dir|. |output_file|, if not
 // null, is populated with the name of the last (or only) member extracted from
 // the archive. Returns UNPACK_NO_ERROR on success. Otherwise, returns a status
-// value indicating the operation that failed. Existing files in `output_dir`
-// are not overwritten.
+// value indicating the operation that failed.
 UnPackStatus UnPackArchive(const base::FilePath& archive,
                            const base::FilePath& output_dir,
                            base::FilePath* output_file);
diff --git a/chrome/installer/util/unbuffered_file_writer.cc b/chrome/installer/util/unbuffered_file_writer.cc
deleted file mode 100644
index 9542b0521db74..0000000000000
--- a/chrome/installer/util/unbuffered_file_writer.cc
+++ /dev/null
@@ -1,336 +0,0 @@
-// Copyright 2025 The Chromium Authors
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/installer/util/unbuffered_file_writer.h"
-
-#include <windows.h>
-
-#include <algorithm>
-#include <limits>
-#include <utility>
-
-#include "base/check.h"
-#include "base/check_op.h"
-#include "base/compiler_specific.h"
-#include "base/files/file_path.h"
-#include "base/logging.h"
-#include "base/metrics/histogram_functions.h"
-#include "base/numerics/checked_math.h"
-#include "base/process/memory.h"
-#include "base/types/expected_macros.h"
-
-namespace installer {
-
-namespace {
-
-// These values are persisted to logs. Entries should not be renumbered and
-// numeric values should never be reused.
-enum class Operation {
-  kCreate,
-  kGetInfo,
-  kAllocate,
-  kWrite,
-  kSetInfo,
-  kClearDelete,
-  kMaxValue = kClearDelete,
-};
-
-std::string_view ToString(Operation operation) {
-  switch (operation) {
-    case Operation::kCreate:
-      return "Create";
-    case Operation::kGetInfo:
-      return "GetInfo";
-    case Operation::kAllocate:
-      return "Allocate";
-    case Operation::kWrite:
-      return "Write";
-    case Operation::kSetInfo:
-      return "SetInfo";
-    case Operation::kClearDelete:
-      return "ClearDelete";
-  }
-}
-
-void RecordFailure(Operation operation, DWORD error_code) {
-  base::UmaHistogramSparse(base::StrCat({"Setup.Install.UnbufferedFileWriter.",
-                                         ToString(operation), ".Error"}),
-                           static_cast<int>(error_code));
-}
-
-// Returns `value` rounded up to be an integral number of `chunk_size` chunks.
-size_t RoundUp(size_t value, size_t chunk_size) {
-  if (auto remainder = base::CheckMod(value, chunk_size);
-      remainder.ValueOrDie() == 0) {
-    return value;
-  } else {
-    return base::CheckAdd(value,
-                          base::CheckSub(chunk_size, std::move(remainder)))
-        .ValueOrDie();
-  }
-}
-
-// Returns `value` rounded down to be an integral number of `chunk_size` chunks.
-size_t RoundDown(size_t value, size_t chunk_size) {
-  return base::CheckSub(value, base::CheckMod(value, chunk_size)).ValueOrDie();
-}
-
-// A deleter function that frees memory allocated via VirtualAlloc.
-void VirtualFreeDeleteFn(void* ptr) {
-  PCHECK(::VirtualFree(ptr, /*dwSize=*/0, MEM_RELEASE));
-}
-
-// Returns an empty AlignedBuffer.
-base::HeapArray<uint8_t, void (*)(void*)> MakeEmptyBuffer() {
-  // SAFETY: No allocation; deleter will never be called.
-  return UNSAFE_BUFFERS(
-      base::HeapArray<uint8_t, void (*)(void*)>::FromOwningPointer(nullptr, 0,
-                                                                   nullptr));
-}
-
-}  // namespace
-
-// static
-base::expected<UnbufferedFileWriter, DWORD> UnbufferedFileWriter::Create(
-    const base::FilePath& path,
-    int64_t buffer_size) {
-  CHECK(!path.empty());
-  CHECK_GE(buffer_size, 0LL);
-
-  base::File file(::CreateFileW(path.value().c_str(),
-                                /*dwDesiredAccess=*/GENERIC_WRITE | DELETE,
-                                /*dwShareMode=*/FILE_SHARE_DELETE,
-                                /*lpSecurityAttributes=*/nullptr,
-                                /*dwCreationDisposition=*/CREATE_NEW,
-                                /*dwFlagsAndAttributes=*/FILE_ATTRIBUTE_NORMAL |
-                                    FILE_FLAG_NO_BUFFERING |
-                                    FILE_FLAG_WRITE_THROUGH,
-                                /*hTemplateFile=*/nullptr));
-
-  if (!file.IsValid()) {
-    auto error = ::GetLastError();
-    PLOG(ERROR) << "CreateFileW failed";
-    RecordFailure(Operation::kCreate, error);
-    return base::unexpected(error);
-  }
-
-  // The file is deleted unless committed.
-  file.DeleteOnClose(true);
-
-  // Get the physical sector size for the device backing the file.
-  FILE_STORAGE_INFO storage = {};
-  if (!::GetFileInformationByHandleEx(file.GetPlatformFile(), FileStorageInfo,
-                                      &storage, sizeof(storage))) {
-    auto error = ::GetLastError();
-    PLOG(ERROR) << "GetFileInformationByHandleEx failed";
-    RecordFailure(Operation::kGetInfo, error);
-    return base::unexpected(error);
-  }
-  const DWORD physical_sector_size = storage.PhysicalBytesPerSectorForAtomicity;
-
-  // Make the buffer size an even multiple of the physical sector size.
-  buffer_size = buffer_size ? RoundUp(buffer_size, physical_sector_size)
-                            : physical_sector_size;
-
-  // Allocate a properly-aligned write buffer.
-  AlignedBuffer buffer = AllocateAligned(buffer_size, physical_sector_size);
-  if (buffer_size && buffer.empty()) {
-    auto error = ::GetLastError();
-    PLOG(ERROR) << "Allocation failed";
-    RecordFailure(Operation::kAllocate, error);
-    return base::unexpected(error);
-  }
-
-  return UnbufferedFileWriter(std::move(file), physical_sector_size,
-                              std::move(buffer));
-}
-
-UnbufferedFileWriter::UnbufferedFileWriter(UnbufferedFileWriter&&) = default;
-UnbufferedFileWriter& UnbufferedFileWriter::operator=(UnbufferedFileWriter&&) =
-    default;
-
-UnbufferedFileWriter::~UnbufferedFileWriter() = default;
-
-void UnbufferedFileWriter::Advance(size_t offset) {
-  CHECK_LE(offset, buffer_.size() - data_size_);
-  data_size_ += offset;
-}
-
-base::expected<void, DWORD> UnbufferedFileWriter::Checkpoint() {
-  CHECK(file_.IsValid());  // Use-after-move or after Commit.
-
-  RETURN_IF_ERROR(Write(/*include_final_incomplete_sector=*/false));
-  return base::ok();
-}
-
-base::expected<void, DWORD> UnbufferedFileWriter::Commit(
-    std::optional<base::Time> last_modified_time) {
-  CHECK(file_.IsValid());  // Use-after-move or after Commit.
-
-  ASSIGN_OR_RETURN(int64_t file_size,
-                   Write(/*include_final_incomplete_sector=*/true));
-
-  if ((file_size % physical_sector_size_) != 0) {
-    // Truncate down to the actual size.
-    FILE_END_OF_FILE_INFO information = {};
-    information.EndOfFile.QuadPart = file_size;
-    if (!::SetFileInformationByHandle(
-            file_.GetPlatformFile(),
-            /*FileInformationClass=*/FileEndOfFileInfo,
-            /*lpFileInformation=*/&information,
-            /*dwBufferSize=*/sizeof(information))) {
-      auto error = ::GetLastError();
-      PLOG(ERROR) << "SetFileInformationByHandle failed";
-      RecordFailure(Operation::kSetInfo, error);
-      return base::unexpected(error);
-    }
-  }
-
-  // The file has been written and shrunk down to the correct size. Clear the
-  // delete-on-close bit so that it is retained when closed below.
-  if (!file_.DeleteOnClose(false)) {
-    auto error = ::GetLastError();
-    PLOG(ERROR) << "DeleteOnClose failed";
-    RecordFailure(Operation::kClearDelete, error);
-    return base::unexpected(error);
-  }
-
-  if (last_modified_time) {
-    // Make a best-effort attempt to set the file time before closing the file.
-    FILETIME filetime = last_modified_time->ToFileTime();
-    ::SetFileTime(file_.GetPlatformFile(), /*lpCreationTime=*/nullptr,
-                  /*lpLastAccessTime=*/nullptr, /*lpLastWriteTime=*/&filetime);
-  }
-
-  // Close the file now that everything has succeeded.
-  file_.Close();
-
-  return base::ok();
-}
-
-UnbufferedFileWriter::UnbufferedFileWriter(base::File file,
-                                           DWORD physical_sector_size,
-                                           AlignedBuffer buffer)
-    : file_(std::move(file)),
-      physical_sector_size_(physical_sector_size),
-      buffer_(std::move(buffer)) {}
-
-base::expected<int64_t, DWORD> UnbufferedFileWriter::Write(
-    bool include_final_incomplete_sector) {
-  if (!buffer_.size()) {
-    // A previous call to Write(true) has succeeded. One may not call
-    // Write(false) again in this case.
-    CHECK(include_final_incomplete_sector);
-    return base::ok(file_position_);
-  }
-
-  // The number of bytes available to write.
-  const size_t unwritten_size = data_size_ - written_size_;
-
-  // The number of bytes available to write including padding to bring it up to
-  // an integral number of physical sectors.
-  const size_t unwritten_size_padded =
-      RoundUp(unwritten_size, physical_sector_size_);
-
-  // The number of bytes for this write; including or not including the padding
-  // to fill a complete sector at the end.
-  const size_t to_write_size =
-      include_final_incomplete_sector
-          ? unwritten_size_padded
-          : RoundDown(unwritten_size, physical_sector_size_);
-
-  // The aligned data to write in this call and the unwritten data at the end of
-  // the buffer that will not be written if `include_final_incomplete_sector` is
-  // false.
-  auto [to_write, after_write] =
-      buffer_.subspan(written_size_, unwritten_size_padded)
-          .split_at(include_final_incomplete_sector
-                        ? unwritten_size_padded
-                        : unwritten_size_padded -
-                              (unwritten_size - to_write_size));
-
-  // The data in the incomplete final sector that will not be written.
-  if (include_final_incomplete_sector) {
-    // Zero-pad the end of the buffer to the physical sector boundary.
-    std::ranges::fill(to_write.last(unwritten_size_padded - unwritten_size), 0);
-  }
-
-  // Write the data to disk in chunks no larger than 2^31-1 bytes (the max
-  // supported by base::File::Write).
-  const size_t max_write_size =
-      RoundDown(static_cast<size_t>(std::numeric_limits<int>::max()),
-                physical_sector_size_);
-  while (!to_write.empty()) {
-    size_t this_write_size = std::min(max_write_size, to_write.size());
-    base::span<uint8_t> this_write;
-    std::tie(this_write, to_write) = to_write.split_at(this_write_size);
-    if (file_.Write(file_position_, this_write) != this_write_size) {
-      auto error = ::GetLastError();
-      PLOG(ERROR) << "Write failed";
-      RecordFailure(Operation::kWrite, error);
-      return base::unexpected(error);
-    }
-    written_size_ += this_write_size;
-    file_position_ += this_write_size;
-  }
-
-  // No written data remains in the buffer.
-  written_size_ = 0;
-
-  if (include_final_incomplete_sector) {
-    // All data has been written. Release the buffer.
-    buffer_ = MakeEmptyBuffer();
-    data_size_ = 0;
-
-    // Subtract the padding from the file position so that it now represents
-    // the desired size of the file.
-    file_position_ -= (unwritten_size_padded - unwritten_size);
-  } else {
-    // `after_write` holds data beyond the last complete sector that was
-    // written. Shift this to the front of the buffer for the next round of
-    // writes.
-    buffer_.copy_prefix_from(after_write);
-    data_size_ = after_write.size();
-  }
-
-  return base::ok(file_position_);
-}
-
-// static
-UnbufferedFileWriter::AlignedBuffer UnbufferedFileWriter::AllocateAligned(
-    size_t size,
-    DWORD alignment) {
-  // Attempt using the normal allocator. In non-debug builds, PartitionAlloc
-  // will make sensible choices to do a mapped-allocation for large sizes.
-  uint8_t* mem = nullptr;
-  if (base::UncheckedAlignedAlloc(size, alignment,
-                                  reinterpret_cast<void**>(&mem))) {
-    // SAFETY: UncheckedAlignedAlloc allocates at least `size` bytes.
-    return UNSAFE_BUFFERS(AlignedBuffer::FromOwningPointer(
-        mem, size, &base::UncheckedAlignedFree));
-  }
-
-  // If the normal allocator failed, try making a pagefile-backed allocation.
-  // This is necessary for very large allocations, as PartitionAlloc rejects
-  // them outright.
-  static const DWORD kGranularity = [] {
-    SYSTEM_INFO system_info = {};
-    ::GetSystemInfo(&system_info);
-    return system_info.dwAllocationGranularity;
-  }();
-
-  // Add support for devices that have physical sector sizes greater than the
-  // allocation granularity if needed (doubtful -- famous last words!).
-  CHECK_EQ(kGranularity % alignment, 0U);
-  mem = static_cast<uint8_t*>(::VirtualAlloc(
-      /*lpAddress=*/0, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
-  if (mem) {
-    // SAFETY: VirtualAlloc allocates at least `size` bytes.
-    return UNSAFE_BUFFERS(
-        AlignedBuffer::FromOwningPointer(mem, size, &VirtualFreeDeleteFn));
-  }
-  return MakeEmptyBuffer();
-}
-
-}  // namespace installer
diff --git a/chrome/installer/util/unbuffered_file_writer.h b/chrome/installer/util/unbuffered_file_writer.h
deleted file mode 100644
index d8a951b1b073a..0000000000000
--- a/chrome/installer/util/unbuffered_file_writer.h
+++ /dev/null
@@ -1,178 +0,0 @@
-// Copyright 2025 The Chromium Authors
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CHROME_INSTALLER_UTIL_UNBUFFERED_FILE_WRITER_H_
-#define CHROME_INSTALLER_UTIL_UNBUFFERED_FILE_WRITER_H_
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include <optional>
-
-#include "base/containers/heap_array.h"
-#include "base/containers/span.h"
-#include "base/files/file.h"
-#include "base/time/time.h"
-#include "base/types/expected.h"
-#include "base/win/windows_types.h"
-
-namespace base {
-class FilePath;
-}
-
-namespace installer {
-
-// Writes a file to disk using direct, unbuffered I/O.
-//
-// Considerations when using:
-//
-// A single allocation is made for the write buffer. An instance will try very
-// hard to satisfy this request and will fail gracefully rather than crash if it
-// can't be satisfied.
-//
-// Data written to disk does not go through the system cache. This is especially
-// suitable for background writes that should not interfere with other uses of
-// the system.
-//
-// Explicit flushes are not needed. Once `Commit` succeeds, the data has reached
-// the disk and the disk has been told to put it to the physical media. There is
-// no guarantee that the disk will obey this, but the same can be said of
-// FlushFileBuffers.
-//
-// Checkpoint() and Commit() may fail with media errors. Both are safe to be
-// called repeatedly on error to retry. Note that no experimentation has yet
-// been done in this area to determine whether such retries will be fruitful or
-// not.
-//
-// Destruction of an instance without a successful Commit() will result in
-// deletion of the file.
-//
-// See
-// https://learn.microsoft.com/windows/win32/FileIO/file-buffering and
-// https://learn.microsoft.com/windows/win32/api/FileAPI/nf-fileapi-createfilea#caching-behavior
-// for details about unbuffered, direct I/O on Windows.
-//
-// Sample usage with a single small write:
-//
-//   // Create a writer.
-//   ASSIGN_OR_RETURN(auto writer, UnbufferedFileWriter::Create(path));
-//   // Put some data in its write buffer.
-//   size_t data_size = PutDataInBuffer(writer.write_buffer());
-//   // Tell the writer how much of the buffer has been populated.
-//   writer.Advance(data_size);
-//   // Commit all data to disk.
-//   RETURN_IF_ERROR(writer.Commit());
-//
-// Advanced usage w/ Checkpoint:
-//
-//   // Create a writer with a buffer to hold at least 10KiB.
-//   ASSIGN_OR_RETURN(auto writer,
-//                    UnbufferedFileWriter::Create(path, 10 * 1024));
-//   // Emit and commit until all data has been written.
-//   while (HaveDataToWrite()) {
-//     size_t data_size = PutDataInBuffer(writer.write_buffer());
-//     // Tell the writer how much of the buffer has been populated.
-//     writer.Advance(data_size);
-//     // Checkpoint to move data from the buffer to disk.
-//     RETURN_IF_ERROR(writer.Checkpoint());
-//   }
-//   // Commit all data to disk.
-//   RETURN_IF_ERROR(writer.Commit());
-//
-class UnbufferedFileWriter {
- public:
-  // Creates and opens the file at `path`. `buffer_size`, if specified,
-  // indicates the desired size of the buffer to hold data between checkpoints.
-  // If none is specified, the buffer will be the size of a single physical
-  // sector. The file will be deleted if `Commit()` is never called (including
-  // in case of process termination). Returns a Windows system error code in
-  // case of failure.
-  static base::expected<UnbufferedFileWriter, DWORD> Create(
-      const base::FilePath& path,
-      int64_t buffer_size = 0);
-
-  UnbufferedFileWriter(const UnbufferedFileWriter&) = delete;
-  UnbufferedFileWriter& operator=(const UnbufferedFileWriter&) = delete;
-  UnbufferedFileWriter(UnbufferedFileWriter&&);
-  UnbufferedFileWriter& operator=(UnbufferedFileWriter&&);
-  ~UnbufferedFileWriter();
-
-  // A view into a buffer into which the caller must place data to write to the
-  // file. At creation, this is at least as big as the `buffer_size` provided at
-  // construction. If no `buffer_size` was provided, this will be precisely the
-  // size of one physical sector of the disk to which the file is being written.
-  // `Advance()` must be called before `Checkpoint()` or `Commit()` to indicate
-  // how much of this buffer has ben populated with data. Any other use of the
-  // instance invalidates any previously-obtained view to the buffer.
-  base::span<uint8_t> write_buffer() { return buffer_.subspan(data_size_); }
-
-  // Indicates that the first `offset` bytes of `write_buffer()` have been
-  // populated and are ready to be written. The next call to `write_buffer()`
-  // will return a correspondingly smaller view into the buffer. The next call
-  // to `Checkpoint()` will write as many integral physical sectors from the
-  // buffer to disk as possible. Note well: if `buffer_size` was not specified
-  // at construction or is smaller than one physical sector, `Checkpoint()` will
-  // have no effect. Such data will be written to disk only on `Commit()`.
-  void Advance(size_t offset);
-
-  // Writes as many complete physical sectors from the buffer to disk as
-  // possible. Does nothing if `Advance()` has not been called to move forward
-  // at least one full sector. Returns a Windows system error code in case of
-  // failure. May be called repeatedly on failure to retry.
-  base::expected<void, DWORD> Checkpoint();
-
-  // Commits the file to disk; optionally setting the file's last-modified time.
-  // Returns a Windows system error code in case of failure. May be called
-  // repeatedly on failure to retry. The file is closed on success, in which
-  // case the instance may not be used further.
-  base::expected<void, DWORD> Commit(
-      std::optional<base::Time> last_modified_time);
-
- private:
-  using AlignedBuffer = base::HeapArray<uint8_t, void (*)(void*)>;
-
-  UnbufferedFileWriter(base::File file,
-                       DWORD physical_sector_size,
-                       AlignedBuffer buffer);
-
-  // Writes complete sectors from the contents of `buffer_` starting from
-  // `written_size_` to the file starting at `file_position_`. If
-  // `include_final_incomplete_sector` is true, the buffer's full contents up
-  // through `data_size_` are written after padding with zeros produces a
-  // complete physical sector at the end of the file. Otherwise, the data for
-  // the final incomplete sector is moved to the front of `buffer_` to be
-  // included in a subsequent write of at least one full sector. Returns the
-  // size of the file, omitting any zero padding added for the final write.
-  // Returns a Windows system error code in case of failure. May be called
-  // repeatedly on failure to retry.
-  base::expected<int64_t, DWORD> Write(bool include_final_incomplete_sector);
-
-  // Returns an uninitialized buffer of at least `size` bytes aligned as
-  // requested, or an empty buffer on failure to allocate.
-  static AlignedBuffer AllocateAligned(size_t size, DWORD alignment);
-
-  // The file being written; valid from construction through successful Commit.
-  base::File file_;
-
-  // The size of a physical sector of the disk on which `file_` resides.
-  DWORD physical_sector_size_;
-
-  // A buffer aligned to physical_sector_size_.
-  AlignedBuffer buffer_;
-
-  // The amount of data in `buffer_` that has not been written to disk.
-  size_t data_size_ = 0;
-
-  // The amount of data in `buffer_` that has been written to disk. This is
-  // always strictly less than `data_size_` when non-zero. It is only non-zero
-  // after a failed call to `Checkpoint()`.
-  size_t written_size_ = 0;
-
-  // The offset into the file where the last write completed.
-  int64_t file_position_ = 0;
-};
-
-}  // namespace installer
-
-#endif  // CHROME_INSTALLER_UTIL_UNBUFFERED_FILE_WRITER_H_
diff --git a/chrome/installer/util/unbuffered_file_writer_unittest.cc b/chrome/installer/util/unbuffered_file_writer_unittest.cc
deleted file mode 100644
index 60eed14424fc8..0000000000000
--- a/chrome/installer/util/unbuffered_file_writer_unittest.cc
+++ /dev/null
@@ -1,156 +0,0 @@
-// Copyright 2025 The Chromium Authors
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "chrome/installer/util/unbuffered_file_writer.h"
-
-#include <windows.h>
-
-#include <algorithm>
-#include <optional>
-#include <string>
-#include <string_view>
-
-#include "base/byte_count.h"
-#include "base/containers/heap_array.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/files/scoped_temp_dir.h"
-#include "base/logging.h"
-#include "base/test/gmock_expected_support.h"
-#include "base/test/metrics/histogram_tester.h"
-#include "testing/gmock/include/gmock/gmock.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace installer {
-
-namespace {
-
-using base::test::ErrorIs;
-using base::test::HasValue;
-using base::test::ValueIs;
-
-class UnbufferedFileWriterTest : public testing::Test {
- protected:
-  void SetUp() override { ASSERT_TRUE(temp_dir_.CreateUniqueTempDir()); }
-
-  const base::FilePath temp_dir() const { return temp_dir_.GetPath(); }
-
- private:
-  base::ScopedTempDir temp_dir_;
-};
-
-// Tests that a file with no contents works.
-TEST_F(UnbufferedFileWriterTest, EmptyFile) {
-  base::FilePath path = temp_dir().Append(FILE_PATH_LITERAL("empty"));
-  ASSERT_OK_AND_ASSIGN(UnbufferedFileWriter writer,
-                       UnbufferedFileWriter::Create(path));
-  ASSERT_THAT(writer.Commit(std::nullopt), HasValue());
-  ASSERT_THAT(base::GetFileSize(path), testing::Optional(0LL));
-}
-
-// Tests a small file; smaller than a physical sector.
-TEST_F(UnbufferedFileWriterTest, SmallFile) {
-  base::FilePath path = temp_dir().Append(FILE_PATH_LITERAL("empty"));
-  std::string_view contents = "hi mom";
-  ASSERT_OK_AND_ASSIGN(UnbufferedFileWriter writer,
-                       UnbufferedFileWriter::Create(path));
-  writer.write_buffer().copy_prefix_from(base::as_byte_span(contents));
-  writer.Advance(contents.size());
-  ASSERT_THAT(writer.Commit(std::nullopt), HasValue());
-  ASSERT_THAT(base::GetFileSize(path), testing::Optional(contents.size()));
-  std::string result;
-  ASSERT_PRED2(base::ReadFileToString, path, &result);
-  ASSERT_EQ(contents, result);
-}
-
-// Tests writing to a file in multiple small chunks.
-TEST_F(UnbufferedFileWriterTest, CommitChunks) {
-  base::FilePath path = temp_dir().Append(FILE_PATH_LITERAL("chunked"));
-  ASSERT_OK_AND_ASSIGN(UnbufferedFileWriter writer,
-                       UnbufferedFileWriter::Create(path));
-
-  // The write buffer will be the size of one sector.
-  const size_t sector_size = writer.write_buffer().size();
-  // Alignment guarantees that this will hold.
-  const size_t number_count = sector_size / sizeof(uint64_t);
-  ASSERT_EQ(number_count * sizeof(uint64_t), sector_size);
-
-  // Write four sectors' worth of increasing integers.
-  uint64_t index = 0;
-  for (int i = 0; i < 4; ++i) {
-    base::span write_buffer = writer.write_buffer();
-    ASSERT_EQ(write_buffer.size(), sector_size);
-    // SAFETY: The write buffer is large enough to hold `number_count` numbers.
-    std::ranges::generate(
-        UNSAFE_BUFFERS(base::span(
-            reinterpret_cast<uint64_t*>(write_buffer.data()), number_count)),
-        [&index] { return index++; });
-    writer.Advance(sector_size);
-    // The write buffer is now full.
-    ASSERT_EQ(writer.write_buffer().size(), 0U);
-    // Send it to the disk.
-    ASSERT_THAT(writer.Checkpoint(), HasValue());
-  }
-  ASSERT_THAT(writer.Commit(std::nullopt), HasValue());
-  ASSERT_THAT(base::GetFileSize(path), testing::Optional(4 * sector_size));
-  std::string result;
-  ASSERT_PRED2(base::ReadFileToString, path, &result);
-  ASSERT_EQ(result.size(), 4 * sector_size);
-  // Confirm that the data is all there, and all in the correct order.
-  index = 0;
-  ASSERT_TRUE(std::ranges::all_of(
-      // SAFETY: The string buffer is large enough to hold the numbers.
-      UNSAFE_BUFFERS(base::span(reinterpret_cast<uint64_t*>(
-                                    base::as_writable_byte_span(result).data()),
-                                result.size() / sizeof(uint64_t)),
-                     [&index](auto& slot) { return slot == index++; })));
-}
-
-// Tests writing a very large file.
-TEST_F(UnbufferedFileWriterTest, VeryLarge) {
-  static constexpr auto kFileSize = base::GiB(2.333);
-  base::FilePath path = temp_dir().Append(FILE_PATH_LITERAL("very_large"));
-  ASSERT_OK_AND_ASSIGN(
-      UnbufferedFileWriter writer,
-      UnbufferedFileWriter::Create(path, kFileSize.InBytesUnsigned()));
-  writer.Advance(kFileSize.InBytesUnsigned());
-  ASSERT_THAT(writer.Commit(std::nullopt), HasValue());
-  ASSERT_THAT(base::GetFileSize(path), testing::Optional(kFileSize.InBytes()));
-}
-
-// Tests that creation fails if the target file already exists.
-TEST_F(UnbufferedFileWriterTest, FileExists) {
-  base::FilePath path = temp_dir().Append(FILE_PATH_LITERAL("exists"));
-  ASSERT_TRUE(base::WriteFile(path, std::string_view("hi mom")));
-  base::HistogramTester histogram_tester;
-  ASSERT_THAT(UnbufferedFileWriter::Create(path), ErrorIs(ERROR_FILE_EXISTS));
-  histogram_tester.ExpectUniqueSample(
-      "Setup.Install.UnbufferedFileWriter.Create.Error", ERROR_FILE_EXISTS, 1);
-}
-
-// Tests that the target file is deleted upon destruction of an instance without
-// commit.
-TEST_F(UnbufferedFileWriterTest, DeleteWithoutCommit) {
-  base::FilePath path = temp_dir().Append(FILE_PATH_LITERAL("file"));
-
-  WIN32_FILE_ATTRIBUTE_DATA data = {};
-  {
-    ASSERT_OK_AND_ASSIGN(UnbufferedFileWriter writer,
-                         UnbufferedFileWriter::Create(path));
-    // An attempt to check for the file will fail with ACCESS_DENIED because the
-    // file is marked for deletion.
-    ASSERT_FALSE(::GetFileAttributesEx(path.value().c_str(),
-                                       GetFileExInfoStandard, &data));
-    ASSERT_EQ(::GetLastError(), static_cast<DWORD>(ERROR_ACCESS_DENIED));
-  }
-  // Now that the file has been deleted, an attempt to get its attributes will
-  // fail with FILE_NOT_FOUND.
-  ASSERT_FALSE(::GetFileAttributesEx(path.value().c_str(),
-                                     GetFileExInfoStandard, &data));
-  ASSERT_EQ(::GetLastError(), static_cast<DWORD>(ERROR_FILE_NOT_FOUND));
-}
-
-}  // namespace
-
-}  // namespace installer
diff --git a/tools/metrics/histograms/metadata/installer/OWNERS b/tools/metrics/histograms/metadata/installer/OWNERS
deleted file mode 100644
index da6e75559f49c..0000000000000
--- a/tools/metrics/histograms/metadata/installer/OWNERS
+++ /dev/null
@@ -1,7 +0,0 @@
-per-file OWNERS=file://tools/metrics/histograms/metadata/METRIC_REVIEWER_OWNERS
-
-# Prefer sending CLs to the owners listed below.
-# Use chromium-metrics-reviews@google.com as a backup.
-grt@chromium.org
-tbrandston@google.com
-
