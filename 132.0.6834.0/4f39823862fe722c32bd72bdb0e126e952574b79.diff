diff --git a/base/threading/thread_local.h b/base/threading/thread_local.h
index a32e671bf7ff9..6c6c2c92443d5 100644
--- a/base/threading/thread_local.h
+++ b/base/threading/thread_local.h
@@ -5,6 +5,46 @@
 // WARNING: Thread local storage is a bit tricky to get right. Please make sure
 // that this is really the proper solution for what you're trying to achieve.
 // Don't prematurely optimize, most likely you can just use a Lock.
+//
+// These classes implement a wrapper around ThreadLocalStorage::Slot. On
+// construction, they will allocate a TLS slot, and free the TLS slot on
+// destruction. No memory management (creation or destruction) is handled. This
+// means for uses of ThreadLocalPointer, you must correctly manage the memory
+// yourself, these classes will not destroy the pointer for you. There are no
+// at-thread-exit actions taken by these classes.
+//
+// ThreadLocalPointer<Type> wraps a Type*. It performs no creation or
+// destruction, so memory management must be handled elsewhere. The first call
+// to Get() on a thread will return NULL. You can update the pointer with a call
+// to Set().
+//
+// ThreadLocalBoolean wraps a bool. It will default to false if it has never
+// been set otherwise with Set().
+//
+// Thread Safety: An instance of ThreadLocalStorage is completely thread safe
+// once it has been created. If you want to dynamically create an instance, you
+// must of course properly deal with safety and race conditions.
+//
+// In Android, the system TLS is limited.
+//
+// Example usage:
+//   // My class is logically attached to a single thread. We cache a pointer
+//   // on the thread it was created on, so we can implement current().
+//   MyClass::MyClass() {
+//     DCHECK(Singleton<ThreadLocalPointer<MyClass> >::get()->Get() == NULL);
+//     Singleton<ThreadLocalPointer<MyClass> >::get()->Set(this);
+//   }
+//
+//   MyClass::~MyClass() {
+//     DCHECK(Singleton<ThreadLocalPointer<MyClass> >::get()->Get() != NULL);
+//     Singleton<ThreadLocalPointer<MyClass> >::get()->Set(NULL);
+//   }
+//
+//   // Return the current MyClass associated with the calling thread, can be
+//   // NULL if there isn't a MyClass associated.
+//   MyClass* MyClass::current() {
+//     return Singleton<ThreadLocalPointer<MyClass> >::get()->Get();
+//   }
 
 #ifndef BASE_THREADING_THREAD_LOCAL_H_
 #define BASE_THREADING_THREAD_LOCAL_H_
@@ -18,13 +58,30 @@
 
 namespace base {
 
-// `thread_local` is only allowed for trivially-destructible types (see
-// //styleguide/c++/c++.md#thread_local-variables). This class provides
-// thread-scoped management of non-trivially-destructible types. Pointers handed
-// to it are owned and automatically deleted during their associated thread's
-// exit phase (or when replaced if Set() is invoked multiple times on the same
-// thread).
-//
+template <typename T>
+class ThreadLocalPointer {
+ public:
+  ThreadLocalPointer() = default;
+
+  ThreadLocalPointer(const ThreadLocalPointer&) = delete;
+  ThreadLocalPointer& operator=(const ThreadLocalPointer&) = delete;
+
+  ~ThreadLocalPointer() = default;
+
+  T* Get() const { return static_cast<T*>(slot_.Get()); }
+
+  void Set(T* ptr) {
+    slot_.Set(const_cast<void*>(static_cast<const void*>(ptr)));
+  }
+
+ private:
+  ThreadLocalStorage::Slot slot_;
+};
+
+// A ThreadLocalOwnedPointer<T> is like a ThreadLocalPointer<T> except that
+// pointers handed to it are owned and automatically deleted during their
+// associated thread's exit phase (or when replaced if Set() is invoked multiple
+// times on the same thread).
 // The ThreadLocalOwnedPointer instance itself can only be destroyed when no
 // threads, other than the one it is destroyed on, have remaining state set in
 // it. Typically this means that ThreadLocalOwnedPointer instances are held in
@@ -66,6 +123,23 @@ class ThreadLocalOwnedPointer {
 };
 #endif  // DCHECK_IS_ON()
 
+class ThreadLocalBoolean {
+ public:
+  ThreadLocalBoolean() = default;
+
+  ThreadLocalBoolean(const ThreadLocalBoolean&) = delete;
+  ThreadLocalBoolean& operator=(const ThreadLocalBoolean&) = delete;
+
+  ~ThreadLocalBoolean() = default;
+
+  bool Get() const { return tlp_.Get() != nullptr; }
+
+  void Set(bool val) { tlp_.Set(val ? this : nullptr); }
+
+ private:
+  ThreadLocalPointer<void> tlp_;
+};
+
 }  // namespace base
 
 #endif  // BASE_THREADING_THREAD_LOCAL_H_
diff --git a/base/threading/thread_local_unittest.cc b/base/threading/thread_local_unittest.cc
index e38a32a184007..17a336d79e9aa 100644
--- a/base/threading/thread_local_unittest.cc
+++ b/base/threading/thread_local_unittest.cc
@@ -17,12 +17,141 @@ namespace base {
 
 namespace {
 
+class ThreadLocalTesterBase : public DelegateSimpleThreadPool::Delegate {
+ public:
+  typedef ThreadLocalPointer<char> TLPType;
+
+  ThreadLocalTesterBase(TLPType* tlp, WaitableEvent* done)
+      : tlp_(tlp), done_(done) {}
+  ~ThreadLocalTesterBase() override = default;
+
+ protected:
+  raw_ptr<TLPType> tlp_;
+  raw_ptr<WaitableEvent> done_;
+};
+
+class SetThreadLocal : public ThreadLocalTesterBase {
+ public:
+  SetThreadLocal(TLPType* tlp, WaitableEvent* done)
+      : ThreadLocalTesterBase(tlp, done), val_(nullptr) {}
+  ~SetThreadLocal() override = default;
+
+  void set_value(char* val) { val_ = val; }
+
+  void Run() override {
+    DCHECK(!done_->IsSignaled());
+    tlp_->Set(val_.get());
+    done_->Signal();
+  }
+
+ private:
+  raw_ptr<char> val_;
+};
+
+class GetThreadLocal : public ThreadLocalTesterBase {
+ public:
+  GetThreadLocal(TLPType* tlp, WaitableEvent* done)
+      : ThreadLocalTesterBase(tlp, done), ptr_(nullptr) {}
+  ~GetThreadLocal() override = default;
+
+  void set_ptr(char** ptr) { ptr_ = ptr; }
+
+  void Run() override {
+    DCHECK(!done_->IsSignaled());
+    *ptr_ = tlp_->Get();
+    done_->Signal();
+  }
+
+ private:
+  raw_ptr<char*> ptr_;
+};
+
+}  // namespace
+
+// In this test, we start 2 threads which will access a ThreadLocalPointer.  We
+// make sure the default is NULL, and the pointers are unique to the threads.
+TEST(ThreadLocalTest, Pointer) {
+  DelegateSimpleThreadPool tp1("ThreadLocalTest tp1", 1);
+  DelegateSimpleThreadPool tp2("ThreadLocalTest tp1", 1);
+  tp1.Start();
+  tp2.Start();
+
+  ThreadLocalPointer<char> tlp;
+
+  static char* const kBogusPointer = reinterpret_cast<char*>(0x1234);
+
+  char* tls_val;
+  WaitableEvent done(WaitableEvent::ResetPolicy::MANUAL,
+                     WaitableEvent::InitialState::NOT_SIGNALED);
+
+  GetThreadLocal getter(&tlp, &done);
+  getter.set_ptr(&tls_val);
+
+  // Check that both threads defaulted to NULL.
+  tls_val = kBogusPointer;
+  done.Reset();
+  tp1.AddWork(&getter);
+  done.Wait();
+  EXPECT_EQ(static_cast<char*>(nullptr), tls_val);
+
+  tls_val = kBogusPointer;
+  done.Reset();
+  tp2.AddWork(&getter);
+  done.Wait();
+  EXPECT_EQ(static_cast<char*>(nullptr), tls_val);
+
+  SetThreadLocal setter(&tlp, &done);
+  setter.set_value(kBogusPointer);
+
+  // Have thread 1 set their pointer value to kBogusPointer.
+  done.Reset();
+  tp1.AddWork(&setter);
+  done.Wait();
+
+  tls_val = nullptr;
+  done.Reset();
+  tp1.AddWork(&getter);
+  done.Wait();
+  EXPECT_EQ(kBogusPointer, tls_val);
+
+  // Make sure thread 2 is still NULL
+  tls_val = kBogusPointer;
+  done.Reset();
+  tp2.AddWork(&getter);
+  done.Wait();
+  EXPECT_EQ(static_cast<char*>(nullptr), tls_val);
+
+  // Set thread 2 to kBogusPointer + 1.
+  setter.set_value(kBogusPointer + 1);
+
+  done.Reset();
+  tp2.AddWork(&setter);
+  done.Wait();
+
+  tls_val = nullptr;
+  done.Reset();
+  tp2.AddWork(&getter);
+  done.Wait();
+  EXPECT_EQ(kBogusPointer + 1, tls_val);
+
+  // Make sure thread 1 is still kBogusPointer.
+  tls_val = nullptr;
+  done.Reset();
+  tp1.AddWork(&getter);
+  done.Wait();
+  EXPECT_EQ(kBogusPointer, tls_val);
+
+  tp1.JoinAll();
+  tp2.JoinAll();
+}
+
+namespace {
+
 // A simple helper which sets the given boolean to true on destruction.
 class SetTrueOnDestruction {
  public:
-  explicit SetTrueOnDestruction(bool* was_destroyed)
-      : was_destroyed_(was_destroyed) {
-    CHECK_NE(was_destroyed, nullptr);
+  SetTrueOnDestruction(bool* was_destroyed) : was_destroyed_(was_destroyed) {
+    CHECK(was_destroyed != nullptr);
   }
 
   SetTrueOnDestruction(const SetTrueOnDestruction&) = delete;
@@ -203,4 +332,23 @@ TEST(ThreadLocalTest, ThreadLocalOwnedPointerMultiThreadedAndStaticStorage) {
   EXPECT_FALSE(main_thread_was_destroyed);
 }
 
+TEST(ThreadLocalTest, Boolean) {
+  {
+    ThreadLocalBoolean tlb;
+    EXPECT_FALSE(tlb.Get());
+
+    tlb.Set(false);
+    EXPECT_FALSE(tlb.Get());
+
+    tlb.Set(true);
+    EXPECT_TRUE(tlb.Get());
+  }
+
+  // Our slot should have been freed, we're all reset.
+  {
+    ThreadLocalBoolean tlb;
+    EXPECT_FALSE(tlb.Get());
+  }
+}
+
 }  // namespace base
diff --git a/styleguide/c++/c++.md b/styleguide/c++/c++.md
index 3f3fd4f0c4f3e..5c4b60f69e918 100644
--- a/styleguide/c++/c++.md
+++ b/styleguide/c++/c++.md
@@ -266,7 +266,6 @@ long as it complies with the following requirements:
     [the Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html#thread_local).
   * It must not be constructed inside OOM handlers or any other code that cannot
     allocate memory, since on POSIX, construction may alloc.
-
 If you can't comply with these requirements, consider
 [`base::ThreadLocalOwnedPointer`](../../base/threading/thread_local.h) or
 another nearby low-level utility.
diff --git a/tools/clang/plugins/ChromeClassTester.cpp b/tools/clang/plugins/ChromeClassTester.cpp
index 0792336fbe73f..d165d3ad5887f 100644
--- a/tools/clang/plugins/ChromeClassTester.cpp
+++ b/tools/clang/plugins/ChromeClassTester.cpp
@@ -164,6 +164,10 @@ void ChromeClassTester::BuildBannedLists() {
 }
 
 void ChromeClassTester::BuildBannedLists() {
+  // Used in really low level threading code that probably shouldn't be out of
+  // lined.
+  ignored_record_names_.emplace("ThreadLocalBoolean");
+
   // A complicated pickle derived struct that is all packed integers.
   ignored_record_names_.emplace("Header");
 
