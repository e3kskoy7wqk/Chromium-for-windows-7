

diff --git a/content/app/initialize_mojo_core.cc b/content/app/initialize_mojo_core.cc
index 6600e576a857f..b8afb34dfb28e 100644
--- a/content/app/initialize_mojo_core.cc
+++ b/content/app/initialize_mojo_core.cc
@@ -20,5 +20,9 @@
 #include "sandbox/policy/sandbox_type.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace content {
 
 void InitializeMojoCore() {
@@ -52,9 +56,12 @@ void InitializeMojoCore() {
       config.force_direct_shared_memory_allocation = true;
   } else {
 #if BUILDFLAG(IS_WIN)
-    // On Windows it's not necessary to broker shared memory allocation, as
-    // even sandboxed processes can allocate their own without trouble.
-    config.force_direct_shared_memory_allocation = true;
+    if (base::win::GetVersion() >= base::win::Version::WIN8_1) {
+      // On Windows 8.1 and later it's not necessary to broker shared memory
+      // allocation, as even sandboxed processes can allocate their own without
+      // trouble.
+      config.force_direct_shared_memory_allocation = true;
+    }
 #endif
   }
 
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index dfaaffe13b67e..001b440c5e5db 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2806,6 +2806,8 @@ source_set("browser") {
       "renderer_host/direct_manipulation_helper_win.h",
       "renderer_host/dwrite_font_file_util_win.cc",
       "renderer_host/dwrite_font_file_util_win.h",
+      "renderer_host/dwrite_font_lookup_table_builder_win.cc",
+      "renderer_host/dwrite_font_lookup_table_builder_win.h",
       "renderer_host/dwrite_font_proxy_impl_win.cc",
       "renderer_host/dwrite_font_proxy_impl_win.h",
       "renderer_host/input/stylus_handwriting_callback_sink_win.cc",
diff --git a/content/browser/accessibility/ax_platform_node_textrangeprovider_win_browsertest.cc b/content/browser/accessibility/ax_platform_node_textrangeprovider_win_browsertest.cc
index d18ee3736f6ce..aaf49f4a0914c 100644
--- a/content/browser/accessibility/ax_platform_node_textrangeprovider_win_browsertest.cc
+++ b/content/browser/accessibility/ax_platform_node_textrangeprovider_win_browsertest.cc
@@ -9,4 +9,5 @@
 #include "base/win/scoped_bstr.h"
 #include "base/win/scoped_safearray.h"
 #include "base/win/scoped_variant.h"
+#include "base/win/windows_version.h"
 #include "content/browser/accessibility/accessibility_content_browsertest.h"
@@ -3856,6 +3857,11 @@ IN_PROC_BROWSER_TEST_F(AXPlatformNodeTextRangeProviderWinBrowserTest,
 
 IN_PROC_BROWSER_TEST_F(AXPlatformNodeTextRangeProviderWinBrowserTest,
                        DegenerateRangeBoundingRect) {
+  // Due to https://crbug.com/1193359, custom fonts do not load consistently in
+  // Windows 7. So not running this test on Windows 7.
+  if (base::win::GetVersion() == base::win::Version::WIN7)
+    return;
+
   LoadInitialAccessibilityTreeFromHtmlFilePath(
       "/accessibility/html/fixed-width-text.html");
 
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index eea4901a0a3ca..87c6966880c79 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -197,3 +197,4 @@
 #include <shellapi.h>
 
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "net/base/winsock_init.h"
@@ -1024,6 +1025,16 @@ int BrowserMainLoop::PreMainMessageLoopRun() {
 
   variations::MaybeScheduleFakeCrash();
 
+#if BUILDFLAG(IS_WIN)
+  // ShellBrowserMainParts initializes a ShellBrowserContext with a profile
+  // directory only in PreMainMessageLoopRun(). DWriteFontLookupTableBuilder
+  // needs to access this directory, hence triggering after this stage has run.
+  if (base::FeatureList::IsEnabled(features::kFontSrcLocalMatching)) {
+    content::DWriteFontLookupTableBuilder::GetInstance()
+        ->SchedulePrepareFontUniqueNameTableIfNeeded();
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
   // Unretained(this) is safe as the main message loop expected to run it is
   // stopped before ~BrowserMainLoop (in the event the message loop doesn't
   // reach idle before that point).
diff --git a/content/browser/font_unique_name_lookup/font_unique_name_browsertest.cc b/content/browser/font_unique_name_lookup/font_unique_name_browsertest.cc
index 69057c293a07f..1d8151999cdbb 100644
--- a/content/browser/font_unique_name_lookup/font_unique_name_browsertest.cc
+++ b/content/browser/font_unique_name_lookup/font_unique_name_browsertest.cc
@@ -18,6 +18,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/files/scoped_temp_dir.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #endif
 
 namespace content {
diff --git a/content/browser/form_controls_browsertest.cc b/content/browser/form_controls_browsertest.cc
index 4804b9254df55..7457d4b1c6c73 100644
--- a/content/browser/form_controls_browsertest.cc
+++ b/content/browser/form_controls_browsertest.cc
@@ -24,6 +24,10 @@
 #include "base/android/build_info.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 // TODO(crbug.com/40625383): Move the baselines to skia gold for easier
 //   rebaselining when all platforms are supported.
 
@@ -142,6 +146,16 @@ class FormControlsBrowserTest : public ContentBrowserTest {
 #endif  // BUILDFLAG(IS_ANDROID)
     return false;
   }
+
+  bool SkipTestForOldWinVersion() const {
+#if BUILDFLAG(IS_WIN)
+    // Win7 font rendering causes too large of rendering diff for pixel
+    // comparison.
+    if (base::win::GetVersion() <= base::win::Version::WIN7)
+      return true;
+#endif  // BUILDFLAG(IS_WIN)
+    return false;
+  }
 
   base::test::ScopedFeatureList feature_list_;
 };
@@ -261,6 +275,9 @@ IN_PROC_BROWSER_TEST_F(FormControlsBrowserTest, Button) {
   if (SkipTestForOldAndroidVersions())
     return;
 
+  if (SkipTestForOldWinVersion())
+    return;
+
   RunTest("form_controls_browsertest_button",
           R"HTML(
             <style>body {margin: 8px} input {margin-bottom: 18px;}</style>
diff --git a/content/browser/renderer_host/direct_manipulation_helper_win.cc b/content/browser/renderer_host/direct_manipulation_helper_win.cc
index 8a50a633084e7..a0ae3fcb213e3 100644
--- a/content/browser/renderer_host/direct_manipulation_helper_win.cc
+++ b/content/browser/renderer_host/direct_manipulation_helper_win.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/win/window_event_target.h"
 #include "ui/compositor/compositor.h"
@@ -27,6 +28,10 @@ DirectManipulationHelper::CreateInstance(HWND window,
   if (!::IsWindow(window) || !compositor || !event_target)
     return nullptr;
 
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
+
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(window, compositor));
 
@@ -41,6 +46,10 @@ std::unique_ptr<DirectManipulationHelper>
 DirectManipulationHelper::CreateInstanceForTesting(
     ui::WindowEventTarget* event_target,
     Microsoft::WRL::ComPtr<IDirectManipulationViewport> viewport) {
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
+
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(0, nullptr));
 
diff --git a/content/browser/renderer_host/direct_manipulation_win_browsertest.cc b/content/browser/renderer_host/direct_manipulation_win_browsertest.cc
index f4bf76309c2cd..2ec0c54615abf 100644
--- a/content/browser/renderer_host/direct_manipulation_win_browsertest.cc
+++ b/content/browser/renderer_host/direct_manipulation_win_browsertest.cc
@@ -4,6 +4,7 @@
 
 #include "content/browser/renderer_host/direct_manipulation_helper_win.h"
 
+#include "base/win/windows_version.h"
 #include "content/browser/renderer_host/direct_manipulation_test_helper_win.h"
 #include "content/browser/renderer_host/legacy_render_widget_host_win.h"
 #include "content/browser/renderer_host/render_widget_host_view_aura.h"
@@ -86,6 +87,9 @@ class DirectManipulationBrowserTest : public DirectManipulationBrowserTestBase {
 // interaction begin and destroyed after direct manipulation interaction end.
 IN_PROC_BROWSER_TEST_F(DirectManipulationBrowserTest,
                        ObserverDuringInteraction) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   EXPECT_TRUE(NavigateToURL(shell(), GURL(url::kAboutBlankURL)));
 
   LegacyRenderWidgetHostHWND* lrwhh = GetLegacyRenderWidgetHostHWND();
@@ -137,6 +141,9 @@ class EventLogger : public ui::EventRewriter {
 
 // Check DirectManipulation events convert to ui::event correctly.
 IN_PROC_BROWSER_TEST_F(DirectManipulationBrowserTest, EventConvert) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   EXPECT_TRUE(NavigateToURL(shell(), GURL(url::kAboutBlankURL)));
 
   LegacyRenderWidgetHostHWND* lrwhh = GetLegacyRenderWidgetHostHWND();
@@ -293,6 +300,9 @@ class PrecisionTouchpadBrowserTest : public DirectManipulationBrowserTestBase {
 // Confirm that preventDefault correctly prevents pinch zoom on precision
 // touchpad.
 IN_PROC_BROWSER_TEST_F(PrecisionTouchpadBrowserTest, PreventDefaultPinchZoom) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   ASSERT_TRUE(NavigateToURL(shell(), GURL(R"HTML(data:text/html,<!DOCTYPE html>
         <html>
           Hello, world
@@ -369,6 +379,9 @@ IN_PROC_BROWSER_TEST_F(PrecisionTouchpadBrowserTest, PreventDefaultPinchZoom) {
 // Confirm that preventDefault correctly prevents scrolling on precision
 // touchpad.
 IN_PROC_BROWSER_TEST_F(PrecisionTouchpadBrowserTest, PreventDefaultScroll) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   ASSERT_TRUE(NavigateToURL(shell(), GURL(R"HTML(data:text/html,<!DOCTYPE html>
     <html>
       <body style='height:2000px; width:2000px;'>
diff --git a/content/browser/renderer_host/direct_manipulation_win_unittest.cc b/content/browser/renderer_host/direct_manipulation_win_unittest.cc
index 542a8d690bf35..f8335bf63da87 100644
--- a/content/browser/renderer_host/direct_manipulation_win_unittest.cc
+++ b/content/browser/renderer_host/direct_manipulation_win_unittest.cc
@@ -6,6 +6,7 @@
 
 #include <objbase.h>
 
+#include "base/win/windows_version.h"
 #include "content/browser/renderer_host/direct_manipulation_helper_win.h"
 #include "content/browser/renderer_host/direct_manipulation_test_helper_win.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -356,6 +357,12 @@ class DirectManipulationUnitTest : public testing::Test {
   MockWindowEventTarget event_target_;
 };
 
+TEST_F(DirectManipulationUnitTest, HelperShouldCreateForWin10) {
+  // We should create DirectManipulationHelper instance when win version >= 10.
+  EXPECT_EQ(GetDirectManipulationHelper() != nullptr,
+            base::win::GetVersion() >= base::win::Version::WIN10);
+}
+
 TEST_F(DirectManipulationUnitTest, ReceiveSimplePanTransform) {
   if (!GetDirectManipulationHelper())
     return;
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
new file mode 100644
index 0000000000000..17729359deaf4
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
@@ -0,0 +1,771 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+
+#include <set>
+#include <utility>
+
+#include "base/file_version_info.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/hash/hash.h"
+#include "base/i18n/case_conversion.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/task/task_traits.h"
+#include "base/task/thread_pool.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/trace_event/trace_event.h"
+#include "base/types/optional_util.h"
+#include "base/version.h"
+#include "base/win/registry.h"
+#include "content/browser/renderer_host/dwrite_font_file_util_win.h"
+#include "content/browser/renderer_host/dwrite_font_proxy_impl_win.h"
+#include "content/common/features.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/common/content_client.h"
+#include "content/public/common/content_features.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_persistence.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "ui/gfx/win/direct_write.h"
+
+namespace content {
+
+namespace {
+
+const base::FilePath::CharType kProtobufFilename[] =
+    FILE_PATH_LITERAL("font_unique_name_table.pb");
+
+// Timeout after which font scanning and metadata extraction is stopped and the
+// local lookup table is cleared. Font scanning and lookup table construction is
+// only needed pre Windows 10. If the timeout is hit, no local font matching
+// will be performed on this particular pre Win 10 system.
+constexpr base::TimeDelta kFontIndexingTimeoutDefault = base::Minutes(5);
+
+// In timeout test case, slow down indexing of one font file to this percentage
+// of the timeout value. Assuming that at least two fonts are indexed, the
+// timeout should be usually hit during indexing the second font.
+constexpr float kIndexingSlowDownForTestingPercentage = 0.75;
+
+// Additional local custom interface specific HRESULT codes (also added to
+// enums.xml) to mark font scanning implementation specific error situations, as
+// part of reporting them in a UMA metric.
+constexpr HRESULT kErrorFontScanningTimedOut =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD101);
+constexpr HRESULT kErrorExtractingLocalizedStringsFailed =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD102);
+constexpr HRESULT kErrorNoFullNameOrPostScriptName =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD103);
+
+bool ExtractCaseFoldedLocalizedStrings(
+    IDWriteLocalizedStrings* dwrite_localized_strings,
+    std::vector<std::string>* localized_strings) {
+  uint32_t strings_count = dwrite_localized_strings->GetCount();
+
+  if (!strings_count)
+    return false;
+
+  localized_strings->reserve(localized_strings->size() + strings_count);
+  for (UINT32 j = 0; j < strings_count; ++j) {
+    UINT32 length;
+    HRESULT hr = dwrite_localized_strings->GetStringLength(j, &length);
+    if (FAILED(hr))
+      continue;
+    std::wstring localized_name;
+    localized_name.resize(length + 1);
+    hr = dwrite_localized_strings->GetString(j, &localized_name[0], length + 1);
+    if (FAILED(hr)) {
+      continue;
+    }
+    localized_name.resize(length);
+    // The documentation for the API call does not specify an encoding but the
+    // results are wchar_t and FireFox considers them UTF-16, as seen here:
+    // https://dxr.mozilla.org/mozilla-central/source/gfx/thebes/gfxDWriteFontList.cpp#90
+    // so we'll assume that.
+    localized_strings->push_back(base::UTF16ToUTF8(
+        base::i18n::FoldCase(base::WideToUTF16(localized_name))));
+  }
+  return true;
+}
+
+bool EnsureCacheDirectory(base::FilePath cache_directory) {
+  // If the directory does not exist already, ensure that the parent directory
+  // exists, which is usually the User Data directory. If it exists, we can try
+  // creating the cache directory.
+  return !cache_directory.empty() &&
+         (base::DirectoryExists(cache_directory) ||
+          (base::DirectoryExists(cache_directory.DirName()) &&
+           CreateDirectory(cache_directory)));
+}
+
+}  // namespace
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    blink::FontUniqueNameTable_UniqueFont&& font,
+    std::vector<std::string>&& names)
+    : font_entry(std::move(font)), extracted_names(std::move(names)) {}
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::
+    ~FontFileWithUniqueNames() = default;
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other) = default;
+
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult() = default;
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult(FamilyResult&& other) =
+    default;
+DWriteFontLookupTableBuilder::FamilyResult::~FamilyResult() = default;
+
+DWriteFontLookupTableBuilder::DWriteFontLookupTableBuilder()
+    : font_indexing_timeout_(kFontIndexingTimeoutDefault) {
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::InitializeCacheDirectoryFromProfile() {
+  // Unit tests that do not launch a full browser environment usually don't need
+  // testing of src:local()-style font matching. Check that an environment is
+  // present here and configcure the cache directory based on that. If none is
+  // configured, catch this in DuplicateMemoryRegion(), i.e. when a client
+  // tries to use this API.
+  cache_directory_ =
+      GetContentClient() && GetContentClient()->browser()
+          ? GetContentClient()->browser()->GetFontLookupTableCacheDir()
+          : base::FilePath();
+}
+
+DWriteFontLookupTableBuilder::~DWriteFontLookupTableBuilder() = default;
+
+base::ReadOnlySharedMemoryRegion
+DWriteFontLookupTableBuilder::DuplicateMemoryRegion() {
+  DCHECK(!TableCacheFilePath().empty())
+      << "Ensure that a cache_directory_ is set (see "
+         "InitializeCacheDirectoryFromProfile())";
+  DCHECK(FontUniqueNameTableReady());
+  return font_table_memory_.region.Duplicate();
+}
+
+bool DWriteFontLookupTableBuilder::IsFontUniqueNameTableValid() {
+  return font_table_memory_.IsValid() && font_table_memory_.mapping.size();
+}
+
+void DWriteFontLookupTableBuilder::InitializeDirectWrite() {
+  if (direct_write_initialized_)
+    return;
+  direct_write_initialized_ = true;
+
+  Microsoft::WRL::ComPtr<IDWriteFactory> factory;
+  gfx::win::CreateDWriteFactory(&factory);
+  if (factory == nullptr) {
+    // We won't be able to load fonts, but we should still return messages so
+    // renderers don't hang if they for some reason send us a font message.
+    return;
+  }
+
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
+  factory.As<IDWriteFactory3>(&factory3_);
+
+  HRESULT hr = factory->GetSystemFontCollection(&collection_);
+  DCHECK(SUCCEEDED(hr));
+
+  if (!collection_) {
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.GetSystemFontCollectionResult", hr);
+    return;
+  }
+}
+
+std::string DWriteFontLookupTableBuilder::ComputePersistenceHash(
+    const std::string& browser_version) {
+  // Build a hash from DWrite product version, browser major version and font
+  // names and file paths as stored in the registry. The browser major version
+  // is included to ensure that the cache is rebuild at least once for every
+  // Chrome milestone release. DWrite DLL version is included to ensure that any
+  // change in DWrite behavior after an update does not interfere with the
+  // information we have in the cache. The font registry keys and values are
+  // used to detect changes in installed fonts.
+
+  std::unique_ptr<FileVersionInfo> dwrite_version_info =
+      FileVersionInfo::CreateFileVersionInfo(
+          base::FilePath(FILE_PATH_LITERAL("DWrite.dll")));
+
+  DCHECK(dwrite_version_info);
+
+  std::string dwrite_version =
+      base::UTF16ToUTF8(dwrite_version_info->product_version());
+
+  std::string to_hash = dwrite_version;
+
+  const wchar_t kFonts[] =
+      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
+  base::win::RegistryValueIterator it(HKEY_LOCAL_MACHINE, kFonts);
+  for (; it.Valid(); ++it) {
+    to_hash.append(base::WideToUTF8(it.Name()));
+    to_hash.append(base::WideToUTF8(it.Value()));
+  }
+
+  base::Version full_version = base::Version(browser_version);
+
+  // Version can be an empty string on trybots.
+  if (full_version.IsValid()) {
+    to_hash.append(base::NumberToString(full_version.components()[0]));
+  }
+
+  uint32_t fonts_changed_hash = base::PersistentHash(to_hash);
+  return std::to_string(fonts_changed_hash);
+}
+
+void DWriteFontLookupTableBuilder::SetCacheDirectoryForTesting(
+    base::FilePath cache_directory) {
+  cache_directory_ = cache_directory;
+}
+
+void DWriteFontLookupTableBuilder::SetCachingEnabledForTesting(
+    bool caching_enabled) {
+  caching_enabled_ = caching_enabled;
+}
+
+bool DWriteFontLookupTableBuilder::HasDWriteUniqueFontLookups() {
+  InitializeDirectWrite();
+  return factory3_;
+}
+
+void DWriteFontLookupTableBuilder::OverrideDWriteVersionChecksForTesting() {
+  InitializeDirectWrite();
+  factory3_.Reset();
+}
+
+base::TimeDelta DWriteFontLookupTableBuilder::IndexingTimeout() {
+  return font_indexing_timeout_;
+}
+
+void DWriteFontLookupTableBuilder::PostCallbacks() {
+  callbacks_task_runner_->StartWithTaskRunner(
+      base::ThreadPool::CreateSequencedTaskRunner({
+#if DCHECK_IS_ON()
+            // Needed for DCHECK in DuplicateMemoryRegion() which performs file
+            // operations to detect cache directory.
+            base::MayBlock(),
+#endif
+            base::TaskPriority::USER_VISIBLE,
+            base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN
+      }));
+}
+
+base::FilePath DWriteFontLookupTableBuilder::TableCacheFilePath() {
+  if (!EnsureCacheDirectory(cache_directory_))
+    return base::FilePath();
+  return cache_directory_.Append(kProtobufFilename);
+}
+
+bool DWriteFontLookupTableBuilder::PersistToFile() {
+  DCHECK(caching_enabled_);
+
+  if (!IsFontUniqueNameTableValid())
+    return false;
+
+  return blink::font_table_persistence::PersistToFile(font_table_memory_,
+                                                      TableCacheFilePath());
+}
+
+bool DWriteFontLookupTableBuilder::LoadFromFile() {
+  DCHECK(caching_enabled_);
+  DCHECK(!IsFontUniqueNameTableValid());
+
+  return blink::font_table_persistence::LoadFromFile(TableCacheFilePath(),
+                                                     &font_table_memory_);
+}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    scoped_refptr<base::SequencedTaskRunner> runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback)
+    : task_runner(std::move(runner)), mojo_callback(std::move(callback)) {}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    CallbackOnTaskRunner&& other) = default;
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::~CallbackOnTaskRunner() =
+    default;
+
+void DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady(
+    scoped_refptr<base::SequencedTaskRunner> task_runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+
+  // base::Unretained(this) acceptable as bound argument here since
+  // DWriteFontLookupTableBuilder is a singleton instance.
+  callbacks_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(
+          &DWriteFontLookupTableBuilder::RunPendingCallback,
+          base::Unretained(this),
+          CallbackOnTaskRunner(std::move(task_runner), std::move(callback))));
+}
+
+bool DWriteFontLookupTableBuilder::FontUniqueNameTableReady() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FontUniqueNameTableReady");
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  DCHECK(!HasDWriteUniqueFontLookups());
+  return font_table_built_.IsSet() && IsFontUniqueNameTableValid();
+}
+
+void DWriteFontLookupTableBuilder::
+    SchedulePrepareFontUniqueNameTableIfNeeded() {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+    InitializeDirectWrite();
+  }
+
+  // Nothing to do if we have API to directly lookup local fonts by unique name
+  // (as on Windows 10, IDWriteFactory3 available).
+  if (HasDWriteUniqueFontLookups())
+    return;
+
+  // Do not schedule indexing if we do not have a profile or temporary directory
+  // to store the cached table. This prevents repetitive and redundant scanning
+  // when the ContentBrowserClient did not provide a cache directory, as is the
+  // case in content_unittests.
+  if (TableCacheFilePath().empty())
+    return;
+
+  start_time_table_ready_ = base::TimeTicks::Now();
+  scanning_error_reasons_.clear();
+
+  scoped_refptr<base::SequencedTaskRunner> results_collection_task_runner =
+      base::ThreadPool::CreateSequencedTaskRunner(
+          {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+           base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN});
+
+  std::string browser_version =
+      GetContentClient()->browser()->GetUserAgentMetadata().full_version;
+  results_collection_task_runner->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable,
+                     base::Unretained(this), browser_version));
+}
+
+void DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable(
+    const std::string& browser_version) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  // The table must only be built once.
+  DCHECK(!font_table_built_.IsSet());
+
+  if (caching_enabled_ && LoadFromFile()) {
+    blink::FontUniqueNameTable font_table;
+    const bool update_needed =
+        !IsFontUniqueNameTableValid() ||
+        !font_table.ParseFromArray(font_table_memory_.mapping.memory(),
+                                   font_table_memory_.mapping.size()) ||
+        font_table.stored_for_platform_version_identifier() !=
+            ComputePersistenceHash(browser_version);
+
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTableDiskCacheHit",
+                          !update_needed);
+    if (!update_needed) {
+      base::TimeDelta duration =
+          base::TimeTicks::Now() - start_time_table_ready_;
+      DEPRECATED_UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                                 duration);
+      font_table_built_.Set();
+      PostCallbacks();
+      return;
+    }
+  }
+
+  start_time_table_build_ = base::TimeTicks::Now();
+  font_unique_name_table_ = std::make_unique<blink::FontUniqueNameTable>();
+
+  // The |stored_for_platform_version_identifier| proto field is used for
+  // persisting the table to disk and identifying whether an update to the
+  // table is needed when loading it back.
+  font_unique_name_table_->set_stored_for_platform_version_identifier(
+      ComputePersistenceHash(browser_version));
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+
+    outstanding_family_results_ = collection_->GetFontFamilyCount();
+    family_results_empty_ = 0;
+    family_results_non_empty_ = 0;
+    UMA_HISTOGRAM_CUSTOM_COUNTS(
+        "DirectWrite.Fonts.Proxy.FamilyCountIndexingStart",
+        outstanding_family_results_, 1, 5000, 50);
+  }
+  for (UINT32 family_index = 0; family_index < outstanding_family_results_;
+       ++family_index) {
+    // Specify base::ThreadPolicy::MUST_USE_FOREGROUND because in
+    // https://crbug.com/960263 we observed a priority inversion when running
+    // DWrite worker tasks in the background.
+    base::ThreadPool::PostTaskAndReplyWithResult(
+        FROM_HERE,
+        {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+         base::ThreadPolicy::MUST_USE_FOREGROUND,
+         base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+        base::BindOnce(
+            &ExtractPathAndNamesFromFamily, collection_, family_index,
+            start_time_table_build_, slow_down_mode_for_testing_,
+            OptionalToPtr(hang_event_for_testing_), IndexingTimeout()),
+        base::BindOnce(&DWriteFontLookupTableBuilder::
+                           AppendFamilyResultAndFinalizeIfNeeded,
+                       base::Unretained(this)));
+  }
+  // Post a task to catch timeouts should one of the
+  // tasks will eventually not reply.
+  timeout_callback_.Reset(base::BindOnce(
+      &DWriteFontLookupTableBuilder::OnTimeout, base::Unretained(this)));
+  base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(
+      FROM_HERE, timeout_callback_.callback(), IndexingTimeout());
+}
+
+// static
+DWriteFontLookupTableBuilder::FamilyResult
+DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily(
+    Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+    uint32_t family_index,
+    base::TimeTicks start_time,
+    SlowDownMode slow_down_mode_for_testing,
+    base::WaitableEvent* hang_event_for_testing,
+    base::TimeDelta indexing_timeout) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily");
+
+  static base::NoDestructor<std::u16string> windows_fonts_path(
+      GetWindowsFontsPath());
+
+  DWriteFontLookupTableBuilder::FamilyResult family_result;
+
+  if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+    family_result.exit_hresult = kErrorFontScanningTimedOut;
+    return family_result;
+  }
+
+  Microsoft::WRL::ComPtr<IDWriteFontFamily> family;
+  HRESULT hr = collection->GetFontFamily(family_index, &family);
+  if (FAILED(hr)) {
+    family_result.exit_hresult = hr;
+    return family_result;
+  }
+  UINT32 font_count = family->GetFontCount();
+
+  HRESULT last_hresult_continue_reason = S_OK;
+  for (UINT32 font_index = 0; font_index < font_count; ++font_index) {
+    if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+      family_result.exit_hresult = kErrorFontScanningTimedOut;
+      return family_result;
+    }
+
+    Microsoft::WRL::ComPtr<IDWriteFont> font;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = family->GetFont(font_index, &font);
+    }
+    if (FAILED(hr)) {
+      family_result.exit_hresult = hr;
+      return family_result;
+    }
+
+    if (font->GetSimulations() != DWRITE_FONT_SIMULATIONS_NONE)
+      continue;
+
+    std::set<std::wstring> path_set;
+    std::set<std::wstring> custom_font_path_set;
+    uint32_t ttc_index = 0;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = AddFilesForFont(font.Get(), *windows_fonts_path, &path_set);
+      if (FAILED(hr)) {
+        // It's possible to not be able to retrieve a font file for a font that
+        // is in the system font collection, see https://crbug.com/922183. If we
+        // were not able to retrieve a file for a registered font, we do not
+        // need to add it to the map.
+        last_hresult_continue_reason = hr;
+        continue;
+      }
+    }
+
+    // After having received clarification from Microsoft, the API is designed
+    // for allowing multiple files to be returned, if MS was to support a file
+    // format like Type1 fonts with this API, but for now only ever returns 1
+    // font file as only TrueType / OpenType fonts are supported.
+    DCHECK_EQ(path_set.size() + custom_font_path_set.size(), 1u);
+    // If this font is placed in a custom font path location, we pass it to
+    // Blink, and we'll track with UMA there if such a font path is matched
+    // and used. If this happens more than very rarely, we will need to add an
+    // out-of-process loading mechanism for loading those uniquely matched
+    // font files.
+    base::FilePath file_path(path_set.size() ? *path_set.begin()
+                                             : *custom_font_path_set.begin());
+    DCHECK(!file_path.empty());
+
+    // Build entry for being added to the table in separate call.
+    blink::FontUniqueNameTable_UniqueFont unique_font;
+    unique_font.set_file_path(file_path.AsUTF8Unsafe());
+    unique_font.set_ttc_index(ttc_index);
+
+    std::vector<std::string> extracted_names;
+    auto extract_names =
+        [&extracted_names,
+         &font](DWRITE_INFORMATIONAL_STRING_ID font_info_string_id) -> HRESULT {
+      // Now get names, and make them point to the added font.
+      Microsoft::WRL::ComPtr<IDWriteLocalizedStrings> font_id_keyed_names;
+      BOOL has_id_keyed_names;
+      {
+        base::ScopedBlockingCall scoped_blocking_call(
+            FROM_HERE, base::BlockingType::MAY_BLOCK);
+        HRESULT hr = font->GetInformationalStrings(
+            font_info_string_id, &font_id_keyed_names, &has_id_keyed_names);
+        if (FAILED(hr))
+          return hr;
+        if (!has_id_keyed_names)
+          return kErrorNoFullNameOrPostScriptName;
+      }
+
+      return ExtractCaseFoldedLocalizedStrings(font_id_keyed_names.Get(),
+                                               &extracted_names)
+                 ? S_OK
+                 : kErrorExtractingLocalizedStringsFailed;
+    };
+
+    hr = extract_names(DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_NAME);
+    hr = FAILED(hr) ? hr : extract_names(DWRITE_INFORMATIONAL_STRING_FULL_NAME);
+
+    if (slow_down_mode_for_testing == SlowDownMode::kDelayEachTask) {
+      base::PlatformThread::Sleep(indexing_timeout *
+                                  kIndexingSlowDownForTestingPercentage);
+    } else if (slow_down_mode_for_testing ==
+                        SlowDownMode::kHangOneTask &&
+               family_index == 0) {
+      base::ScopedAllowBaseSyncPrimitivesForTesting scoped_allow_sync_;
+      DCHECK(hang_event_for_testing);
+      hang_event_for_testing->Wait();
+    }
+
+    if (extracted_names.empty()) {
+      last_hresult_continue_reason = hr;
+      continue;
+    }
+
+    family_result.exit_hresult = S_OK;
+    family_result.font_files_with_names.push_back(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames(
+            std::move(unique_font), std::move(extracted_names)));
+  }
+
+  if (family_result.font_files_with_names.empty()) {
+    family_result.exit_hresult = last_hresult_continue_reason;
+  }
+
+  return family_result;
+}
+
+void DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded(
+    const FamilyResult& family_result) {
+  TRACE_EVENT0(
+      "dwrite,fonts",
+      "DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded");
+
+  outstanding_family_results_--;
+
+  // If this task's response came late and OnTimeout was called, we
+  // do not need the results anymore and the table was already finalized.
+  if (font_table_built_.IsSet())
+    return;
+
+  if (!family_result.font_files_with_names.size())
+    family_results_empty_++;
+  else
+    family_results_non_empty_++;
+
+  if (FAILED(family_result.exit_hresult))
+    scanning_error_reasons_[family_result.exit_hresult]++;
+
+  for (const FontFileWithUniqueNames& font_of_family :
+       family_result.font_files_with_names) {
+    blink::FontUniqueNameTable_UniqueFont* added_unique_font =
+        font_unique_name_table_->add_fonts();
+
+    *added_unique_font = font_of_family.font_entry;
+
+    int added_font_index = font_unique_name_table_->fonts_size() - 1;
+
+    for (auto& font_name : font_of_family.extracted_names) {
+      blink::FontUniqueNameTable_UniqueNameToFontMapping* added_mapping =
+          font_unique_name_table_->add_name_map();
+      DCHECK(added_mapping);
+      added_mapping->set_font_name(font_name);
+      added_mapping->set_font_index(added_font_index);
+    }
+  }
+
+  if (!outstanding_family_results_) {
+    FinalizeFontTable();
+  }
+}
+
+void DWriteFontLookupTableBuilder::RunPendingCallback(
+    CallbackOnTaskRunner pending_callback) {
+  DCHECK(callbacks_task_runner_->RunsTasksInCurrentSequence());
+  pending_callback.task_runner->PostTask(
+      FROM_HERE, base::BindOnce(std::move(pending_callback.mojo_callback),
+                                DuplicateMemoryRegion()));
+}
+
+void DWriteFontLookupTableBuilder::FinalizeFontTable() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FinalizeFontTable");
+  DCHECK(!font_table_built_.IsSet());
+
+  timeout_callback_.Cancel();
+
+  // Make sure that whatever happens in the remainder of this function the
+  // FontUniqueNameTable object gets released by moving it to a local variable.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table(
+      std::move(font_unique_name_table_));
+
+  bool timed_out = false;
+  if (base::TimeTicks::Now() - start_time_table_build_ > IndexingTimeout()) {
+    font_unique_name_table->clear_fonts();
+    font_unique_name_table->clear_name_map();
+    timed_out = true;
+  }
+  UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.TableBuildTimedOut",
+                        timed_out);
+
+  int empty_family_results_percentage =
+      round(((family_results_empty_ * 1.0f) /
+             (family_results_empty_ + family_results_non_empty_)) *
+            100.0);
+  UMA_HISTOGRAM_PERCENTAGE("DirectWrite.Fonts.Proxy.EmptyFamilyResultsRatio",
+                           empty_family_results_percentage);
+
+  if (empty_family_results_percentage > 0) {
+    auto most_frequent_hresult_element = std::max_element(
+        std::begin(scanning_error_reasons_), std::end(scanning_error_reasons_),
+        [](const decltype(scanning_error_reasons_)::value_type& a,
+           decltype(scanning_error_reasons_)::value_type& b) {
+          return a.second < b.second;
+        });
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.MostFrequentScanningFailure",
+        most_frequent_hresult_element->first);
+  }
+
+  unsigned num_font_files = font_unique_name_table->fonts_size();
+
+  blink::FontTableMatcher::SortUniqueNameTableForSearch(
+      font_unique_name_table.get());
+
+  font_table_memory_ = base::ReadOnlySharedMemoryRegion::Create(
+      font_unique_name_table->ByteSizeLong());
+
+  if (!IsFontUniqueNameTableValid() ||
+      !font_unique_name_table->SerializeToArray(
+          font_table_memory_.mapping.memory(),
+          font_table_memory_.mapping.size())) {
+    font_table_memory_ = base::MappedReadOnlyRegion();
+  }
+
+  if (caching_enabled_) {
+    bool persist_succeeded = PersistToFile();
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTablePersistSuccess",
+                          persist_succeeded);
+  }
+
+  font_table_built_.Set();
+  PostCallbacks();
+
+  if (!IsFontUniqueNameTableValid())
+    return;
+
+  base::TimeDelta duration = base::TimeTicks::Now() - start_time_table_build_;
+  DEPRECATED_UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableBuildTime",
+                             duration);
+
+  duration = base::TimeTicks::Now() - start_time_table_ready_;
+  DEPRECATED_UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                             duration);
+
+  // The size is usually tens of kilobytes, ~50kb on a standard Windows 10
+  // installation, 1MB should be a more than high enough upper limit.
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.LookupTableSize",
+                              font_table_memory_.mapping.size() / 1024, 1, 1000,
+                              50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.NumFontFiles",
+                              num_font_files, 1, 5000, 50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.IndexingSpeed",
+                              num_font_files / duration.InSecondsF(), 1, 10000,
+                              50);
+}
+
+void DWriteFontLookupTableBuilder::OnTimeout() {
+  DCHECK(!font_table_built_.IsSet());
+  FinalizeFontTable();
+}
+
+void DWriteFontLookupTableBuilder::SetSlowDownIndexingForTestingWithTimeout(
+    SlowDownMode slow_down_mode,
+    base::TimeDelta new_timeout) {
+  slow_down_mode_for_testing_ = slow_down_mode;
+  font_indexing_timeout_ = new_timeout;
+  if (slow_down_mode == SlowDownMode::kHangOneTask)
+    hang_event_for_testing_.emplace();
+}
+
+void DWriteFontLookupTableBuilder::ResetLookupTableForTesting() {
+  slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  font_indexing_timeout_ = kFontIndexingTimeoutDefault;
+  callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+  font_table_memory_ = base::MappedReadOnlyRegion();
+  caching_enabled_ = true;
+  font_table_built_.UnsafeResetForTesting();
+}
+
+void DWriteFontLookupTableBuilder::ResetStateForTesting() {
+  ResetLookupTableForTesting();
+  // Recreate fFactory3 if available, to reset
+  // OverrideDWriteVersionChecksForTesting().
+  direct_write_initialized_ = false;
+  InitializeDirectWrite();
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::ResumeFromHangForTesting() {
+  hang_event_for_testing_->Signal();
+}
+
+// static
+DWriteFontLookupTableBuilder* DWriteFontLookupTableBuilder::GetInstance() {
+  static base::NoDestructor<DWriteFontLookupTableBuilder> instance;
+  return instance.get();
+}
+
+}  // namespace content
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
new file mode 100644
index 0000000000000..f656225802ed5
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
@@ -0,0 +1,255 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+#define CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+#include <dwrite_3.h>
+#include <wrl.h>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/cancelable_callback.h"
+#include "base/files/file_path.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/memory/singleton.h"
+#include "base/no_destructor.h"
+#include "base/synchronization/atomic_flag.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/task/deferred_sequenced_task_runner.h"
+#include "base/time/time.h"
+#include "content/common/content_export.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom.h"
+
+namespace content {
+
+// Singleton class which encapsulates building the font unique name table lookup
+// once, then serving the built table as a ReadOnlySharedMemoryRegion. Receives
+// requests for accessing this table from DWriteFontProxyImpl after Mojo IPC
+// calls from the renderer. A method ScheduleBuildFontUniqueNameTable() is
+// provided to schedule building the font unique name lookup
+// structure. EnsureFontUniqueNameTable() can be called on any thread to wait
+// for the lookup table to be ready. After that, DuplicateMemoryRegion() can be
+// used to retrieve the lookup structure. Thread-safe when used as described
+// below.
+class CONTENT_EXPORT DWriteFontLookupTableBuilder {
+ public:
+  static DWriteFontLookupTableBuilder* GetInstance();
+
+  DWriteFontLookupTableBuilder(const DWriteFontLookupTableBuilder&) = delete;
+  DWriteFontLookupTableBuilder& operator=(const DWriteFontLookupTableBuilder&) =
+      delete;
+
+  // Retrieve the prepared memory region if it is available.
+  // EnsureFontUniqueNameTable() must be checked before.
+  base::ReadOnlySharedMemoryRegion DuplicateMemoryRegion();
+
+  // Enqueue a request to get notified about the availability of the shared
+  // memory region holding the unique font lookup table.
+  // https://crbug.com/967316 shows that we do have a higher number of
+  // DWriteFontProxyImpl instances, potentially running on different
+  // TaskRunners. Capture each relevant task runner with a call to this method.
+  void QueueShareMemoryRegionWhenReady(
+      scoped_refptr<base::SequencedTaskRunner> task_runner,
+      blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback);
+
+  // Returns whether the indexing has completed and the shared memory region is
+  // immediately ready without any sync operations.
+  bool FontUniqueNameTableReady();
+
+  // If needed, i.e. if we're on pre-Windows 10, posts a task to load from cache
+  // or build (if cache not available) the unique name table index, should only
+  // be called once at browser startup, after that,
+  // QueueShareMemoryRegionWhenReady() to trigger the mojo callbacks when the
+  // table is ready.
+  void SchedulePrepareFontUniqueNameTableIfNeeded();
+
+  enum class SlowDownMode { kDelayEachTask, kHangOneTask, kNoSlowdown };
+
+  // Slow down each family indexing step for testing the internal timeout,
+  // either with a single hung task or by delaying each indexing step. At the
+  // same time, configure a new timeout value for testing, overriding the
+  // default timeout.
+  void SetSlowDownIndexingForTestingWithTimeout(SlowDownMode slowdown_mode,
+                                                base::TimeDelta new_timeout);
+
+  // Reset timeout overrides and empty table. Needed to trigger rebuilding the
+  // lookup table, when testing using slowed-down indexing. Otherwise, the test
+  // methods would use the already cached lookup table.
+  void ResetLookupTableForTesting();
+
+  // Resets other overrides such as the DWrite version check override and cache
+  // directory back to its default values.
+  void ResetStateForTesting();
+
+  // Signals hang_event_for_testing_ which is used in testing hanging one of the
+  // font name retrieval tasks.
+  void ResumeFromHangForTesting();
+
+  // Computes a hash to determine whether cache contents needed to be updated,
+  // consisting of font names and their file paths read from the registry (not
+  // from disk), The DWrite.dll's product version and the Chrome version, as a
+  // safety mechanism to refresh the cache for every release. Exposed as a
+  // public method to be able to run the hash function in a test.
+  // `browser_version` is used in the hash.
+  std::string ComputePersistenceHash(const std::string& browser_version);
+
+  // Configures the cache directory in which to store the serialized font table
+  // lookup structure. Use only in testing. Normally the directory name is
+  // retrieved from ContentBrowserClient.
+  void SetCacheDirectoryForTesting(base::FilePath cache_directory);
+
+  // Configures whether the cache should be used. Needed for testing to test
+  // repeated rebuilding of the font table lookup structure.
+  void SetCachingEnabledForTesting(bool caching_enabled);
+
+  // Disable DCHECKs that ensure DWriteFontLookupTableBuilder is only
+  // run pre Windows 10, used for testing only to allow running the tests on
+  // Windows 10.
+  void OverrideDWriteVersionChecksForTesting();
+
+ private:
+  friend class base::NoDestructor<DWriteFontLookupTableBuilder>;
+
+  struct FontFileWithUniqueNames {
+    FontFileWithUniqueNames(blink::FontUniqueNameTable_UniqueFont&& font,
+                            std::vector<std::string>&& names);
+    ~FontFileWithUniqueNames();
+    FontFileWithUniqueNames(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other);
+    FontFileWithUniqueNames(const FontFileWithUniqueNames&) = delete;
+    FontFileWithUniqueNames& operator=(const FontFileWithUniqueNames&) = delete;
+
+    blink::FontUniqueNameTable_UniqueFont font_entry;
+    std::vector<std::string> extracted_names;
+  };
+
+  struct FamilyResult {
+    FamilyResult();
+
+    FamilyResult(const FamilyResult&) = delete;
+    FamilyResult& operator=(const FamilyResult&) = delete;
+
+    FamilyResult(FamilyResult&& other);
+
+    ~FamilyResult();
+
+    std::vector<FontFileWithUniqueNames> font_files_with_names;
+    HRESULT exit_hresult{S_OK};
+  };
+
+  // Try to find a serialized lookup table from the cache directory specified at
+  // construction and load it into memory.
+  bool LoadFromFile();
+
+  // Serialize the current lookup table into a file in the cache directory
+  // specified at construction time.
+  bool PersistToFile();
+
+  // Initialize the cache directory from the user profile directory if
+  // DWriteFontLookupTableBuilder is executed in an environment where the
+  // profile is accessible.
+  void InitializeCacheDirectoryFromProfile();
+
+  // Load from cache or construct the font unique name lookup table. If the
+  // cache is up to date, do not schedule a run to scan all Windows-enumerated
+  // fonts. `browser_version` is used in the hashing algorithm for the cache
+  // key.
+  void PrepareFontUniqueNameTable(const std::string& browser_version);
+
+  // Helper function to perform DWrite operations to retrieve path names, full
+  // font name and PostScript name for a font specified by collection + family
+  // index.
+  static FamilyResult ExtractPathAndNamesFromFamily(
+      Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+      uint32_t family_index,
+      base::TimeTicks start_time,
+      SlowDownMode slow_down_mode,
+      base::WaitableEvent* hang_event_for_testing,
+      base::TimeDelta indexing_timeout);
+
+  // Callback from scheduled tasks to add the retrieved font names to the
+  // protobuf.
+  void AppendFamilyResultAndFinalizeIfNeeded(const FamilyResult& family_result);
+
+  // Sort the results that were collected into the protobuf structure and
+  // signal that font unique name lookup table construction is complete.
+  // Serializes the constructed protobuf to disk.
+  void FinalizeFontTable();
+
+  void OnTimeout();
+
+  bool IsFontUniqueNameTableValid();
+
+  void InitializeDirectWrite();
+
+  base::FilePath TableCacheFilePath();
+
+  // Returns true if IDWriteFactory3 is available, which means that we can
+  // access IDWriteFontSet API which provides direct lookup by PostScript name
+  // and full font name, in which case we do not need to build this table.
+  bool HasDWriteUniqueFontLookups();
+
+  base::TimeDelta IndexingTimeout();
+
+  void PostCallbacks();
+
+  DWriteFontLookupTableBuilder();
+  ~DWriteFontLookupTableBuilder();
+
+  // Protobuf structure temporarily used and shared during table construction.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table_;
+
+  struct CallbackOnTaskRunner {
+    CallbackOnTaskRunner(
+        scoped_refptr<base::SequencedTaskRunner>,
+        blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback);
+    CallbackOnTaskRunner(CallbackOnTaskRunner&&);
+    ~CallbackOnTaskRunner();
+    scoped_refptr<base::SequencedTaskRunner> task_runner;
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback
+        mojo_callback;
+  };
+
+  // Task method to bind the CallbackOnTaskRunner for delayed execution when
+  // building the font table is completed.
+  void RunPendingCallback(CallbackOnTaskRunner pending_callback);
+
+  base::MappedReadOnlyRegion font_table_memory_;
+  base::AtomicFlag font_table_built_;
+
+  bool direct_write_initialized_ = false;
+  base::TimeDelta font_indexing_timeout_;
+  Microsoft::WRL::ComPtr<IDWriteFontCollection> collection_;
+  Microsoft::WRL::ComPtr<IDWriteFactory2> factory2_;
+  Microsoft::WRL::ComPtr<IDWriteFactory3> factory3_;
+  SlowDownMode slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  uint32_t outstanding_family_results_ = 0;
+  uint32_t family_results_non_empty_ = 0;
+  uint32_t family_results_empty_ = 0;
+  base::TimeTicks start_time_table_ready_;
+  base::TimeTicks start_time_table_build_;
+  base::FilePath cache_directory_;
+
+  bool caching_enabled_ = true;
+  absl::optional<base::WaitableEvent> hang_event_for_testing_;
+  base::CancelableOnceCallback<void()> timeout_callback_;
+
+  // All responses are serialized through this DeferredSequencedTaskRunner. It
+  // is started when the table is ready and guarantees that requests made before
+  // the table was ready are replied to first.
+  scoped_refptr<base::DeferredSequencedTaskRunner> callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+
+  std::map<HRESULT, unsigned> scanning_error_reasons_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win_unittest.cc b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win_unittest.cc
index f121022d3075e..0a05a25184e72 100644
--- a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win_unittest.cc
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win_unittest.cc
@@ -17,6 +17,7 @@
 #include "base/test/bind.h"
 #include "base/test/scoped_feature_list.h"
 #include "base/test/task_environment.h"
+#include "content/common/features.h"
 #include "content/public/common/content_features.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
index 836a576e5aa09..8c1e45a8a0dd1 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
@@ -369,6 +369,21 @@ void DWriteFontProxyImpl::MapCharacters(
   DCHECK_GT(result->mapped_length, 0u);
 }
 
+void DWriteFontProxyImpl::GetUniqueNameLookupTableIfAvailable(
+    GetUniqueNameLookupTableIfAvailableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  /* Table is not synchronously available, return immediately. */
+  if (!DWriteFontLookupTableBuilder::GetInstance()
+           ->FontUniqueNameTableReady()) {
+    std::move(callback).Run(false, base::ReadOnlySharedMemoryRegion());
+    return;
+  }
+
+  std::move(callback).Run(
+      true,
+      DWriteFontLookupTableBuilder::GetInstance()->DuplicateMemoryRegion());
+}
+
 void DWriteFontProxyImpl::MatchUniqueFont(
     const std::u16string& unique_font_name,
     MatchUniqueFontCallback callback) {
@@ -458,6 +473,25 @@ void DWriteFontProxyImpl::MatchUniqueFont(
   std::move(callback).Run(std::move(font_file), ttc_index);
 }
 
+void DWriteFontProxyImpl::GetUniqueFontLookupMode(
+    GetUniqueFontLookupModeCallback callback) {
+  InitializeDirectWrite();
+  // If factory3_ is available, that means we can use IDWriteFontSet to filter
+  // for PostScript name and full font name directly and do not need to build
+  // the lookup table.
+  blink::mojom::UniqueFontLookupMode lookup_mode =
+      factory3_.Get() ? blink::mojom::UniqueFontLookupMode::kSingleLookups
+                      : blink::mojom::UniqueFontLookupMode::kRetrieveTable;
+  std::move(callback).Run(lookup_mode);
+}
+
+void DWriteFontProxyImpl::GetUniqueNameLookupTable(
+    GetUniqueNameLookupTableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  DWriteFontLookupTableBuilder::GetInstance()->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(), std::move(callback));
+}
+
 void DWriteFontProxyImpl::FallbackFamilyAndStyleForCodepoint(
     const std::string& base_family_name,
     const std::string& locale_name,
@@ -516,15 +550,14 @@ void DWriteFontProxyImpl::InitializeDirectWrite() {
     return;
   }
 
-  // QueryInterface for IDWriteFactory2. This should succeed since we only
-  // support >= Win10.
+  // QueryInterface for IDWriteFactory2. It's ok for this to fail if we are
+  // running an older version of DirectWrite (earlier than Win8.1).
   factory_.As<IDWriteFactory2>(&factory2_);
-  DCHECK(factory2_);
 
-  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows.
-  // This should succeed since we only support >= Win10.
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
   factory_.As<IDWriteFactory3>(&factory3_);
-  DCHECK(factory3_);
 
   HRESULT hr = factory_->GetSystemFontCollection(&collection_);
   DCHECK(SUCCEEDED(hr));
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
index 0b1372e57a540..f6327c8fee27e 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
@@ -14,6 +14,7 @@
 #include <vector>
 
 #include "base/memory/read_only_shared_memory_region.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/browser_thread.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
@@ -56,6 +57,15 @@ class CONTENT_EXPORT DWriteFontProxyImpl
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void GetUniqueFontLookupMode(
+      GetUniqueFontLookupModeCallback callback) override;
+
+  void GetUniqueNameLookupTableIfAvailable(
+      GetUniqueNameLookupTableIfAvailableCallback callback) override;
+
+  void GetUniqueNameLookupTable(
+      GetUniqueNameLookupTableCallback callback) override;
+
   void FallbackFamilyAndStyleForCodepoint(
       const std::string& base_family_name,
       const std::string& locale_name,
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
index 5b737b4ed2c34..f67f13bc15e7b 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
@@ -10,13 +10,18 @@
 #include <memory>
 
 #include "base/containers/contains.h"
+#include "base/file_version_info.h"
 #include "base/files/file.h"
+#include "base/files/scoped_temp_dir.h"
 #include "base/memory/ref_counted.h"
 #include "base/run_loop.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/utf_string_conversions.h"
+#include "base/synchronization/waitable_event.h"
 #include "base/test/scoped_feature_list.h"
 #include "base/test/task_environment.h"
+#include "base/win/windows_version.h"
+#include "content/common/features.h"
 #include "content/public/common/content_features.h"
 #include "content/public/test/browser_task_environment.h"
 #include "mojo/public/cpp/bindings/receiver.h"
@@ -32,6 +37,24 @@ namespace content {
 
 namespace {
 
+struct FontExpectation {
+  const char* font_name;
+  uint16_t ttc_index;
+};
+
+constexpr FontExpectation kExpectedTestFonts[] = {{"CambriaMath", 1},
+                                                  {"Ming-Lt-HKSCS-ExtB", 2},
+                                                  {"NSimSun", 1},
+                                                  {"calibri-bolditalic", 0}};
+
+// DirectWrite on Windows supports IDWriteFontSet API which allows for querying
+// by PostScript name and full font name directly. In the implementation of
+// DWriteFontProxy we check whether this API is available by checking for
+// whether IDWriteFactory3 is available. In order to validate in a unit test
+// whether this check works, compare it against the dwrite.dll major version -
+// versions starting from 10 have the required functionality.
+constexpr int kDWriteMajorVersionSupportingSingleLookups = 10;
+
 // Base test class that sets up the Mojo connection to DWriteFontProxy so that
 // tests can call its Mojo methods.
 class DWriteFontProxyImplUnitTest : public testing::Test {
@@ -43,12 +66,60 @@ class DWriteFontProxyImplUnitTest : public testing::Test {
     return *dwrite_font_proxy_;
   }
 
+  bool SupportsSingleLookups() {
+    blink::mojom::UniqueFontLookupMode lookup_mode;
+    dwrite_font_proxy().GetUniqueFontLookupMode(&lookup_mode);
+    return lookup_mode == blink::mojom::UniqueFontLookupMode::kSingleLookups;
+  }
+
   base::test::TaskEnvironment task_environment_;
   mojo::Remote<blink::mojom::DWriteFontProxy> dwrite_font_proxy_;
   DWriteFontProxyImpl impl_;
   mojo::Receiver<blink::mojom::DWriteFontProxy> receiver_;
 };
 
+// Derived class for tests that exercise font unique local matching mojo methods
+// of DWriteFontProxy. Needs a ScopedFeatureList to activate the feature as it
+// is currently behind a flag.
+class DWriteFontProxyLocalMatchingTest : public DWriteFontProxyImplUnitTest {
+ public:
+  DWriteFontProxyLocalMatchingTest() {
+    feature_list_.InitAndEnableFeature(features::kFontSrcLocalMatching);
+  }
+
+ private:
+  base::test::ScopedFeatureList feature_list_;
+};
+
+// Derived class for tests that exercise the parts of the DWriteFontProxy Mojo
+// interface that deal with accessing the font lookup table created by
+// DWriteFontLookupTableBuilder. Initializes the DWriteFontLookupTableBuilder
+// and has a ScopedTempDir for testing persisting the lookup table to disk.
+class DWriteFontProxyTableMatchingTest
+    : public DWriteFontProxyLocalMatchingTest {
+ public:
+  void SetUp() override {
+    DWriteFontLookupTableBuilder* table_builder_instance =
+        DWriteFontLookupTableBuilder::GetInstance();
+    bool temp_dir_success = scoped_temp_dir_.CreateUniqueTempDir();
+    ASSERT_TRUE(temp_dir_success);
+    table_builder_instance->OverrideDWriteVersionChecksForTesting();
+    table_builder_instance->SetCacheDirectoryForTesting(
+        scoped_temp_dir_.GetPath());
+    table_builder_instance->ResetLookupTableForTesting();
+    table_builder_instance->SchedulePrepareFontUniqueNameTableIfNeeded();
+  }
+
+  void TearDown() override {
+    DWriteFontLookupTableBuilder* table_builder_instance =
+        DWriteFontLookupTableBuilder::GetInstance();
+    table_builder_instance->ResetStateForTesting();
+  }
+
+ private:
+  base::ScopedTempDir scoped_temp_dir_;
+};
+
 TEST_F(DWriteFontProxyImplUnitTest, GetFamilyCount) {
   UINT32 family_count = 0;
   dwrite_font_proxy().GetFamilyCount(&family_count);
@@ -194,7 +265,12 @@ TEST_F(DWriteFontProxyImplUnitTest, TestCustomFontFiles) {
 }
 
 TEST_F(DWriteFontProxyImplUnitTest, FallbackFamily) {
+  const bool on_win10 = base::win::GetVersion() >= base::win::Version::WIN10;
+
   for (auto& fallback_request : gfx::kGetFontFallbackTests) {
+    if (fallback_request.is_win10 && !on_win10)
+      continue;
+
     blink::mojom::FallbackFamilyAndStylePtr fallback_family_and_style;
     UChar32 codepoint;
     U16_GET(fallback_request.text.c_str(), 0, 0, fallback_request.text.size(),
@@ -219,6 +295,91 @@ TEST_F(DWriteFontProxyImplUnitTest, FallbackFamily) {
   }
 }
 
+namespace {
+void TestWhenLookupTableReady(
+    bool* did_test_fonts,
+    base::ReadOnlySharedMemoryRegion font_table_memory) {
+  blink::FontTableMatcher font_table_matcher(font_table_memory.Map());
+  for (auto& test_font_name_index : kExpectedTestFonts) {
+    absl::optional<blink::FontTableMatcher::MatchResult> match_result =
+        font_table_matcher.MatchName(test_font_name_index.font_name);
+    ASSERT_TRUE(match_result)
+        << "No font matched for font name: " << test_font_name_index.font_name;
+    base::File unique_font_file(
+        base::FilePath::FromUTF8Unsafe(match_result->font_path),
+        base::File::FLAG_OPEN | base::File::FLAG_READ);
+    ASSERT_TRUE(unique_font_file.IsValid());
+    ASSERT_GT(unique_font_file.GetLength(), 0);
+    ASSERT_EQ(test_font_name_index.ttc_index, match_result->ttc_index);
+    *did_test_fonts = true;
+  }
+}
+}  // namespace
+
+TEST_F(DWriteFontProxyTableMatchingTest, TestFindUniqueFont) {
+  bool lookup_table_results_were_tested = false;
+  dwrite_font_proxy().GetUniqueNameLookupTable(base::BindOnce(
+      &TestWhenLookupTableReady, &lookup_table_results_were_tested));
+  task_environment_.RunUntilIdle();
+  ASSERT_TRUE(lookup_table_results_were_tested);
+}
+
+TEST_F(DWriteFontProxyLocalMatchingTest, TestSingleLookup) {
+  // Do not run this test on unsupported Windows versions.
+  if (!SupportsSingleLookups())
+    return;
+  for (auto& test_font_name_index : kExpectedTestFonts) {
+    base::File result_handle;
+    uint32_t ttc_index;
+    dwrite_font_proxy().MatchUniqueFont(
+        base::UTF8ToUTF16(test_font_name_index.font_name), &result_handle,
+        &ttc_index);
+    ASSERT_TRUE(result_handle.IsValid());
+    ASSERT_GT(result_handle.GetLength(), 0);
+    ASSERT_EQ(test_font_name_index.ttc_index, ttc_index);
+  }
+}
+
+TEST_F(DWriteFontProxyLocalMatchingTest, TestSingleLookupUnavailable) {
+  // Do not run this test on unsupported Windows versions.
+  if (!SupportsSingleLookups())
+    return;
+  base::File result_handle;
+  uint32_t ttc_index;
+  std::u16string unavailable_font_name =
+      u"Unavailable_Font_Name_56E7EA7E-2C69-4E23-99DC-750BC19B250E";
+  dwrite_font_proxy().MatchUniqueFont(unavailable_font_name, &result_handle,
+                                      &ttc_index);
+  ASSERT_FALSE(result_handle.IsValid());
+  ASSERT_EQ(ttc_index, 0u);
+}
+
+TEST_F(DWriteFontProxyLocalMatchingTest, TestLookupMode) {
+  std::unique_ptr<FileVersionInfo> dwrite_version_info =
+      FileVersionInfo::CreateFileVersionInfo(
+          base::FilePath(FILE_PATH_LITERAL("DWrite.dll")));
+
+  std::string dwrite_version =
+      base::UTF16ToUTF8(dwrite_version_info->product_version());
+
+  int dwrite_major_version_number = 0;
+  ASSERT_TRUE(
+      base::StringToInt(dwrite_version.substr(0, dwrite_version.find(".")),
+                        &dwrite_major_version_number));
+
+  blink::mojom::UniqueFontLookupMode expected_lookup_mode;
+  if (dwrite_major_version_number >=
+      kDWriteMajorVersionSupportingSingleLookups) {
+    expected_lookup_mode = blink::mojom::UniqueFontLookupMode::kSingleLookups;
+  } else {
+    expected_lookup_mode = blink::mojom::UniqueFontLookupMode::kRetrieveTable;
+  }
+
+  blink::mojom::UniqueFontLookupMode lookup_mode;
+  dwrite_font_proxy().GetUniqueFontLookupMode(&lookup_mode);
+  ASSERT_EQ(lookup_mode, expected_lookup_mode);
+}
+
 }  // namespace
 
 }  // namespace content
diff --git a/content/test/BUILD.gn b/content/test/BUILD.gn
index 0dad112416dbd..18c4d82d2bfb4 100644
--- a/content/test/BUILD.gn
+++ b/content/test/BUILD.gn
@@ -3206,6 +3206,7 @@ test("content_unittests") {
       "../browser/renderer_host/direct_manipulation_test_helper_win.cc",
       "../browser/renderer_host/direct_manipulation_test_helper_win.h",
       "../browser/renderer_host/direct_manipulation_win_unittest.cc",
+      "../browser/renderer_host/dwrite_font_lookup_table_builder_win_unittest.cc",
       "../browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc",
       "../browser/screenlock_monitor/screenlock_monitor_device_source_win_unittest.cc",
       "../child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc",
diff --git a/content/test/dwrite_font_fake_sender_win.cc b/content/test/dwrite_font_fake_sender_win.cc
index dd6c051111e0c..848a7fcc13be2 100644
--- a/content/test/dwrite_font_fake_sender_win.cc
+++ b/content/test/dwrite_font_fake_sender_win.cc
@@ -146,6 +146,15 @@ void FakeFontCollection::MapCharacters(
 void FakeFontCollection::MatchUniqueFont(const std::u16string& unique_font_name,
                                          MatchUniqueFontCallback callback) {}
 
+void FakeFontCollection::GetUniqueFontLookupMode(
+    GetUniqueFontLookupModeCallback callback) {}
+
+void FakeFontCollection::GetUniqueNameLookupTable(
+    GetUniqueNameLookupTableCallback callback) {}
+
+void FakeFontCollection::GetUniqueNameLookupTableIfAvailable(
+    GetUniqueNameLookupTableIfAvailableCallback callback) {}
+
 void FakeFontCollection::FallbackFamilyAndStyleForCodepoint(
     const std::string& base_family_name,
     const std::string& locale_name,
diff --git a/content/test/dwrite_font_fake_sender_win.h b/content/test/dwrite_font_fake_sender_win.h
index 3906ff44e64a6..223e1546a197d 100644
--- a/content/test/dwrite_font_fake_sender_win.h
+++ b/content/test/dwrite_font_fake_sender_win.h
@@ -125,6 +125,12 @@ class FakeFontCollection : public blink::mojom::DWriteFontProxy {
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void GetUniqueFontLookupMode(
+      GetUniqueFontLookupModeCallback callback) override;
+  void GetUniqueNameLookupTableIfAvailable(
+      GetUniqueNameLookupTableIfAvailableCallback callback) override;
+  void GetUniqueNameLookupTable(
+      GetUniqueNameLookupTableCallback callback) override;
   void FallbackFamilyAndStyleForCodepoint(
       const std::string& base_family_name,
       const std::string& locale_name,
diff --git a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
index 9363936246018..c6ddb5b7e6061 100644
--- a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
+++ b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
@@ -63,14 +63,47 @@ interface DWriteFontProxy {
   GetFontFileHandles(uint32 family_index)
      => (array<mojo_base.mojom.ReadOnlyFile> file_handles);
 
-  // Matches a unique PostScript or full font name against the installed fonts
-  // using DirectWrite API. Returns a pre-opened file handle and ttc_index from
-  // which the unique font can be instantiated. Returns null handle and 0 ttc
-  // index if no font is found.
+  // Returns which font unique name matching lookup mode is to be used on the
+  // current machine. On DirectWrite 10 and above, single lookups can be
+  // performed directly against DirectWrite API. On older DirectWrite (Windows
+  // 7-8.1), unique font lookups need to be performed against a shared memory
+  // region which contains the lookup table. Compare GetUniqueFontLookupTable()
+  // for lookup mode kRetrieveTable and MatchUniqueFont for
+  // lookup mode kSingleLookups.
+  [Sync]
+  GetUniqueFontLookupMode() => (UniqueFontLookupMode lookup_mode);
+
+  // On supported Windows versions, matches a unique PostScript or full font
+  // name against the installed fonts using DirectWrite API. Returns a
+  // pre-opened file handle and ttc_index from which the unique font can be
+  // instantiated.  Check which mode is supported using
+  // GetFontUniqueNameLookupMode().  Returns null handle and 0 ttc index
+  // if no font is found. Must not be called if GetUniqueFontLookupMode()
+  // returned kRetrieveTable.
   [Sync]
   MatchUniqueFont(mojo_base.mojom.String16 font_unique_name)
       => (mojo_base.mojom.ReadOnlyFile? file_handle, uint32 ttc_index);
 
+  // Synchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion if it is available
+  // immediately without any blocking operations. Use FontTableMatcher to
+  // perform searches in it. If it is not available without blocking operations,
+  // sync_available is false and no shared memory region is provided.
+  [Sync]
+  GetUniqueNameLookupTableIfAvailable()
+      => (bool sync_available,
+          mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
+  // Asynchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion. The lookup list is built
+  // on the first renderer call to retrieving this list. Use FontTableMatcher
+  // to perform searches in it. Retrieval may take up to several seconds if the
+  // table needs rebuilding on browser side.
+  GetUniqueNameLookupTable() =>
+  (mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
   // Locates a font family that is able to render the specified text using the
   // specified style. If successful, the family_index and family_name will
   // indicate which family in the system font collection can render the
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
index 103c6f3ffb493..05ec3e9d78176 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
@@ -10,6 +10,7 @@
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/metrics/histogram_macros.h"
+#include "mojo/public/mojom/base/shared_memory.mojom-blink.h"
 #include "skia/ext/font_utils.h"
 #include "third_party/blink/public/common/features.h"
 #include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
@@ -28,11 +29,14 @@ FontUniqueNameLookupWin::~FontUniqueNameLookupWin() = default;
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueName(
     const String& font_unique_name) {
-  return MatchUniqueNameSingleLookup(font_unique_name);
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups)
+    return MatchUniqueNameSingleLookup(font_unique_name);
+  return MatchUniqueNameLookupTable(font_unique_name);
 }
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
     const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups);
   base::File font_file;
   uint32_t ttc_index = 0;
 
@@ -45,6 +49,31 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
   return InstantiateFromFileAndTtcIndex(std::move(font_file), ttc_index);
 }
 
+sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameLookupTable(
+    const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  if (!IsFontUniqueNameLookupReadyForSyncLookup())
+    return nullptr;
+
+  std::optional<FontTableMatcher::MatchResult> match_result =
+      font_table_matcher_->MatchName(font_unique_name.Utf8());
+  if (!match_result)
+    return nullptr;
+
+  base::FilePath file_path =
+      base::FilePath::FromUTF8Unsafe(match_result->font_path.c_str());
+  return InstantiateFromPathAndTtcIndex(file_path, match_result->ttc_index);
+}
+
+// Used for font matching with table lookup case only.
+sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromPathAndTtcIndex(
+    base::FilePath font_file_path,
+    uint32_t ttc_index) {
+  return SkTypeface::MakeFromFile(font_file_path.AsUTF8Unsafe().c_str(),
+                                  ttc_index);
+}
+
 // Used for font matching with single lookup case only.
 sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
     base::File file_handle,
@@ -63,13 +92,52 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
 }
 
 bool FontUniqueNameLookupWin::IsFontUniqueNameLookupReadyForSyncLookup() {
-  if (!RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
+  if (!RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled())
     return true;
-  }
 
   EnsureServiceConnected();
 
-  return true;
+  if (!lookup_mode_.has_value()) {
+    blink::mojom::UniqueFontLookupMode lookup_mode_from_mojo;
+    service_->GetUniqueFontLookupMode(&lookup_mode_from_mojo);
+    lookup_mode_ = lookup_mode_from_mojo;
+  }
+
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups) {
+    return true;
+  }
+
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  // If we have the table already, we're ready for sync lookups.
+  if (font_table_matcher_.get())
+    return true;
+
+  // We have previously determined via IPC whether the table is sync available.
+  // Return what we found out before.
+  if (sync_available_.has_value())
+    return sync_available_.value();
+
+  // If we haven't asked the browser before, probe synchronously - if the table
+  // is available on the browser side, we can continue with sync operation.
+
+  bool sync_available_from_mojo = false;
+  base::ReadOnlySharedMemoryRegion shared_memory_region;
+  service_->GetUniqueNameLookupTableIfAvailable(&sync_available_from_mojo,
+                                                &shared_memory_region);
+  sync_available_ = sync_available_from_mojo;
+
+  if (*sync_available_) {
+    // Adopt the shared memory region, do not notify anyone in callbacks as
+    // PrepareFontUniqueNameLookup must not have been called yet. Just return
+    // true from this function.
+    DCHECK_EQ(pending_callbacks_.size(), 0u);
+    ReceiveReadOnlySharedMemoryRegion(std::move(shared_memory_region));
+  }
+
+  // If it wasn't available synchronously LocalFontFaceSource has to call
+  // PrepareFontUniqueNameLookup.
+  return *sync_available_;
 }
 
 void FontUniqueNameLookupWin::EnsureServiceConnected() {
@@ -79,11 +147,66 @@ void FontUniqueNameLookupWin::EnsureServiceConnected() {
       service_.BindNewPipeAndPassReceiver());
 }
 
+void FontUniqueNameLookupWin::PrepareFontUniqueNameLookup(
+    NotifyFontUniqueNameLookupReady callback) {
+  DCHECK(!font_table_matcher_.get());
+  DCHECK(RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled());
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  pending_callbacks_.push_back(std::move(callback));
+
+  // We bind the service on the first call to PrepareFontUniqueNameLookup. After
+  // that we do not need to make additional IPC requests to retrieve the table.
+  // The observing callback was added to the list, so all clients will be
+  // informed when the lookup table has arrived.
+  if (pending_callbacks_.size() > 1)
+    return;
+
+  EnsureServiceConnected();
+
+  service_->GetUniqueNameLookupTable(base::BindOnce(
+      &FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion,
+      base::Unretained(this)));
+}
+
 void FontUniqueNameLookupWin::Init() {
   if (!base::FeatureList::IsEnabled(features::kPrefetchFontLookupTables))
     return;
 
   EnsureServiceConnected();
+
+  if (lookup_mode_.has_value()) {
+    InitWithLookupMode(lookup_mode_.value());
+    return;
+  }
+
+  service_->GetUniqueFontLookupMode(base::BindOnce(
+      &FontUniqueNameLookupWin::InitWithLookupMode, base::Unretained(this)));
+}
+
+void FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion(
+    base::ReadOnlySharedMemoryRegion shared_memory_region) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+  font_table_matcher_ =
+      std::make_unique<FontTableMatcher>(shared_memory_region.Map());
+  while (!pending_callbacks_.empty()) {
+    NotifyFontUniqueNameLookupReady callback = pending_callbacks_.TakeFirst();
+    std::move(callback).Run();
+  }
+}
+
+void FontUniqueNameLookupWin::InitWithLookupMode(
+    blink::mojom::UniqueFontLookupMode lookup_mode) {
+  lookup_mode_ = lookup_mode;
+
+  if (!font_table_matcher_.get() &&
+      RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled() &&
+      lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable) {
+    // This call primes IsFontUniqueNameLookupReadyForSyncLookup() by
+    // asynchronously fetching the font table so it will be ready when needed.
+    // It isn't needed now, so base::DoNothing() is passed as the callback.
+    PrepareFontUniqueNameLookup(base::DoNothing());
+  }
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
index fe321a0189302..45a38a913ebd3 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
@@ -14,8 +14,14 @@
 namespace blink {
 
 // Performs the IPC towards the browser process for font unique name
-// matching. Direct individual sync Mojo IPC calls are made to lookup fonts,
-// and the class reponds synchronously.
+// matching. This class operates in one of two lookup modes, depending on
+// lookup_mode_. On Windows 10 or when IDWriteFontFactory3 is available, direct
+// individual sync Mojo IPC calls are made too lookup fonts - and the class
+// reponds synchronously.  On Windows 7 & 8, a shared memory region is retrieved
+// asynchronously, then lookups are performed against that table. When the
+// asynchronous request to retrieve the table completes, the clients are
+// notified. And once the table was retrieved, this class returns to operating
+// in synchronous mode as matching can be performed instantly.
 class FontUniqueNameLookupWin : public FontUniqueNameLookup {
  public:
   FontUniqueNameLookupWin();
@@ -26,19 +32,31 @@ class FontUniqueNameLookupWin : public FontUniqueNameLookup {
 
   bool IsFontUniqueNameLookupReadyForSyncLookup() override;
 
+  void PrepareFontUniqueNameLookup(
+      NotifyFontUniqueNameLookupReady callback) override;
+
   void Init() override;
 
  private:
   void EnsureServiceConnected();
 
+  sk_sp<SkTypeface> MatchUniqueNameLookupTable(const String& font_unique_name);
   sk_sp<SkTypeface> MatchUniqueNameSingleLookup(const String& font_unique_name);
 
+  sk_sp<SkTypeface> InstantiateFromPathAndTtcIndex(
+      base::FilePath font_file_path,
+      uint32_t ttc_index);
   sk_sp<SkTypeface> InstantiateFromFileAndTtcIndex(base::File file_handle,
                                                    uint32_t ttc_index);
 
+  void InitWithLookupMode(blink::mojom::UniqueFontLookupMode lookup_mode);
+
   mojo::Remote<mojom::blink::DWriteFontProxy> service_;
   WTF::Deque<NotifyFontUniqueNameLookupReady> pending_callbacks_;
+  std::optional<blink::mojom::UniqueFontLookupMode> lookup_mode_;
   std::optional<bool> sync_available_;
+  void ReceiveReadOnlySharedMemoryRegion(
+      base::ReadOnlySharedMemoryRegion shared_memory_region);
 };
 
 }  // namespace blink
