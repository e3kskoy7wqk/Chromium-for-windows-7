diff --git a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
index 23d324460ad28..c34e3aab4eeb3 100644
--- a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
+++ b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
@@ -27,111 +27,216 @@
 #include "ui/views/views_features.h"
 
 namespace {
+// This class encapsulates much of the same logic from ThemeHelperWin pertaining
+// to the calculation of frame colors on Windows 8, 10 and up. Once the
+// ColorProvider is permanently switched on, all the relevant code from
+// ThemeHelperWin can be deleted.
+class FrameColorHelper {
+ public:
+  FrameColorHelper();
+  FrameColorHelper(const FrameColorHelper&) = delete;
+  FrameColorHelper& operator=(const FrameColorHelper&) = delete;
+  ~FrameColorHelper() = default;
 
-color_utils::HSL GetTint(int id, const ui::ColorProviderKey& key) {
-  const color_utils::HSL default_tint = ThemeProperties::GetDefaultTint(
-      id,
-      // The `ColorProviderKey` does not provide separate incognito state, but
-      // the color mode will be dark in that case.
-      // TODO(pkasting): `ThemeService`/`ThemeProperties` plumbing incognito and
-      // dark mode separately is largely a broken relic at this point, and
-      // various callers already conflate the two in both directions. The
-      // "incognito" concept should probably be purged from all that code, and
-      // for the very few places that make a distinction (e.g. frame tints) we
-      // should just pick which behavior we want.
-      false, key.color_mode == ui::ColorProviderKey::ColorMode::kDark);
-
-  color_utils::HSL custom_tint;
-  return (key.custom_theme && key.custom_theme->GetTint(id, &custom_tint))
-             ? custom_tint
-             : default_tint;
-}
+  void AddNativeChromeColors(ui::ColorMixer& mixer,
+                             const ui::ColorProviderKey& key) const;
+  void AddBorderAccentColors(ui::ColorMixer& mixer) const;
 
-std::optional<SkColor> GetThemeColor(const ui::ColorProviderKey& key, int id) {
-  SkColor theme_color;
-  return (key.custom_theme && key.custom_theme->GetColor(id, &theme_color))
-             ? std::make_optional(theme_color)
-             : std::nullopt;
-}
+  static FrameColorHelper* Get();
+
+ private:
+  // Returns the Tint for the given |id|. If there is no tint, the identity tint
+  // {-1, -1, -1} is returned and won't tint the color on which it is used.
+  color_utils::HSL GetTint(int id, const ui::ColorProviderKey& key) const;
+
+  // Callback executed when the accent color is updated. This re-reads the
+  // accent color and updates |dwm_frame_color_| and
+  // |dwm_inactive_frame_color_|.
+  void OnAccentColorUpdated();
+
+  // Re-reads the accent colors and updates member variables.
+  void FetchAccentColors();
+
+  base::CallbackListSubscription subscription_ =
+      ui::AccentColorObserver::Get()->Subscribe(
+          base::BindRepeating(&FrameColorHelper::OnAccentColorUpdated,
+                              base::Unretained(this)));
+
+  // The frame color when active. If empty the default colors should be used.
+  std::optional<SkColor> dwm_frame_color_;
+
+  // The frame color when inactive. If empty the default colors should be used.
+  std::optional<SkColor> dwm_inactive_frame_color_;
 
-struct FrameTransforms {
-  std::optional<ui::ColorTransform> active;
-  std::optional<ui::ColorTransform> inactive;
+  // The DWM accent border color, if available; white otherwise.
+  SkColor dwm_accent_border_color_ = SK_ColorWHITE;
 };
 
-FrameTransforms GetMicaFrameTransforms(const ui::ColorProviderKey& key) {
-  const auto mica_frame_color =
-      (key.color_mode == ui::ColorProviderKey::ColorMode::kDark)
-          ? SkColorSetRGB(0x20, 0x20, 0x20)
-          : SkColorSetRGB(0xE8, 0xE8, 0xE8);
-  return {mica_frame_color, mica_frame_color};
+FrameColorHelper::FrameColorHelper() {
+  FetchAccentColors();
 }
 
-FrameTransforms GetSystemFrameTransforms(const ui::ColorProviderKey& key) {
-  FrameTransforms frame_transforms;
-  if (ShouldDefaultThemeUseMicaTitlebar()) {
-    frame_transforms = GetMicaFrameTransforms(key);
+void FrameColorHelper::AddNativeChromeColors(
+    ui::ColorMixer& mixer,
+    const ui::ColorProviderKey& key) const {
+  using TP = ThemeProperties;
+  using ColorMode = ui::ColorProviderKey::ColorMode;
+
+  auto get_theme_color = [key](int id) -> std::optional<SkColor> {
+    SkColor theme_color;
+    if (key.custom_theme && key.custom_theme->GetColor(id, &theme_color)) {
+      return theme_color;
+    }
+    return std::nullopt;
+  };
+
+  // When we're custom-drawing the titlebar we want to use either the colors
+  // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
+  // custom-drawing the titlebar we want to match the color Windows actually
+  // uses because some things (like the incognito icon) use this color to
+  // decide whether they should draw in light or dark mode. Incognito colors
+  // should be the same as non-incognito in all cases here.
+
+  constexpr SkColor kSystemMicaLightFrameColor =
+      SkColorSetRGB(0xE8, 0xE8, 0xE8);
+  constexpr SkColor kSystemMicaDarkFrameColor = SkColorSetRGB(0x20, 0x20, 0x20);
+
+  // We should only attempt to paint system-style frames if configured to do so
+  // in the key.
+  const bool use_native_colors =
+      (key.frame_type == ui::ColorProviderKey::FrameType::kChromium &&
+       key.frame_style == ui::ColorProviderKey::FrameStyle::kSystem);
+
+  std::optional<ui::ColorTransform> active_frame_transform;
+  if (auto color = get_theme_color(TP::COLOR_FRAME_ACTIVE)) {
+    active_frame_transform = {color.value()};
+  } else if (use_native_colors) {
+    if (dwm_frame_color_) {
+      active_frame_transform = {dwm_frame_color_.value()};
+    } else if (ShouldDefaultThemeUseMicaTitlebar()) {
+      active_frame_transform = {key.color_mode == ColorMode::kDark
+                                    ? kSystemMicaDarkFrameColor
+                                    : kSystemMicaLightFrameColor};
+    }
   }
-  const auto* const accent_color_observer = ui::AccentColorObserver::Get();
-  if (const std::optional<SkColor> dwm_frame_color =
-          accent_color_observer->accent_color()) {
-    frame_transforms.active = {dwm_frame_color.value()};
-    const std::optional<SkColor> dwm_inactive_frame_color =
-        accent_color_observer->accent_color_inactive();
-    frame_transforms.inactive =
-        dwm_inactive_frame_color.has_value()
-            ? ui::ColorTransform(dwm_inactive_frame_color.value())
-            : ui::HSLShift({dwm_frame_color.value()},
-                           GetTint(ThemeProperties::TINT_FRAME_INACTIVE, key));
+
+  std::optional<ui::ColorTransform> inactive_frame_transform;
+  if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE)) {
+    inactive_frame_transform = {color.value()};
+  } else if (use_native_colors) {
+    if (dwm_inactive_frame_color_) {
+      inactive_frame_transform = {dwm_inactive_frame_color_.value()};
+    } else if (dwm_frame_color_) {
+      inactive_frame_transform =
+          ui::HSLShift({dwm_frame_color_.value()},
+                       GetTint(ThemeProperties::TINT_FRAME_INACTIVE, key));
+    } else if (ShouldDefaultThemeUseMicaTitlebar()) {
+      inactive_frame_transform = {key.color_mode == ColorMode::kDark
+                                      ? kSystemMicaDarkFrameColor
+                                      : kSystemMicaLightFrameColor};
+    }
   }
-  return frame_transforms;
-}
 
-FrameTransforms GetFrameTransforms(const ui::ColorProviderKey& key) {
-  FrameTransforms frame_transforms;
-  if (key.frame_style == ui::ColorProviderKey::FrameStyle::kSystem) {
-    frame_transforms = GetSystemFrameTransforms(key);
+  // If setting custom window frame colors ensure we also update the
+  // corresponding sys header colors. Although this diverges from chrome's
+  // material spec these overrides are necessary to ensure UI assigned to these
+  // color roles can continue to work as expected while respecting platform
+  // frame overrides.
+  if (active_frame_transform) {
+    mixer[ui::kColorFrameActive] = active_frame_transform.value();
+    mixer[ui::kColorSysHeader] = active_frame_transform.value();
+    mixer[ui::kColorSysOnHeaderDivider] =
+        GetColorWithMaxContrast(ui::kColorSysHeader);
+    mixer[ui::kColorSysOnHeaderPrimary] =
+        GetColorWithMaxContrast(ui::kColorSysHeader);
+    mixer[ui::kColorSysStateHeaderHover] =
+        ui::AlphaBlend(ui::kColorSysBase, ui::kColorSysHeader,
+                       /* 40% opacity */ 0.4 * SK_AlphaOPAQUE);
+    mixer[ui::kColorSysHeaderContainer] = {ui::kColorSysBase};
   }
-  if (auto color = GetThemeColor(key, ThemeProperties::COLOR_FRAME_ACTIVE)) {
-    frame_transforms.active = {color.value()};
+  if (inactive_frame_transform) {
+    mixer[ui::kColorFrameInactive] = inactive_frame_transform.value();
+    mixer[ui::kColorSysHeaderInactive] = inactive_frame_transform.value();
+    mixer[ui::kColorSysOnHeaderDividerInactive] =
+        GetColorWithMaxContrast(ui::kColorSysHeaderInactive);
+    mixer[ui::kColorSysOnHeaderPrimaryInactive] =
+        GetColorWithMaxContrast(ui::kColorSysHeaderInactive);
+    mixer[ui::kColorSysStateHeaderHoverInactive] =
+        ui::AlphaBlend(ui::kColorSysBase, ui::kColorSysHeaderInactive,
+                       /* 40% opacity */ 0.4 * SK_AlphaOPAQUE);
+    mixer[ui::kColorSysHeaderContainerInactive] = {ui::kColorSysBase};
   }
-  if (auto color = GetThemeColor(key, ThemeProperties::COLOR_FRAME_INACTIVE)) {
-    frame_transforms.inactive = {color.value()};
+
+  if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+    mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
+    mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
+    mixer[kColorNewTabButtonInkDropFrameActive] =
+        ui::GetColorWithMaxContrast(ui::kColorFrameActive);
+    mixer[kColorNewTabButtonInkDropFrameInactive] =
+        ui::GetColorWithMaxContrast(ui::kColorFrameInactive);
   }
-  return frame_transforms;
 }
 
-// Updates the NativeTheme's user_color to reflect the system accent color.
-// TODO(crbug.com/40280436): Explore moving logic into NativeThemeWin.
-void UpdateUserColor() {
-  const auto accent_color = ui::AccentColorObserver::Get()->accent_color();
-  ui::NativeTheme::GetInstanceForNativeUi()->set_user_color(accent_color);
-  ui::NativeTheme::GetInstanceForWeb()->set_user_color(accent_color);
+void FrameColorHelper::AddBorderAccentColors(ui::ColorMixer& mixer) const {
+  // In Windows 10, native inactive borders are #555555 with 50% alpha.
+  // Prior to version 1809, native active borders use the accent color.
+  // In version 1809 and following, the active border is #262626 with 66%
+  // alpha unless the accent color is also used for the frame.
+  mixer[kColorAccentBorderActive] = {
+      (base::win::GetVersion() >= base::win::Version::WIN10_RS5 &&
+       !dwm_frame_color_)
+          ? SkColorSetARGB(0xa8, 0x26, 0x26, 0x26)
+          : dwm_accent_border_color_};
+  mixer[kColorAccentBorderInactive] = {SkColorSetARGB(0x80, 0x55, 0x55, 0x55)};
+}
+
+// static
+FrameColorHelper* FrameColorHelper::Get() {
+  static base::NoDestructor<FrameColorHelper> g_frame_color_helper;
+  return g_frame_color_helper.get();
+}
+
+color_utils::HSL FrameColorHelper::GetTint(
+    int id,
+    const ui::ColorProviderKey& key) const {
+  color_utils::HSL hsl;
+  if (key.custom_theme && key.custom_theme->GetTint(id, &hsl)) {
+    return hsl;
+  }
+  // Always pass false for |incognito| here since the ColorProvider is treating
+  // incognito mode as dark mode. If this needs to change, that information will
+  // need to propagate into the ColorProviderKey.
+  return ThemeProperties::GetDefaultTint(
+      id, false, key.color_mode == ui::ColorProviderKey::ColorMode::kDark);
 }
 
-void OnAccentColorUpdated() {
-  UpdateUserColor();
+void FrameColorHelper::OnAccentColorUpdated() {
+  FetchAccentColors();
   ui::NativeTheme::GetInstanceForNativeUi()->NotifyOnNativeThemeUpdated();
   ui::NativeTheme::GetInstanceForWeb()->NotifyOnNativeThemeUpdated();
 }
 
-void UpdateUserColorWhenAccentColorStateChanges() {
-  UpdateUserColor();
-  static base::NoDestructor<base::CallbackListSubscription> subscription(
-      ui::AccentColorObserver::Get()->Subscribe(
-          base::BindRepeating(&OnAccentColorUpdated)));
-}
+void FrameColorHelper::FetchAccentColors() {
+  // Update the NativeTheme's user_color to reflect the system accent color.
+  // TODO(crbug.com/40280436): Explore moving FrameColorHelper logic into
+  // NativeThemeWin.
+  const auto* accent_color_observer = ui::AccentColorObserver::Get();
+  const auto accent_color = accent_color_observer->accent_color();
+  ui::NativeTheme::GetInstanceForNativeUi()->set_user_color(accent_color);
+  ui::NativeTheme::GetInstanceForWeb()->set_user_color(accent_color);
 
-SkColor GetAccentBorderColor() {
-  if (const std::optional<SkColor> accent_border_color =
-          ui::AccentColorObserver::Get()->accent_border_color()) {
-    return accent_border_color.value();
+  if (!accent_color_observer->use_dwm_frame_color()) {
+    dwm_accent_border_color_ = SK_ColorWHITE;
+    dwm_frame_color_.reset();
+    dwm_inactive_frame_color_.reset();
+    return;
   }
 
-  // Windows 10 pre-version 1809 native active borders default to white, while
-  // in version 1809 and onwards they default to #262626 with 66% alpha.
-  const bool pre_1809 = base::win::GetVersion() < base::win::Version::WIN10_RS5;
-  return pre_1809 ? SK_ColorWHITE : SkColorSetARGB(0xa8, 0x26, 0x26, 0x26);
+  dwm_accent_border_color_ =
+      accent_color_observer->accent_border_color().value_or(SK_ColorWHITE);
+
+  dwm_frame_color_ = accent_color;
+  dwm_inactive_frame_color_ = accent_color_observer->accent_color_inactive();
 }
 
 ui::ColorTransform GetCaptionForegroundColor(
@@ -152,7 +257,44 @@ ui::ColorTransform GetCaptionForegroundColor(
   return base::BindRepeating(generator, std::move(input_transform));
 }
 
-void AddNativeHighContrastColors(ui::ColorMixer& mixer) {
+}  // namespace
+
+void AddNativeChromeColorMixer(ui::ColorProvider* provider,
+                               const ui::ColorProviderKey& key) {
+  ui::ColorMixer& mixer = provider->AddMixer();
+
+  // NOTE: These cases are always handled, even on Win7, in order to ensure the
+  // the color provider redirection tests function. Win7 callers should never
+  // actually pass in these IDs.
+  FrameColorHelper::Get()->AddBorderAccentColors(mixer);
+
+  mixer[kColorCaptionButtonForegroundActive] =
+      GetCaptionForegroundColor(kColorWindowControlButtonBackgroundActive);
+  mixer[kColorCaptionButtonForegroundInactive] =
+      GetCaptionForegroundColor(kColorWindowControlButtonBackgroundInactive);
+  mixer[kColorCaptionCloseButtonBackgroundHovered] = {
+      SkColorSetRGB(0xE8, 0x11, 0x23)};
+  mixer[kColorCaptionCloseButtonForegroundHovered] = {SK_ColorWHITE};
+  mixer[kColorCaptionForegroundActive] =
+      GetCaptionForegroundColor(ui::kColorFrameActive);
+  mixer[kColorCaptionForegroundInactive] =
+      SetAlpha(GetCaptionForegroundColor(ui::kColorFrameInactive), 0x66);
+  mixer[kColorTabSearchCaptionButtonFocusRing] = ui::PickGoogleColor(
+      ui::kColorFocusableBorderFocused, ui::kColorFrameActive,
+      color_utils::kMinimumVisibleContrastRatio);
+
+  if (key.color_mode == ui::ColorProviderKey::ColorMode::kLight) {
+    mixer[kColorNewTabPageBackground] = {ui::kColorNativeWindow};
+    mixer[kColorNewTabPageLink] = {ui::kColorNativeHotlight};
+    mixer[kColorNewTabPageText] = {ui::kColorNativeWindowText};
+  }
+
+  if (key.contrast_mode != ui::ColorProviderKey::ContrastMode::kHigh) {
+    FrameColorHelper::Get()->AddNativeChromeColors(mixer, key);
+    return;
+  }
+
+  // High contrast uses system colors.
   mixer[kColorInfoBarContentAreaSeparator] = {
       kColorToolbarContentAreaSeparator};
   mixer[kColorLocationBarBorder] = {ui::kColorNativeWindowText};
@@ -203,10 +345,11 @@ void AddNativeHighContrastColors(ui::ColorMixer& mixer) {
   mixer[kColorToolbarButtonIcon] = {kColorToolbarText};
   const bool platform_high_contrast_ink_drop = base::FeatureList::IsEnabled(
       views::features::kEnablePlatformHighContrastInkDrop);
-  mixer[kColorToolbarButtonIconHovered] = {
-      platform_high_contrast_ink_drop
-          ? ui::ColorId{ui::kColorNativeHighlightText}
-          : kColorToolbarText};
+  if (platform_high_contrast_ink_drop) {
+    mixer[kColorToolbarButtonIconHovered] = {ui::kColorNativeHighlightText};
+  } else {
+    mixer[kColorToolbarButtonIconHovered] = {kColorToolbarText};
+  }
   mixer[kColorToolbarButtonIconInactive] = {ui::kColorNativeGrayText};
   mixer[kColorToolbarContentAreaSeparator] = {kColorToolbarText};
   if (platform_high_contrast_ink_drop) {
@@ -218,82 +361,3 @@ void AddNativeHighContrastColors(ui::ColorMixer& mixer) {
   mixer[kColorToolbarTopSeparatorFrameInactive] = {
       kColorToolbarTopSeparatorFrameActive};
 }
-
-void AddNativeNonHighContrastColors(ui::ColorMixer& mixer,
-                                    const ui::ColorProviderKey& key) {
-  // Set frame colors appropriately.
-  //
-  // Instead of simply setting the frame colors directly, this sets the
-  // underlying header colors. Although this diverges from Chrome's material
-  // spec, these overrides are necessary to ensure UI assigned to these color
-  // roles can continue to work as expected while respecting platform frame
-  // overrides.
-  const FrameTransforms frame_transforms = GetFrameTransforms(key);
-  if (frame_transforms.active) {
-    mixer[ui::kColorSysHeader] = frame_transforms.active.value();
-    mixer[ui::kColorSysOnHeaderDivider] =
-        GetColorWithMaxContrast(ui::kColorSysHeader);
-    mixer[ui::kColorSysOnHeaderPrimary] =
-        GetColorWithMaxContrast(ui::kColorSysHeader);
-    mixer[ui::kColorSysStateHeaderHover] =
-        ui::AlphaBlend(ui::kColorSysBase, ui::kColorSysHeader, 0x66);
-    mixer[ui::kColorSysHeaderContainer] = {ui::kColorSysBase};
-  }
-  if (frame_transforms.inactive) {
-    mixer[ui::kColorSysHeaderInactive] = frame_transforms.inactive.value();
-    mixer[ui::kColorSysOnHeaderDividerInactive] =
-        GetColorWithMaxContrast(ui::kColorSysHeaderInactive);
-    mixer[ui::kColorSysOnHeaderPrimaryInactive] =
-        GetColorWithMaxContrast(ui::kColorSysHeaderInactive);
-    mixer[ui::kColorSysStateHeaderHoverInactive] =
-        ui::AlphaBlend(ui::kColorSysBase, ui::kColorSysHeaderInactive, 0x66);
-    mixer[ui::kColorSysHeaderContainerInactive] = {ui::kColorSysBase};
-  }
-
-  if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
-    mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonInkDropFrameActive] =
-        ui::GetColorWithMaxContrast(ui::kColorFrameActive);
-    mixer[kColorNewTabButtonInkDropFrameInactive] =
-        ui::GetColorWithMaxContrast(ui::kColorFrameInactive);
-  }
-}
-
-}  // namespace
-
-void AddNativeChromeColorMixer(ui::ColorProvider* provider,
-                               const ui::ColorProviderKey& key) {
-  UpdateUserColorWhenAccentColorStateChanges();
-
-  ui::ColorMixer& mixer = provider->AddMixer();
-
-  mixer[kColorAccentBorderActive] = {GetAccentBorderColor()};
-  mixer[kColorAccentBorderInactive] = {SkColorSetARGB(0x80, 0x55, 0x55, 0x55)};
-  mixer[kColorCaptionButtonForegroundActive] =
-      GetCaptionForegroundColor(kColorWindowControlButtonBackgroundActive);
-  mixer[kColorCaptionButtonForegroundInactive] =
-      GetCaptionForegroundColor(kColorWindowControlButtonBackgroundInactive);
-  mixer[kColorCaptionCloseButtonBackgroundHovered] = {
-      SkColorSetRGB(0xE8, 0x11, 0x23)};
-  mixer[kColorCaptionCloseButtonForegroundHovered] = {SK_ColorWHITE};
-  mixer[kColorCaptionForegroundActive] =
-      GetCaptionForegroundColor(ui::kColorFrameActive);
-  mixer[kColorCaptionForegroundInactive] =
-      SetAlpha(GetCaptionForegroundColor(ui::kColorFrameInactive), 0x66);
-  mixer[kColorTabSearchCaptionButtonFocusRing] = ui::PickGoogleColor(
-      ui::kColorFocusableBorderFocused, ui::kColorFrameActive,
-      color_utils::kMinimumVisibleContrastRatio);
-
-  if (key.color_mode == ui::ColorProviderKey::ColorMode::kLight) {
-    mixer[kColorNewTabPageBackground] = {ui::kColorNativeWindow};
-    mixer[kColorNewTabPageLink] = {ui::kColorNativeHotlight};
-    mixer[kColorNewTabPageText] = {ui::kColorNativeWindowText};
-  }
-
-  if (key.contrast_mode == ui::ColorProviderKey::ContrastMode::kHigh) {
-    AddNativeHighContrastColors(mixer);
-  } else {
-    AddNativeNonHighContrastColors(mixer, key);
-  }
-}
diff --git a/chrome/browser/win/mica_titlebar.cc b/chrome/browser/win/mica_titlebar.cc
index 2834e858a7e7e..57b359792e10c 100644
--- a/chrome/browser/win/mica_titlebar.cc
+++ b/chrome/browser/win/mica_titlebar.cc
@@ -4,8 +4,6 @@
 
 #include "chrome/browser/win/mica_titlebar.h"
 
-#include <optional>
-
 #include "base/win/windows_version.h"
 #include "ui/color/win/accent_color_observer.h"
 #include "ui/native_theme/native_theme.h"
@@ -18,7 +16,7 @@ BASE_FEATURE(kWindows11MicaTitlebar,
 
 bool ShouldDefaultThemeUseMicaTitlebar() {
   return SystemTitlebarCanUseMicaMaterial() &&
-         !ui::AccentColorObserver::Get()->accent_color().has_value() &&
+         !ui::AccentColorObserver::Get()->use_dwm_frame_color() &&
          ui::NativeTheme::GetInstanceForNativeUi()->GetPreferredContrast() ==
              ui::NativeTheme::PreferredContrast::kNoPreference;
 }
diff --git a/ui/color/win/accent_color_observer.cc b/ui/color/win/accent_color_observer.cc
index b91bef73ba7e7..547c89daafe6b 100644
--- a/ui/color/win/accent_color_observer.cc
+++ b/ui/color/win/accent_color_observer.cc
@@ -39,58 +39,22 @@ base::CallbackListSubscription AccentColorObserver::Subscribe(
 void AccentColorObserver::SetAccentColorForTesting(
     std::optional<SkColor> accent_color) {
   accent_color_ = accent_color;
-  if (!accent_color_.has_value()) {
-    // Maintain invariant that a null accent color implies null other colors.
-    accent_color_inactive_.reset();
-    accent_border_color_.reset();
-  }
   callbacks_.Notify();
 }
 
-void AccentColorObserver::OnDwmKeyUpdated() {
-  UpdateAccentColors();
+void AccentColorObserver::SetUseDwmFrameColorForTesting(
+    bool use_dwm_frame_color) {
+  use_dwm_frame_color_ = use_dwm_frame_color;
   callbacks_.Notify();
-
-  // Watch for future changes. If there is no task runner, this is a test or
-  // tool context and watching is unnecessary.
-  if (!base::SequencedTaskRunner::HasCurrentDefault() ||
-      !dwm_key_->StartWatching(base::BindOnce(
-          &AccentColorObserver::OnDwmKeyUpdated, base::Unretained(this)))) {
-    dwm_key_.reset();
-  }
 }
 
-void AccentColorObserver::UpdateAccentColors() {
-  // Ignore accent colors unless color prevalence is enabled.
-  accent_color_.reset();
-  accent_color_inactive_.reset();
-  accent_border_color_.reset();
-  if (DWORD color_prevalence = 0;
-      dwm_key_->ReadValueDW(L"ColorPrevalence", &color_prevalence) !=
-          ERROR_SUCCESS ||
-      color_prevalence != 1) {
-    return;
-  }
-
-  if (DWORD accent_color = 0;
-      dwm_key_->ReadValueDW(L"AccentColor", &accent_color) == ERROR_SUCCESS) {
-    accent_color_ = skia::COLORREFToSkColor(accent_color);
-  } else {
-    // When there is no accent color, ignore inactive/border colors.
-    return;
-  }
-
-  if (DWORD accent_color_inactive = 0;
-      dwm_key_->ReadValueDW(L"AccentColorInactive", &accent_color_inactive) ==
-      ERROR_SUCCESS) {
-    accent_color_inactive_ = skia::COLORREFToSkColor(accent_color_inactive);
-  }
-
-  if (DWORD colorization_color, colorization_color_balance;
-      dwm_key_->ReadValueDW(L"ColorizationColor", &colorization_color) ==
-          ERROR_SUCCESS &&
-      dwm_key_->ReadValueDW(L"ColorizationColorBalance",
-                            &colorization_color_balance) == ERROR_SUCCESS) {
+void AccentColorObserver::OnDwmKeyUpdated() {
+  accent_border_color_ = std::nullopt;
+  DWORD colorization_color, colorization_color_balance;
+  if ((dwm_key_->ReadValueDW(L"ColorizationColor", &colorization_color) ==
+       ERROR_SUCCESS) &&
+      (dwm_key_->ReadValueDW(L"ColorizationColorBalance",
+                             &colorization_color_balance) == ERROR_SUCCESS)) {
     // The accent border color is a linear blend between the colorization
     // color and the neutral #d9d9d9. colorization_color_balance is the
     // percentage of the colorization color in that blend.
@@ -112,6 +76,35 @@ void AccentColorObserver::UpdateAccentColors() {
         color_utils::AlphaBlend(input_color, SkColorSetRGB(0xd9, 0xd9, 0xd9),
                                 colorization_color_balance / 100.0f);
   }
+
+  accent_color_ = std::nullopt;
+  accent_color_inactive_ = std::nullopt;
+  DWORD accent_color = 0;
+  if (dwm_key_->ReadValueDW(L"AccentColor", &accent_color) == ERROR_SUCCESS) {
+    accent_color_ = skia::COLORREFToSkColor(accent_color);
+    DWORD accent_color_inactive = 0;
+    if (dwm_key_->ReadValueDW(L"AccentColorInactive", &accent_color_inactive) ==
+        ERROR_SUCCESS) {
+      accent_color_inactive_ = skia::COLORREFToSkColor(accent_color_inactive);
+    }
+  }
+
+  DWORD color_prevalence;
+  use_dwm_frame_color_ =
+      accent_color_.has_value() &&
+      (dwm_key_->ReadValueDW(L"ColorPrevalence", &color_prevalence) ==
+       ERROR_SUCCESS) &&
+      color_prevalence == 1;
+
+  callbacks_.Notify();
+
+  // Watch for future changes. If there is no task runner, this is a test or
+  // tool context and watching is unnecessary.
+  if (!base::SequencedTaskRunner::HasCurrentDefault() ||
+      !dwm_key_->StartWatching(base::BindOnce(
+          &AccentColorObserver::OnDwmKeyUpdated, base::Unretained(this)))) {
+    dwm_key_.reset();
+  }
 }
 
 }  // namespace ui
diff --git a/ui/color/win/accent_color_observer.h b/ui/color/win/accent_color_observer.h
index d54271e433009..b0db595c07d57 100644
--- a/ui/color/win/accent_color_observer.h
+++ b/ui/color/win/accent_color_observer.h
@@ -30,8 +30,6 @@ class COMPONENT_EXPORT(COLOR) AccentColorObserver {
   // Registers `callback` to be called whenever the accent color changes.
   base::CallbackListSubscription Subscribe(base::RepeatingClosure callback);
 
-  // NOTE: If `accent_color()` does not contain a value, both other colors are
-  // guaranteed to also not contain values.
   std::optional<SkColor> accent_color() const { return accent_color_; }
   std::optional<SkColor> accent_color_inactive() const {
     return accent_color_inactive_;
@@ -39,14 +37,14 @@ class COMPONENT_EXPORT(COLOR) AccentColorObserver {
   std::optional<SkColor> accent_border_color() const {
     return accent_border_color_;
   }
+  bool use_dwm_frame_color() const { return use_dwm_frame_color_; }
 
   void SetAccentColorForTesting(std::optional<SkColor> accent_color);
+  void SetUseDwmFrameColorForTesting(bool use_dwm_frame_color);
 
  private:
   void OnDwmKeyUpdated();
 
-  void UpdateAccentColors();
-
   // Registry key containing the params that determine the accent color.
   std::unique_ptr<base::win::RegKey> dwm_key_;
 
@@ -54,6 +52,7 @@ class COMPONENT_EXPORT(COLOR) AccentColorObserver {
   std::optional<SkColor> accent_color_;
   std::optional<SkColor> accent_color_inactive_;
   std::optional<SkColor> accent_border_color_;
+  bool use_dwm_frame_color_ = false;
 };
 
 }  // namespace ui
diff --git a/ui/color/win/native_color_mixers_win.cc b/ui/color/win/native_color_mixers_win.cc
index 179dc53711ed9..c9cbe78804849 100644
--- a/ui/color/win/native_color_mixers_win.cc
+++ b/ui/color/win/native_color_mixers_win.cc
@@ -124,8 +124,10 @@ void AddNativeCoreColorMixer(ColorProvider* provider,
 
   // Use the system accent color as the Chrome accent color, if present and only
   // if dwm colors are enabled.
-  if (const std::optional<SkColor> accent_color =
-          AccentColorObserver::Get()->accent_color()) {
+  const auto* accent_color_observer = AccentColorObserver::Get();
+  const auto& accent_color = accent_color_observer->accent_color();
+  if (accent_color.has_value() &&
+      accent_color_observer->use_dwm_frame_color()) {
     mixer[kColorAccent] = PickGoogleColor(accent_color.value());
   }
 
