

diff --git a/device/BUILD.gn b/device/BUILD.gn
index 9ec1a1716cac7..3817dadfad69a 100644
--- a/device/BUILD.gn
+++ b/device/BUILD.gn
@@ -97,6 +97,7 @@ test("device_unittests") {
     sources += [
       "bluetooth/bluetooth_adapter_win_unittest.cc",
       "bluetooth/bluetooth_device_win_unittest.cc",
+      "bluetooth/bluetooth_low_energy_win_unittest.cc",
       "bluetooth/bluetooth_service_record_win_unittest.cc",
       "bluetooth/bluetooth_task_manager_win_unittest.cc",
       "bluetooth/test/bluetooth_test_win.cc",
diff --git a/device/bluetooth/BUILD.gn b/device/bluetooth/BUILD.gn
index ff6d030a46995..211926a87fd05 100644
--- a/device/bluetooth/BUILD.gn
+++ b/device/bluetooth/BUILD.gn
@@ -290,12 +290,22 @@ component("bluetooth") {
       "bluetooth_gatt_discoverer_winrt.h",
       "bluetooth_init_win.cc",
       "bluetooth_init_win.h",
+      "bluetooth_low_energy_defs_win.cc",
+      "bluetooth_low_energy_defs_win.h",
+      "bluetooth_low_energy_win.cc",
+      "bluetooth_low_energy_win.h",
       "bluetooth_pairing_winrt.cc",
       "bluetooth_pairing_winrt.h",
+      "bluetooth_remote_gatt_characteristic_win.cc",
+      "bluetooth_remote_gatt_characteristic_win.h",
       "bluetooth_remote_gatt_characteristic_winrt.cc",
       "bluetooth_remote_gatt_characteristic_winrt.h",
+      "bluetooth_remote_gatt_descriptor_win.cc",
+      "bluetooth_remote_gatt_descriptor_win.h",
       "bluetooth_remote_gatt_descriptor_winrt.cc",
       "bluetooth_remote_gatt_descriptor_winrt.h",
+      "bluetooth_remote_gatt_service_win.cc",
+      "bluetooth_remote_gatt_service_win.h",
       "bluetooth_remote_gatt_service_winrt.cc",
       "bluetooth_remote_gatt_service_winrt.h",
       "bluetooth_service_record_win.cc",
diff --git a/device/bluetooth/bluetooth_device_win.cc b/device/bluetooth/bluetooth_device_win.cc
index e73aea8745f89..91e53067efe0e 100644
--- a/device/bluetooth/bluetooth_device_win.cc
+++ b/device/bluetooth/bluetooth_device_win.cc
@@ -13,6 +13,7 @@
 #include "base/notreached.h"
 #include "base/task/sequenced_task_runner.h"
 #include "device/bluetooth/bluetooth_adapter_win.h"
+#include "device/bluetooth/bluetooth_remote_gatt_service_win.h"
 #include "device/bluetooth/bluetooth_service_record_win.h"
 #include "device/bluetooth/bluetooth_socket_thread.h"
 #include "device/bluetooth/bluetooth_socket_win.h"
@@ -39,7 +40,19 @@ BluetoothDeviceWin::BluetoothDeviceWin(
   Update(device_state);
 }
 
-BluetoothDeviceWin::~BluetoothDeviceWin() = default;
+BluetoothDeviceWin::~BluetoothDeviceWin() {
+  // Explicitly take and erase GATT services one by one to ensure that calling
+  // GetGattService on removed service in GattServiceRemoved returns null.
+  std::vector<std::string> service_keys;
+  for (const auto& gatt_service : gatt_services_) {
+    service_keys.push_back(gatt_service.first);
+  }
+  for (const auto& key : service_keys) {
+    std::unique_ptr<BluetoothRemoteGattService> service =
+        std::move(gatt_services_[key]);
+    gatt_services_.erase(key);
+  }
+}
 
 uint32_t BluetoothDeviceWin::GetBluetoothClass() const {
   return bluetooth_class_;
@@ -91,7 +104,9 @@ bool BluetoothDeviceWin::IsConnected() const {
 }
 
 bool BluetoothDeviceWin::IsGattConnected() const {
-  return false;
+  // If a BLE device is not GATT connected, Windows will automatically
+  // reconnect.
+  return is_low_energy_;
 }
 
 bool BluetoothDeviceWin::IsConnectable() const {
@@ -213,6 +228,7 @@ bool BluetoothDeviceWin::IsEqual(
       bluetooth_class_ != device_state.bluetooth_class ||
       visible_ != device_state.visible ||
       connected_ != device_state.connected ||
+      is_low_energy_ == device_state.is_bluetooth_classic() ||
       paired_ != device_state.authenticated) {
     return false;
   }
@@ -253,10 +269,26 @@ void BluetoothDeviceWin::Update(
   bluetooth_class_ = device_state.bluetooth_class;
   visible_ = device_state.visible;
   connected_ = device_state.connected;
+  is_low_energy_ = !device_state.is_bluetooth_classic();
   paired_ = device_state.authenticated;
   UpdateServices(device_state);
 }
 
+void BluetoothDeviceWin::GattServiceDiscoveryComplete(
+    BluetoothRemoteGattServiceWin* service) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  DCHECK(BluetoothDeviceWin::IsGattServiceDiscovered(
+      service->GetUUID(), service->GetAttributeHandle()));
+
+  discovery_completed_included_services_.insert(
+      {service->GetUUID(), service->GetAttributeHandle()});
+  if (discovery_completed_included_services_.size() != gatt_services_.size())
+    return;
+
+  SetGattServicesDiscoveryComplete(true);
+  adapter_->NotifyGattServicesDiscovered(this);
+}
+
 void BluetoothDeviceWin::CreateGattConnectionImpl(
     std::optional<BluetoothUUID> service_uuid) {
   // Windows will create the Gatt connection as needed.  See:
@@ -283,6 +315,83 @@ void BluetoothDeviceWin::UpdateServices(
     uuids_.insert(service_record->uuid());
     service_record_list_.push_back(std::move(service_record));
   }
+
+  if (!device_state.is_bluetooth_classic())
+    UpdateGattServices(device_state.service_record_states);
+}
+
+bool BluetoothDeviceWin::IsGattServiceDiscovered(const BluetoothUUID& uuid,
+                                                 uint16_t attribute_handle) {
+  for (const auto& gatt_service : gatt_services_) {
+    uint16_t it_att_handle =
+        static_cast<BluetoothRemoteGattServiceWin*>(gatt_service.second.get())
+            ->GetAttributeHandle();
+    BluetoothUUID it_uuid = gatt_service.second->GetUUID();
+    if (attribute_handle == it_att_handle && uuid == it_uuid) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool BluetoothDeviceWin::DoesGattServiceExist(
+    const std::vector<std::unique_ptr<
+        BluetoothTaskManagerWin::ServiceRecordState>>& service_state,
+    BluetoothRemoteGattService* service) {
+  uint16_t attribute_handle =
+      static_cast<BluetoothRemoteGattServiceWin*>(service)
+          ->GetAttributeHandle();
+  BluetoothUUID uuid = service->GetUUID();
+  for (const auto& record_state : service_state) {
+    if (attribute_handle == record_state->attribute_handle &&
+        uuid == record_state->gatt_uuid) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void BluetoothDeviceWin::UpdateGattServices(
+    const std::vector<
+        std::unique_ptr<BluetoothTaskManagerWin::ServiceRecordState>>&
+        service_state) {
+  // First, remove no longer existent GATT service.
+  {
+    std::vector<std::string> to_be_removed_services;
+    for (const auto& gatt_service : gatt_services_) {
+      if (!DoesGattServiceExist(service_state, gatt_service.second.get())) {
+        to_be_removed_services.push_back(gatt_service.first);
+      }
+    }
+    for (const auto& service : to_be_removed_services) {
+      std::unique_ptr<BluetoothRemoteGattService> service_ptr =
+          std::move(gatt_services_[service]);
+      gatt_services_.erase(service);
+    }
+    // Update previously discovered services.
+    for (const auto& gatt_service : gatt_services_) {
+      static_cast<BluetoothRemoteGattServiceWin*>(gatt_service.second.get())
+          ->Update();
+    }
+  }
+
+  // Return if no new services have been added.
+  if (gatt_services_.size() == service_state.size())
+    return;
+
+  // Add new services.
+  for (const auto& record_state : service_state) {
+    if (!IsGattServiceDiscovered(record_state->gatt_uuid,
+                                 record_state->attribute_handle)) {
+      BluetoothRemoteGattServiceWin* primary_service =
+          new BluetoothRemoteGattServiceWin(
+              this, record_state->path, record_state->gatt_uuid,
+              record_state->attribute_handle, true, nullptr, ui_task_runner_);
+      gatt_services_[primary_service->GetIdentifier()] =
+          base::WrapUnique(primary_service);
+      adapter_->NotifyGattServiceAdded(primary_service);
+    }
+  }
 }
 
 }  // namespace device
diff --git a/device/bluetooth/bluetooth_device_win.h b/device/bluetooth/bluetooth_device_win.h
index d9da38fced7b0..a6f1d5ad7aea8 100644
--- a/device/bluetooth/bluetooth_device_win.h
+++ b/device/bluetooth/bluetooth_device_win.h
@@ -21,6 +21,7 @@
 namespace device {
 
 class BluetoothAdapterWin;
+class BluetoothRemoteGattServiceWin;
 class BluetoothServiceRecordWin;
 class BluetoothSocketThread;
 class BluetoothUUID;
@@ -97,6 +98,10 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothDeviceWin
   // |device_state|.
   void Update(const BluetoothTaskManagerWin::DeviceState& device_state);
 
+  // Notify |service| discovery complete, |service| is a remote GATT service of
+  // this device.
+  void GattServiceDiscoveryComplete(BluetoothRemoteGattServiceWin* service);
+
  protected:
   // BluetoothDevice override
   void CreateGattConnectionImpl(
@@ -113,6 +118,24 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothDeviceWin
   // Updates the services with services stored in |device_state|.
   void UpdateServices(const BluetoothTaskManagerWin::DeviceState& device_state);
 
+  // Checks if GATT service with |uuid| and |attribute_handle| has already been
+  // discovered.
+  bool IsGattServiceDiscovered(const BluetoothUUID& uuid,
+                               uint16_t attribute_handle);
+
+  // Checks if |service| still exist on device according to newly discovered
+  // |service_state|.
+  bool DoesGattServiceExist(
+      const std::vector<std::unique_ptr<
+          BluetoothTaskManagerWin::ServiceRecordState>>& service_state,
+      BluetoothRemoteGattService* service);
+
+  // Updates the GATT services with the services stored in |service_state|.
+  void UpdateGattServices(
+      const std::vector<
+          std::unique_ptr<BluetoothTaskManagerWin::ServiceRecordState>>&
+          service_state);
+
   scoped_refptr<base::SequencedTaskRunner> ui_task_runner_;
   scoped_refptr<BluetoothSocketThread> socket_thread_;
 
@@ -130,6 +153,7 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothDeviceWin
   // the device.
   bool paired_;
   bool connected_;
+  bool is_low_energy_;
 
   // Used to send change notifications when a device disappears during
   // discovery.
@@ -140,6 +164,11 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothDeviceWin
 
   // The service records retrieved from SDP.
   std::vector<std::unique_ptr<BluetoothServiceRecordWin>> service_record_list_;
+
+  // The element of the set is the uuid / attribute handle pair of the
+  // BluetoothRemoteGattServiceWin instance.
+  std::set<std::pair<BluetoothUUID, uint16_t>>
+      discovery_completed_included_services_;
 };
 
 }  // namespace device
diff --git a/device/bluetooth/bluetooth_low_energy_defs_win.cc b/device/bluetooth/bluetooth_low_energy_defs_win.cc
new file mode 100644
index 0000000000000..5c8ec5186e7be
--- /dev/null
+++ b/device/bluetooth/bluetooth_low_energy_defs_win.cc
@@ -0,0 +1,9 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "device/bluetooth/bluetooth_low_energy_defs_win.h"
+
+#include <cfg.h>
+#define INITGUID  // For DEVPKEY_Xxxx guid/pid pairs
+#include <devpkey.h>
diff --git a/device/bluetooth/bluetooth_low_energy_defs_win.h b/device/bluetooth/bluetooth_low_energy_defs_win.h
new file mode 100644
index 0000000000000..32bcc1a979ae3
--- /dev/null
+++ b/device/bluetooth/bluetooth_low_energy_defs_win.h
@@ -0,0 +1,35 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef DEVICE_BLUETOOTH_BLUETOOTH_LOW_ENERGY_DEFS_WIN_H_
+#define DEVICE_BLUETOOTH_BLUETOOTH_LOW_ENERGY_DEFS_WIN_H_
+
+#include <windows.h>
+#include <cfg.h>
+#include <devpkey.h>
+#include <ntverp.h>  // For VER_PRODUCTBUILD
+#include <setupapi.h>
+
+#if VER_PRODUCTBUILD > 9600
+// bthledef.h is fixed in the Windows 10 SDK and the extra pop then triggers a
+// warning, so we skip it when VER_PRODUCTBUILD is > 9600 (8.1 SDK)
+#include <bthledef.h>
+#else
+#pragma warning(push)
+// bthledef.h in the Windows 8.1 SDK is buggy and contains
+//   #pragma pop
+// which should be
+//   #pragma warning(pop)
+// So, we disable the "unknown pragma" warning, then actually pop, and then pop
+// our disabling of 4068.
+#pragma warning(disable: 4068)
+#include <bthledef.h>
+#pragma warning(pop)
+#pragma warning(pop)
+#endif
+
+#include <bluetoothapis.h>
+#include <bluetoothleapis.h>
+
+#endif  // DEVICE_BLUETOOTH_BLUETOOTH_LOW_ENERGY_DEFS_WIN_H_
diff --git a/device/bluetooth/bluetooth_low_energy_win.cc b/device/bluetooth/bluetooth_low_energy_win.cc
new file mode 100644
index 0000000000000..fb640e4e46bea
--- /dev/null
+++ b/device/bluetooth/bluetooth_low_energy_win.cc
@@ -0,0 +1,827 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "device/bluetooth/bluetooth_low_energy_win.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "base/files/file.h"
+#include "base/lazy_instance.h"
+#include "base/logging.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/sys_string_conversions.h"
+#include "base/win/scoped_handle.h"
+#include "third_party/re2/src/re2/re2.h"
+
+namespace {
+
+using device::win::DeviceRegistryPropertyValue;
+using device::win::DevicePropertyValue;
+using device::win::BluetoothLowEnergyDeviceInfo;
+using device::win::BluetoothLowEnergyServiceInfo;
+
+const char kDeviceEnumError[] = "Error enumerating Bluetooth LE devices.";
+const char kDeviceInfoError[] =
+    "Error retrieving Bluetooth LE device information.";
+const char kDeviceAddressError[] =
+    "Device instance ID value does not seem to contain a Bluetooth Adapter "
+    "address.";
+const char kDeviceFriendlyNameError[] = "Device name is not valid.";
+const char kInvalidBluetoothAddress[] = "Bluetooth address format is invalid.";
+struct Patterns {
+  Patterns();
+  // Patterns is only instantiated as a leaky LazyInstance, so the destructor
+  // is never called.
+  ~Patterns() = delete;
+  const RE2 address_regex;
+};
+
+Patterns::Patterns()
+    // Match an embedded MAC address in a device path.
+    // e.g.
+    // BTHLEDEVICE\{0000180F-0000-1000-8000-00805F9B34FB}_DEV_VID&01000A_PID&
+    //   014C_REV&0100_818B4B0BACE6\8&4C387F7&0&0020
+    // matches _818B4B0BACE6\
+    // and the 12 hex digits are selected in a capture group.
+    : address_regex(R"(_([0-9A-F]{12})\\)") {}
+
+base::LazyInstance<Patterns>::Leaky g_patterns = LAZY_INSTANCE_INITIALIZER;
+
+// Like ScopedHandle but for HDEVINFO.  Only use this on HDEVINFO returned from
+// SetupDiGetClassDevs.
+class DeviceInfoSetTraits {
+ public:
+  typedef HDEVINFO Handle;
+
+  DeviceInfoSetTraits() = delete;
+  DeviceInfoSetTraits(const DeviceInfoSetTraits&) = delete;
+  DeviceInfoSetTraits& operator=(const DeviceInfoSetTraits&) = delete;
+
+  static bool CloseHandle(HDEVINFO handle) {
+    return ::SetupDiDestroyDeviceInfoList(handle) != FALSE;
+  }
+
+  static bool IsHandleValid(HDEVINFO handle) {
+    return handle != INVALID_HANDLE_VALUE;
+  }
+
+  static HDEVINFO NullHandle() { return INVALID_HANDLE_VALUE; }
+};
+
+typedef base::win::GenericScopedHandle<DeviceInfoSetTraits,
+                                       base::win::DummyVerifierTraits>
+    ScopedDeviceInfoSetHandle;
+
+std::string FormatBluetoothError(const char* message, HRESULT hr) {
+  std::ostringstream string_stream;
+  string_stream << message;
+  if (FAILED(hr))
+    string_stream << logging::SystemErrorCodeToString(hr);
+  return string_stream.str();
+}
+
+bool CheckInsufficientBuffer(bool success,
+                             const char* message,
+                             std::string* error) {
+  if (success) {
+    *error = FormatBluetoothError(message, S_OK);
+    return false;
+  }
+
+  HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
+  if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
+    *error = FormatBluetoothError(message, hr);
+    return false;
+  }
+
+  return true;
+}
+
+bool CheckHResult(HRESULT hr, const char* message, std::string* error) {
+  if (FAILED(hr)) {
+    *error = FormatBluetoothError(message, hr);
+    return false;
+  }
+
+  return true;
+}
+
+bool CheckSuccess(bool success, const char* message, std::string* error) {
+  if (!success) {
+    CheckHResult(HRESULT_FROM_WIN32(GetLastError()), message, error);
+    return false;
+  }
+
+  return true;
+}
+
+bool CheckNoData(HRESULT hr, size_t length) {
+  if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
+    return true;
+
+  if (SUCCEEDED(hr) && length == 0)
+    return true;
+
+  return false;
+}
+
+bool CheckMoreData(HRESULT hr, const char* message, std::string* error) {
+  if (SUCCEEDED(hr)) {
+    *error = FormatBluetoothError(message, hr);
+    return false;
+  }
+
+  if (hr != HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
+    *error = FormatBluetoothError(message, hr);
+    return false;
+  }
+
+  return true;
+}
+
+bool CheckExpectedLength(size_t actual_length,
+                         size_t expected_length,
+                         const char* message,
+                         std::string* error) {
+  if (actual_length != expected_length) {
+    *error = FormatBluetoothError(message, E_FAIL);
+    return false;
+  }
+
+  return true;
+}
+
+bool CollectBluetoothLowEnergyDeviceProperty(
+    const ScopedDeviceInfoSetHandle& device_info_handle,
+    PSP_DEVINFO_DATA device_info_data,
+    const DEVPROPKEY& key,
+    std::unique_ptr<DevicePropertyValue>* value,
+    std::string* error) {
+  DWORD required_length;
+  DEVPROPTYPE prop_type;
+  BOOL success = SetupDiGetDeviceProperty(device_info_handle.Get(),
+                                          device_info_data,
+                                          &key,
+                                          &prop_type,
+                                          NULL,
+                                          0,
+                                          &required_length,
+                                          0);
+  if (!CheckInsufficientBuffer(!!success, kDeviceInfoError, error))
+    return false;
+
+  std::unique_ptr<uint8_t[]> prop_value(new uint8_t[required_length]);
+  DWORD actual_length = required_length;
+  success = SetupDiGetDeviceProperty(device_info_handle.Get(),
+                                     device_info_data,
+                                     &key,
+                                     &prop_type,
+                                     prop_value.get(),
+                                     actual_length,
+                                     &required_length,
+                                     0);
+  if (!CheckSuccess(!!success, kDeviceInfoError, error))
+    return false;
+  if (!CheckExpectedLength(
+          actual_length, required_length, kDeviceInfoError, error)) {
+    return false;
+  }
+
+  (*value) = std::unique_ptr<DevicePropertyValue>(
+      new DevicePropertyValue(prop_type, std::move(prop_value), actual_length));
+  return true;
+}
+
+bool CollectBluetoothLowEnergyDeviceRegistryProperty(
+    const ScopedDeviceInfoSetHandle& device_info_handle,
+    PSP_DEVINFO_DATA device_info_data,
+    DWORD property_id,
+    std::unique_ptr<DeviceRegistryPropertyValue>* value,
+    std::string* error) {
+  ULONG required_length = 0;
+  BOOL success = SetupDiGetDeviceRegistryProperty(device_info_handle.Get(),
+                                                  device_info_data,
+                                                  property_id,
+                                                  NULL,
+                                                  NULL,
+                                                  0,
+                                                  &required_length);
+  if (!CheckInsufficientBuffer(!!success, kDeviceInfoError, error))
+    return false;
+
+  std::unique_ptr<uint8_t[]> property_value(new uint8_t[required_length]);
+  ULONG actual_length = required_length;
+  DWORD property_type;
+  success = SetupDiGetDeviceRegistryProperty(device_info_handle.Get(),
+                                             device_info_data,
+                                             property_id,
+                                             &property_type,
+                                             property_value.get(),
+                                             actual_length,
+                                             &required_length);
+  if (!CheckSuccess(!!success, kDeviceInfoError, error))
+    return false;
+  if (!CheckExpectedLength(
+          actual_length, required_length, kDeviceInfoError, error)) {
+    return false;
+  }
+
+  (*value) = DeviceRegistryPropertyValue::Create(
+      property_type, std::move(property_value), actual_length);
+  return true;
+}
+
+bool CollectBluetoothLowEnergyDeviceInstanceId(
+    const ScopedDeviceInfoSetHandle& device_info_handle,
+    PSP_DEVINFO_DATA device_info_data,
+    std::unique_ptr<device::win::BluetoothLowEnergyDeviceInfo>& device_info,
+    std::string* error) {
+  ULONG required_length = 0;
+  BOOL success = SetupDiGetDeviceInstanceId(
+      device_info_handle.Get(), device_info_data, NULL, 0, &required_length);
+  if (!CheckInsufficientBuffer(!!success, kDeviceInfoError, error))
+    return false;
+
+  std::unique_ptr<WCHAR[]> instance_id(new WCHAR[required_length]);
+  ULONG actual_length = required_length;
+  success = SetupDiGetDeviceInstanceId(device_info_handle.Get(),
+                                       device_info_data,
+                                       instance_id.get(),
+                                       actual_length,
+                                       &required_length);
+  if (!CheckSuccess(!!success, kDeviceInfoError, error))
+    return false;
+  if (!CheckExpectedLength(
+          actual_length, required_length, kDeviceInfoError, error)) {
+    return false;
+  }
+
+  if (actual_length >= 1) {
+    // Ensure string is zero terminated.
+    instance_id.get()[actual_length - 1] = 0;
+    device_info->id = base::SysWideToUTF8(instance_id.get());
+  }
+  return true;
+}
+
+bool CollectBluetoothLowEnergyDeviceFriendlyName(
+    const ScopedDeviceInfoSetHandle& device_info_handle,
+    PSP_DEVINFO_DATA device_info_data,
+    std::unique_ptr<device::win::BluetoothLowEnergyDeviceInfo>& device_info,
+    std::string* error) {
+  std::unique_ptr<DeviceRegistryPropertyValue> property_value;
+  if (!CollectBluetoothLowEnergyDeviceRegistryProperty(device_info_handle,
+                                                       device_info_data,
+                                                       SPDRP_FRIENDLYNAME,
+                                                       &property_value,
+                                                       error)) {
+    return false;
+  }
+
+  if (property_value->property_type() != REG_SZ) {
+    *error = kDeviceFriendlyNameError;
+    return false;
+  }
+
+  device_info->friendly_name = property_value->AsString();
+  return true;
+}
+
+bool ExtractBluetoothAddressFromDeviceInstanceId(const std::string& instance_id,
+                                                 BLUETOOTH_ADDRESS* btha,
+                                                 std::string* error) {
+  std::string address;
+  if (!RE2::PartialMatch(instance_id, g_patterns.Get().address_regex,
+                         &address)) {
+    *error = kDeviceAddressError;
+    return false;
+  }
+
+  int buffer[6];
+  int result =
+      sscanf_s(address.c_str(), "%02X%02X%02X%02X%02X%02X", &buffer[5],
+               &buffer[4], &buffer[3], &buffer[2], &buffer[1], &buffer[0]);
+  if (result != 6) {
+    *error = kInvalidBluetoothAddress;
+    return false;
+  }
+
+  ZeroMemory(btha, sizeof(*btha));
+  btha->rgBytes[0] = buffer[0];
+  btha->rgBytes[1] = buffer[1];
+  btha->rgBytes[2] = buffer[2];
+  btha->rgBytes[3] = buffer[3];
+  btha->rgBytes[4] = buffer[4];
+  btha->rgBytes[5] = buffer[5];
+  return true;
+}
+
+bool CollectBluetoothLowEnergyDeviceAddress(
+    const ScopedDeviceInfoSetHandle& device_info_handle,
+    PSP_DEVINFO_DATA device_info_data,
+    std::unique_ptr<device::win::BluetoothLowEnergyDeviceInfo>& device_info,
+    std::string* error) {
+  // TODO(rpaquay): We exctract the bluetooth device address from the device
+  // instance ID string, as we did not find a more formal API for retrieving the
+  // bluetooth address of a Bluetooth Low Energy device.
+  // A Bluetooth device instance ID often has the following format (under
+  // Win8+):
+  // BTHLE\DEV_BC6A29AB5FB0\8&31038925&0&BC6A29AB5FB0
+  // However, they have also been seen with the following, more expanded,
+  // format:
+  // BTHLEDEVICE\{0000180F-0000-1000-8000-00805F9B34FB}_DEV_VID&01000A_PID&
+  // 014C_REV&0100_818B4B0BACE6\8&4C387F7&0&0020
+  return ExtractBluetoothAddressFromDeviceInstanceId(
+      device_info->id, &device_info->address, error);
+}
+
+bool CollectBluetoothLowEnergyDeviceStatus(
+    const ScopedDeviceInfoSetHandle& device_info_handle,
+    PSP_DEVINFO_DATA device_info_data,
+    std::unique_ptr<device::win::BluetoothLowEnergyDeviceInfo>& device_info,
+    std::string* error) {
+  std::unique_ptr<DevicePropertyValue> value;
+  if (!CollectBluetoothLowEnergyDeviceProperty(device_info_handle,
+                                               device_info_data,
+                                               DEVPKEY_Device_DevNodeStatus,
+                                               &value,
+                                               error)) {
+    return false;
+  }
+
+  if (value->property_type() != DEVPROP_TYPE_UINT32) {
+    *error = kDeviceInfoError;
+    return false;
+  }
+
+  device_info->connected = !(value->AsUint32() & DN_DEVICE_DISCONNECTED);
+  // Windows 8 exposes BLE devices only if they are visible and paired. This
+  // might change in the future if Windows offers a public API for discovering
+  // and pairing BLE devices.
+  device_info->visible = true;
+  device_info->authenticated = true;
+  return true;
+}
+
+bool CollectBluetoothLowEnergyDeviceServices(
+    const base::FilePath& device_path,
+    std::vector<std::unique_ptr<BluetoothLowEnergyServiceInfo>>* services,
+    std::string* error) {
+  base::File file(device_path, base::File::FLAG_OPEN | base::File::FLAG_READ);
+  if (!file.IsValid()) {
+    *error = file.ErrorToString(file.error_details());
+    return false;
+  }
+
+  USHORT required_length;
+  HRESULT hr = BluetoothGATTGetServices(file.GetPlatformFile(),
+                                        0,
+                                        NULL,
+                                        &required_length,
+                                        BLUETOOTH_GATT_FLAG_NONE);
+  if (CheckNoData(hr, required_length))
+    return true;
+  if (!CheckMoreData(hr, kDeviceInfoError, error))
+    return false;
+
+  std::unique_ptr<BTH_LE_GATT_SERVICE[]> gatt_services(
+      new BTH_LE_GATT_SERVICE[required_length]);
+  USHORT actual_length = required_length;
+  hr = BluetoothGATTGetServices(file.GetPlatformFile(),
+                                actual_length,
+                                gatt_services.get(),
+                                &required_length,
+                                BLUETOOTH_GATT_FLAG_NONE);
+  if (!CheckHResult(hr, kDeviceInfoError, error))
+    return false;
+  if (!CheckExpectedLength(
+          actual_length, required_length, kDeviceInfoError, error)) {
+    return false;
+  }
+
+  for (USHORT i = 0; i < actual_length; ++i) {
+    BTH_LE_GATT_SERVICE& gatt_service(gatt_services.get()[i]);
+    auto service_info = std::make_unique<BluetoothLowEnergyServiceInfo>();
+    service_info->uuid = gatt_service.ServiceUuid;
+    service_info->attribute_handle = gatt_service.AttributeHandle;
+    services->push_back(std::move(service_info));
+  }
+
+  return true;
+}
+
+bool CollectBluetoothLowEnergyDeviceInfo(
+    const ScopedDeviceInfoSetHandle& device_info_handle,
+    PSP_DEVICE_INTERFACE_DATA device_interface_data,
+    std::unique_ptr<device::win::BluetoothLowEnergyDeviceInfo>* device_info,
+    std::string* error) {
+  // Retrieve required # of bytes for interface details
+  ULONG required_length = 0;
+  BOOL success = SetupDiGetDeviceInterfaceDetail(device_info_handle.Get(),
+                                                 device_interface_data,
+                                                 NULL,
+                                                 0,
+                                                 &required_length,
+                                                 NULL);
+  if (!CheckInsufficientBuffer(!!success, kDeviceInfoError, error))
+    return false;
+
+  std::unique_ptr<uint8_t[]> interface_data(new uint8_t[required_length]);
+  ZeroMemory(interface_data.get(), required_length);
+
+  PSP_DEVICE_INTERFACE_DETAIL_DATA device_interface_detail_data =
+      reinterpret_cast<PSP_DEVICE_INTERFACE_DETAIL_DATA>(interface_data.get());
+  device_interface_detail_data->cbSize =
+      sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
+
+  SP_DEVINFO_DATA device_info_data = {0};
+  device_info_data.cbSize = sizeof(SP_DEVINFO_DATA);
+
+  ULONG actual_length = required_length;
+  success = SetupDiGetDeviceInterfaceDetail(device_info_handle.Get(),
+                                            device_interface_data,
+                                            device_interface_detail_data,
+                                            actual_length,
+                                            &required_length,
+                                            &device_info_data);
+  if (!CheckSuccess(!!success, kDeviceInfoError, error))
+    return false;
+  if (!CheckExpectedLength(
+          actual_length, required_length, kDeviceInfoError, error)) {
+    return false;
+  }
+
+  std::unique_ptr<device::win::BluetoothLowEnergyDeviceInfo> result(
+      new device::win::BluetoothLowEnergyDeviceInfo());
+  result->path = base::FilePath(device_interface_detail_data->DevicePath);
+  if (!CollectBluetoothLowEnergyDeviceInstanceId(
+          device_info_handle, &device_info_data, result, error)) {
+    return false;
+  }
+  // Get the friendly name. If it fails it is OK to leave the
+  // device_info_data.friendly_name as nullopt indicating the name not read.
+  CollectBluetoothLowEnergyDeviceFriendlyName(device_info_handle,
+                                              &device_info_data, result, error);
+  if (!CollectBluetoothLowEnergyDeviceAddress(
+          device_info_handle, &device_info_data, result, error)) {
+    return false;
+  }
+  if (!CollectBluetoothLowEnergyDeviceStatus(
+          device_info_handle, &device_info_data, result, error)) {
+    return false;
+  }
+  (*device_info) = std::move(result);
+  return true;
+}
+
+enum DeviceInfoResult { kOk, kError, kNoMoreDevices };
+
+// For |device_interface_guid| see the Note of below
+// EnumerateKnownBLEOrBLEGattServiceDevices interface.
+DeviceInfoResult EnumerateSingleBluetoothLowEnergyDevice(
+    GUID device_interface_guid,
+    const ScopedDeviceInfoSetHandle& device_info_handle,
+    DWORD device_index,
+    std::unique_ptr<device::win::BluetoothLowEnergyDeviceInfo>* device_info,
+    std::string* error) {
+  GUID BluetoothInterfaceGUID = device_interface_guid;
+  SP_DEVICE_INTERFACE_DATA device_interface_data = {0};
+  device_interface_data.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
+  BOOL success = ::SetupDiEnumDeviceInterfaces(device_info_handle.Get(),
+                                               NULL,
+                                               &BluetoothInterfaceGUID,
+                                               device_index,
+                                               &device_interface_data);
+  if (!success) {
+    HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
+    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
+      return kNoMoreDevices;
+    }
+    *error = FormatBluetoothError(kDeviceInfoError, hr);
+    return kError;
+  }
+
+  if (!CollectBluetoothLowEnergyDeviceInfo(
+          device_info_handle, &device_interface_data, device_info, error)) {
+    return kError;
+  }
+
+  return kOk;
+}
+
+// Opens a Device Info Set that can be used to enumerate Bluetooth LE devices
+// present on the machine. For |device_interface_guid| see the Note of below
+// EnumerateKnownBLEOrBLEGattServiceDevices interface.
+HRESULT OpenBluetoothLowEnergyDevices(GUID device_interface_guid,
+                                      ScopedDeviceInfoSetHandle* handle) {
+  GUID BluetoothClassGUID = device_interface_guid;
+  ScopedDeviceInfoSetHandle result(SetupDiGetClassDevs(
+      &BluetoothClassGUID, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));
+  if (!result.IsValid()) {
+    return HRESULT_FROM_WIN32(::GetLastError());
+  }
+
+  (*handle) = std::move(result);
+  return S_OK;
+}
+
+// Enumerate known Bluetooth low energy devices or Bluetooth low energy GATT
+// service devices according to |device_interface_guid|.
+// Note: |device_interface_guid| = GUID_BLUETOOTHLE_DEVICE_INTERFACE corresponds
+// Bluetooth low energy devices. |device_interface_guid| =
+// GUID_BLUETOOTH_GATT_SERVICE_DEVICE_INTERFACE corresponds Bluetooth low energy
+// Gatt service devices.
+bool EnumerateKnownBLEOrBLEGattServiceDevices(
+    GUID guid,
+    std::vector<std::unique_ptr<BluetoothLowEnergyDeviceInfo>>* devices,
+    std::string* error) {
+  ScopedDeviceInfoSetHandle info_set_handle;
+  HRESULT hr = OpenBluetoothLowEnergyDevices(guid, &info_set_handle);
+  if (FAILED(hr)) {
+    *error = FormatBluetoothError(kDeviceEnumError, hr);
+    return false;
+  }
+
+  for (DWORD i = 0;; ++i) {
+    std::unique_ptr<BluetoothLowEnergyDeviceInfo> device_info;
+    DeviceInfoResult result = EnumerateSingleBluetoothLowEnergyDevice(
+        guid, info_set_handle, i, &device_info, error);
+    switch (result) {
+      case kNoMoreDevices:
+        return true;
+      case kError:
+        return false;
+      case kOk:
+        devices->push_back(std::move(device_info));
+    }
+  }
+}
+
+}  // namespace
+
+namespace device {
+namespace win {
+
+// static
+std::unique_ptr<DeviceRegistryPropertyValue>
+DeviceRegistryPropertyValue::Create(DWORD property_type,
+                                    std::unique_ptr<uint8_t[]> value,
+                                    size_t value_size) {
+  switch (property_type) {
+    case REG_SZ: {
+      // Ensure string is zero terminated.
+      size_t character_size = value_size / sizeof(WCHAR);
+      CHECK_EQ(character_size * sizeof(WCHAR), value_size);
+      CHECK_GE(character_size, 1u);
+      WCHAR* value_string = reinterpret_cast<WCHAR*>(value.get());
+      value_string[character_size - 1] = 0;
+      break;
+    }
+    case REG_DWORD: {
+      CHECK_EQ(value_size, sizeof(DWORD));
+      break;
+    }
+  }
+  return base::WrapUnique(
+      new DeviceRegistryPropertyValue(property_type, std::move(value)));
+}
+
+DeviceRegistryPropertyValue::DeviceRegistryPropertyValue(
+    DWORD property_type,
+    std::unique_ptr<uint8_t[]> value)
+    : property_type_(property_type), value_(std::move(value)) {}
+
+DeviceRegistryPropertyValue::~DeviceRegistryPropertyValue() {
+}
+
+std::string DeviceRegistryPropertyValue::AsString() const {
+  CHECK_EQ(property_type_, static_cast<DWORD>(REG_SZ));
+  WCHAR* value_string = reinterpret_cast<WCHAR*>(value_.get());
+  return base::SysWideToUTF8(value_string);
+}
+
+DWORD DeviceRegistryPropertyValue::AsDWORD() const {
+  CHECK_EQ(property_type_, static_cast<DWORD>(REG_DWORD));
+  DWORD* value = reinterpret_cast<DWORD*>(value_.get());
+  return *value;
+}
+
+DevicePropertyValue::DevicePropertyValue(DEVPROPTYPE property_type,
+                                         std::unique_ptr<uint8_t[]> value,
+                                         size_t value_size)
+    : property_type_(property_type),
+      value_(std::move(value)),
+      value_size_(value_size) {}
+
+DevicePropertyValue::~DevicePropertyValue() = default;
+
+uint32_t DevicePropertyValue::AsUint32() const {
+  CHECK_EQ(property_type_, static_cast<DEVPROPTYPE>(DEVPROP_TYPE_UINT32));
+  CHECK_EQ(value_size_, sizeof(uint32_t));
+  return *reinterpret_cast<uint32_t*>(value_.get());
+}
+
+BluetoothLowEnergyServiceInfo::BluetoothLowEnergyServiceInfo() = default;
+
+BluetoothLowEnergyServiceInfo::~BluetoothLowEnergyServiceInfo() = default;
+
+BluetoothLowEnergyDeviceInfo::BluetoothLowEnergyDeviceInfo() {
+  address.ullLong = BLUETOOTH_NULL_ADDRESS;
+}
+
+BluetoothLowEnergyDeviceInfo::~BluetoothLowEnergyDeviceInfo() {
+}
+
+bool ExtractBluetoothAddressFromDeviceInstanceIdForTesting(
+    const std::string& instance_id,
+    BLUETOOTH_ADDRESS* btha,
+    std::string* error) {
+  return ExtractBluetoothAddressFromDeviceInstanceId(instance_id, btha, error);
+}
+
+BluetoothLowEnergyWrapper::BluetoothLowEnergyWrapper() = default;
+BluetoothLowEnergyWrapper::~BluetoothLowEnergyWrapper() = default;
+
+bool BluetoothLowEnergyWrapper::EnumerateKnownBluetoothLowEnergyDevices(
+    std::vector<std::unique_ptr<BluetoothLowEnergyDeviceInfo>>* devices,
+    std::string* error) {
+  return EnumerateKnownBLEOrBLEGattServiceDevices(
+      GUID_BLUETOOTHLE_DEVICE_INTERFACE, devices, error);
+}
+
+bool BluetoothLowEnergyWrapper::
+    EnumerateKnownBluetoothLowEnergyGattServiceDevices(
+        std::vector<std::unique_ptr<BluetoothLowEnergyDeviceInfo>>* devices,
+        std::string* error) {
+  return EnumerateKnownBLEOrBLEGattServiceDevices(
+      GUID_BLUETOOTH_GATT_SERVICE_DEVICE_INTERFACE, devices, error);
+}
+
+bool BluetoothLowEnergyWrapper::EnumerateKnownBluetoothLowEnergyServices(
+    const base::FilePath& device_path,
+    std::vector<std::unique_ptr<BluetoothLowEnergyServiceInfo>>* services,
+    std::string* error) {
+  return CollectBluetoothLowEnergyDeviceServices(device_path, services, error);
+}
+
+HRESULT BluetoothLowEnergyWrapper::ReadCharacteristicsOfAService(
+    base::FilePath& service_path,
+    const PBTH_LE_GATT_SERVICE service,
+    std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC>* out_included_characteristics,
+    USHORT* out_counts) {
+  base::File file(service_path, base::File::FLAG_OPEN | base::File::FLAG_READ);
+  if (!file.IsValid())
+    return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
+
+  USHORT allocated_length = 0;
+  HRESULT hr = BluetoothGATTGetCharacteristics(file.GetPlatformFile(), service,
+                                               0, NULL, &allocated_length,
+                                               BLUETOOTH_GATT_FLAG_NONE);
+  if (hr != HRESULT_FROM_WIN32(ERROR_MORE_DATA))
+    return hr;
+
+  out_included_characteristics->reset(
+      new BTH_LE_GATT_CHARACTERISTIC[allocated_length]);
+  hr = BluetoothGATTGetCharacteristics(file.GetPlatformFile(), service,
+                                       allocated_length,
+                                       out_included_characteristics->get(),
+                                       out_counts, BLUETOOTH_GATT_FLAG_NONE);
+  if (SUCCEEDED(hr) && allocated_length != *out_counts) {
+    LOG(ERROR) << "Retrieved charactersitics is not equal to expected"
+               << " allocated_length " << allocated_length << " got "
+               << *out_counts;
+    hr = HRESULT_FROM_WIN32(ERROR_INVALID_USER_BUFFER);
+  }
+
+  if (FAILED(hr)) {
+    out_included_characteristics->reset(nullptr);
+    *out_counts = 0;
+  }
+  return hr;
+}
+
+HRESULT BluetoothLowEnergyWrapper::ReadDescriptorsOfACharacteristic(
+    base::FilePath& service_path,
+    const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+    std::unique_ptr<BTH_LE_GATT_DESCRIPTOR>* out_included_descriptors,
+    USHORT* out_counts) {
+  base::File file(service_path, base::File::FLAG_OPEN | base::File::FLAG_READ);
+  if (!file.IsValid())
+    return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
+
+  USHORT allocated_length = 0;
+  HRESULT hr = BluetoothGATTGetDescriptors(
+      file.GetPlatformFile(), characteristic, 0, NULL, &allocated_length,
+      BLUETOOTH_GATT_FLAG_NONE);
+  if (hr != HRESULT_FROM_WIN32(ERROR_MORE_DATA))
+    return hr;
+
+  out_included_descriptors->reset(new BTH_LE_GATT_DESCRIPTOR[allocated_length]);
+  hr = BluetoothGATTGetDescriptors(
+      file.GetPlatformFile(), characteristic, allocated_length,
+      out_included_descriptors->get(), out_counts, BLUETOOTH_GATT_FLAG_NONE);
+  if (SUCCEEDED(hr) && allocated_length != *out_counts) {
+    LOG(ERROR) << "Retrieved descriptors is not equal to expected"
+               << " allocated_length " << allocated_length << " got "
+               << *out_counts;
+    hr = HRESULT_FROM_WIN32(ERROR_INVALID_USER_BUFFER);
+  }
+
+  if (FAILED(hr)) {
+    out_included_descriptors->reset(nullptr);
+    *out_counts = 0;
+  }
+  return hr;
+}
+
+HRESULT BluetoothLowEnergyWrapper::ReadCharacteristicValue(
+    base::FilePath& service_path,
+    const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+    std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC_VALUE>* out_value) {
+  base::File file(service_path, base::File::FLAG_OPEN | base::File::FLAG_READ);
+  if (!file.IsValid())
+    return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
+
+  USHORT allocated_length = 0;
+  HRESULT hr = BluetoothGATTGetCharacteristicValue(
+      file.GetPlatformFile(), characteristic, 0, NULL, &allocated_length,
+      BLUETOOTH_GATT_FLAG_NONE);
+  if (hr != HRESULT_FROM_WIN32(ERROR_MORE_DATA))
+    return hr;
+
+  out_value->reset(
+      (PBTH_LE_GATT_CHARACTERISTIC_VALUE)(new UCHAR[allocated_length]));
+  USHORT out_length = 0;
+  hr = BluetoothGATTGetCharacteristicValue(
+      file.GetPlatformFile(), characteristic, (ULONG)allocated_length,
+      out_value->get(), &out_length, BLUETOOTH_GATT_FLAG_NONE);
+  if (SUCCEEDED(hr) && allocated_length != out_length) {
+    LOG(ERROR) << "Retrieved characteristic value size is not equal to expected"
+               << " allocated_length " << allocated_length << " got "
+               << out_length;
+    hr = HRESULT_FROM_WIN32(ERROR_INVALID_USER_BUFFER);
+  }
+
+  if (FAILED(hr)) {
+    out_value->reset(nullptr);
+  }
+  return hr;
+}
+
+HRESULT BluetoothLowEnergyWrapper::WriteCharacteristicValue(
+    base::FilePath& service_path,
+    const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+    PBTH_LE_GATT_CHARACTERISTIC_VALUE new_value,
+    ULONG flags) {
+  base::File file(service_path, base::File::FLAG_OPEN | base::File::FLAG_READ |
+                                    base::File::FLAG_WRITE);
+  if (!file.IsValid())
+    return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
+
+  return BluetoothGATTSetCharacteristicValue(
+      file.GetPlatformFile(), characteristic, new_value, {}, flags);
+}
+
+HRESULT BluetoothLowEnergyWrapper::RegisterGattEvents(
+    base::FilePath& service_path,
+    BTH_LE_GATT_EVENT_TYPE event_type,
+    PVOID event_parameter,
+    PFNBLUETOOTH_GATT_EVENT_CALLBACK_CORRECTED callback,
+    PVOID context,
+    BLUETOOTH_GATT_EVENT_HANDLE* out_handle) {
+  base::File file(service_path, base::File::FLAG_OPEN | base::File::FLAG_READ);
+  if (!file.IsValid())
+    return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
+  // Cast to the official callback type for compatibility with the Windows
+  // 10.0.10586 definition, even though it is incorrect. This cast can be
+  // removed when we mandate building Chromium with the 10.0.14393 SDK or
+  // higher.
+  return BluetoothGATTRegisterEvent(
+      file.GetPlatformFile(), event_type, event_parameter,
+      reinterpret_cast<PFNBLUETOOTH_GATT_EVENT_CALLBACK>(callback), context,
+      out_handle, BLUETOOTH_GATT_FLAG_NONE);
+}
+
+HRESULT BluetoothLowEnergyWrapper::UnregisterGattEvent(
+    BLUETOOTH_GATT_EVENT_HANDLE event_handle) {
+  return BluetoothGATTUnregisterEvent(event_handle, BLUETOOTH_GATT_FLAG_NONE);
+}
+
+HRESULT BluetoothLowEnergyWrapper::WriteDescriptorValue(
+    base::FilePath& service_path,
+    const PBTH_LE_GATT_DESCRIPTOR descriptor,
+    PBTH_LE_GATT_DESCRIPTOR_VALUE new_value) {
+  base::File file(service_path, base::File::FLAG_OPEN | base::File::FLAG_READ |
+                                    base::File::FLAG_WRITE);
+  if (!file.IsValid())
+    return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
+  return BluetoothGATTSetDescriptorValue(file.GetPlatformFile(), descriptor,
+                                         new_value, BLUETOOTH_GATT_FLAG_NONE);
+}
+
+}  // namespace win
+}  // namespace device
diff --git a/device/bluetooth/bluetooth_low_energy_win.h b/device/bluetooth/bluetooth_low_energy_win.h
new file mode 100644
index 0000000000000..f9280a683feb1
--- /dev/null
+++ b/device/bluetooth/bluetooth_low_energy_win.h
@@ -0,0 +1,219 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef DEVICE_BLUETOOTH_BLUETOOTH_LOW_ENERGY_WIN_H_
+#define DEVICE_BLUETOOTH_BLUETOOTH_LOW_ENERGY_WIN_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "device/bluetooth/bluetooth_export.h"
+#include "device/bluetooth/bluetooth_low_energy_defs_win.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+
+namespace device {
+namespace win {
+
+//
+// Callback function signature for Bluetooth GATT events. This fixes a bug in
+// this typedef in the Windows 10.0.10586 SDK which is missing the CALLBACK
+// modifier. This corrected typedef should be used throughout Chromium except
+// when casting to the 'official' definition when calling Microsoft functions.
+// This allows Chromium to build with 10.0.14393 or later SDKs (which have the
+// fixed typedef) while doing the correct thing even when built with 10.0.10586.
+// The CALLBACK modifier affects how function parameters are cleaned up from the
+// stack and having a mismatch can lead to misalignment of the stack pointer.
+//
+typedef VOID(CALLBACK* PFNBLUETOOTH_GATT_EVENT_CALLBACK_CORRECTED)(
+    _In_ BTH_LE_GATT_EVENT_TYPE EventType,
+    _In_ PVOID EventOutParameter,
+    _In_opt_ PVOID Context);
+
+// Represents a device registry property value
+class DEVICE_BLUETOOTH_EXPORT DeviceRegistryPropertyValue {
+ public:
+  // Creates a property value instance, where |property_type| is one of REG_xxx
+  // registry value type (e.g. REG_SZ, REG_DWORD), |value| is a byte array
+  // containing the property value and |value_size| is the number of bytes in
+  // |value|. Note the returned instance takes ownership of the bytes in
+  // |value|.
+  static std::unique_ptr<DeviceRegistryPropertyValue> Create(
+      DWORD property_type,
+      std::unique_ptr<uint8_t[]> value,
+      size_t value_size);
+
+  DeviceRegistryPropertyValue(const DeviceRegistryPropertyValue&) = delete;
+  DeviceRegistryPropertyValue& operator=(const DeviceRegistryPropertyValue&) =
+      delete;
+
+  ~DeviceRegistryPropertyValue();
+
+  // Returns the vaue type a REG_xxx value (e.g. REG_SZ, REG_DWORD, ...)
+  DWORD property_type() const { return property_type_; }
+
+  std::string AsString() const;
+  DWORD AsDWORD() const;
+
+ private:
+  DeviceRegistryPropertyValue(DWORD property_type,
+                              std::unique_ptr<uint8_t[]> value);
+
+  DWORD property_type_;
+  std::unique_ptr<uint8_t[]> value_;
+};
+
+// Represents the value associated to a DEVPROPKEY.
+class DEVICE_BLUETOOTH_EXPORT DevicePropertyValue {
+ public:
+  // Creates a property value instance, where |property_type| is one of
+  // DEVPROP_TYPE_xxx value type , |value| is a byte array containing the
+  // property value and |value_size| is the number of bytes in |value|. Note the
+  // returned instance takes ownership of the bytes in |value|.
+  DevicePropertyValue(DEVPROPTYPE property_type,
+                      std::unique_ptr<uint8_t[]> value,
+                      size_t value_size);
+
+  DevicePropertyValue(const DevicePropertyValue&) = delete;
+  DevicePropertyValue& operator=(const DevicePropertyValue&) = delete;
+
+  ~DevicePropertyValue();
+
+  DEVPROPTYPE property_type() const { return property_type_; }
+
+  uint32_t AsUint32() const;
+
+ private:
+  DEVPROPTYPE property_type_;
+  std::unique_ptr<uint8_t[]> value_;
+  size_t value_size_;
+};
+
+struct DEVICE_BLUETOOTH_EXPORT BluetoothLowEnergyServiceInfo {
+  BluetoothLowEnergyServiceInfo();
+  ~BluetoothLowEnergyServiceInfo();
+
+  BTH_LE_UUID uuid;
+  // Attribute handle uniquely identifies this service on the device.
+  USHORT attribute_handle = 0;
+};
+
+struct DEVICE_BLUETOOTH_EXPORT BluetoothLowEnergyDeviceInfo {
+  BluetoothLowEnergyDeviceInfo();
+  ~BluetoothLowEnergyDeviceInfo();
+
+  base::FilePath path;
+  std::string id;
+  absl::optional<std::string> friendly_name;
+  BLUETOOTH_ADDRESS address;
+  bool visible = false;
+  bool authenticated = false;
+  bool connected = false;
+};
+
+bool DEVICE_BLUETOOTH_EXPORT
+ExtractBluetoothAddressFromDeviceInstanceIdForTesting(
+    const std::string& instance_id,
+    BLUETOOTH_ADDRESS* btha,
+    std::string* error);
+
+// Wraps Windows APIs used to access Bluetooth Low Energy devices, providing an
+// interface that can be replaced with fakes in tests.
+class DEVICE_BLUETOOTH_EXPORT BluetoothLowEnergyWrapper {
+ public:
+  BluetoothLowEnergyWrapper();
+  virtual ~BluetoothLowEnergyWrapper();
+
+  // Enumerates the list of known (i.e. already paired) Bluetooth LE devices on
+  // this machine. In case of error, returns false and sets |error| with an
+  // error message describing the problem.
+  // Note: This function returns an error if Bluetooth Low Energy is not
+  // supported on this Windows platform.
+  virtual bool EnumerateKnownBluetoothLowEnergyDevices(
+      std::vector<std::unique_ptr<BluetoothLowEnergyDeviceInfo>>* devices,
+      std::string* error);
+
+  // Enumerates the list of known Bluetooth LE GATT service devices on this
+  // machine (a Bluetooth LE device usually has more than one GATT
+  // services that each of them has a device interface on the machine). In case
+  // of error, returns false and sets |error| with an error message describing
+  // the problem.
+  // Note: This function returns an error if Bluetooth Low Energy is not
+  // supported on this Windows platform.
+  virtual bool EnumerateKnownBluetoothLowEnergyGattServiceDevices(
+      std::vector<std::unique_ptr<BluetoothLowEnergyDeviceInfo>>* devices,
+      std::string* error);
+
+  // Enumerates the list of known (i.e. cached) GATT services for a given
+  // Bluetooth LE device |device_path| into |services|. In case of error,
+  // returns false and sets |error| with an error message describing the
+  // problem.
+  // Note: This function returns an error if Bluetooth Low Energy is not
+  // supported on this Windows platform.
+  virtual bool EnumerateKnownBluetoothLowEnergyServices(
+      const base::FilePath& device_path,
+      std::vector<std::unique_ptr<BluetoothLowEnergyServiceInfo>>* services,
+      std::string* error);
+
+  // Reads characteristics of |service| with service device path |service_path|.
+  // The result will be stored in |*out_included_characteristics| and
+  // |*out_counts|.
+  virtual HRESULT ReadCharacteristicsOfAService(
+      base::FilePath& service_path,
+      const PBTH_LE_GATT_SERVICE service,
+      std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC>* out_included_characteristics,
+      USHORT* out_counts);
+
+  // Reads included descriptors of |characteristic| in service with service
+  // device path |service_path|. The result will be stored in
+  // |*out_included_descriptors| and |*out_counts|.
+  virtual HRESULT ReadDescriptorsOfACharacteristic(
+      base::FilePath& service_path,
+      const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+      std::unique_ptr<BTH_LE_GATT_DESCRIPTOR>* out_included_descriptors,
+      USHORT* out_counts);
+
+  // Reads |characteristic| value in service with service device path
+  // |service_path|. The result will be stored in |*out_value|.
+  virtual HRESULT ReadCharacteristicValue(
+      base::FilePath& service_path,
+      const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+      std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC_VALUE>* out_value);
+
+  // Writes |characteristic| value in service with service device path
+  // |service_path| to |*new_value|.
+  virtual HRESULT WriteCharacteristicValue(
+      base::FilePath& service_path,
+      const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+      PBTH_LE_GATT_CHARACTERISTIC_VALUE new_value,
+      ULONG flags);
+
+  // Register GATT events of |event_type| in the service with service device
+  // path |service_path|. |event_parameter| is the event's parameter. |callback|
+  // is the function to be invoked if the event happened. |context| is the input
+  // parameter to be given back through |callback|. |*out_handle| stores the
+  // unique handle in OS for this registration.
+  virtual HRESULT RegisterGattEvents(
+      base::FilePath& service_path,
+      BTH_LE_GATT_EVENT_TYPE event_type,
+      PVOID event_parameter,
+      PFNBLUETOOTH_GATT_EVENT_CALLBACK_CORRECTED callback,
+      PVOID context,
+      BLUETOOTH_GATT_EVENT_HANDLE* out_handle);
+  virtual HRESULT UnregisterGattEvent(BLUETOOTH_GATT_EVENT_HANDLE event_handle);
+
+  // Writes |descriptor| value in service with service device path
+  // |service_path| to |*new_value|.
+  virtual HRESULT WriteDescriptorValue(base::FilePath& service_path,
+                                       const PBTH_LE_GATT_DESCRIPTOR descriptor,
+                                       PBTH_LE_GATT_DESCRIPTOR_VALUE new_value);
+};
+
+}  // namespace win
+}  // namespace device
+
+#endif  // DEVICE_BLUETOOTH_BLUETOOTH_LOW_ENERGY_WIN_H_
diff --git a/device/bluetooth/bluetooth_low_energy_win_unittest.cc b/device/bluetooth/bluetooth_low_energy_win_unittest.cc
new file mode 100644
index 0000000000000..f1fac9633df56
--- /dev/null
+++ b/device/bluetooth/bluetooth_low_energy_win_unittest.cc
@@ -0,0 +1,116 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "device/bluetooth/bluetooth_low_energy_win.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+#include <utility>
+
+#include "base/strings/stringprintf.h"
+#include "base/strings/sys_string_conversions.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace {
+
+const char kValidDeviceAddress[] = "BC6A29AB5FB0";
+const char kShortDeviceAddress[] = "BC6A29AB5FB";
+
+void ExtractValidBluetoothAddress(const char* format) {
+  BLUETOOTH_ADDRESS btha;
+  std::string error;
+  bool success =
+      device::win::ExtractBluetoothAddressFromDeviceInstanceIdForTesting(
+          base::StringPrintf(format, kValidDeviceAddress), &btha, &error);
+
+  EXPECT_TRUE(success);
+  EXPECT_TRUE(error.empty());
+  EXPECT_EQ(0xbc, btha.rgBytes[5]);
+  EXPECT_EQ(0x6a, btha.rgBytes[4]);
+  EXPECT_EQ(0x29, btha.rgBytes[3]);
+  EXPECT_EQ(0xab, btha.rgBytes[2]);
+  EXPECT_EQ(0x5f, btha.rgBytes[1]);
+  EXPECT_EQ(0xb0, btha.rgBytes[0]);
+}
+
+void ExtractInvalidBluetoothAddress(const char* format, const char* address) {
+  BLUETOOTH_ADDRESS btha;
+  std::string error;
+  bool success =
+      device::win::ExtractBluetoothAddressFromDeviceInstanceIdForTesting(
+          base::StringPrintf(format, address), &btha, &error);
+
+  EXPECT_FALSE(success);
+  EXPECT_FALSE(error.empty());
+}
+
+}  // namespace
+
+namespace device {
+
+class BluetoothLowEnergyWinTest : public testing::Test {};
+
+TEST_F(BluetoothLowEnergyWinTest, ExtractBluetoothAddress_Valid) {
+  // Short form
+  ExtractValidBluetoothAddress(R"(BTHLE\DEV_%s\8&31038925&0&BC6A29AB5FB0)");
+  // Long form
+  ExtractValidBluetoothAddress(
+      R"(BTHLEDEVICE\{0000180F-0000-1000-8000-00805F9B34FB}_DEV_VID&)"
+      R"(01000A_PID&014C_REV&0100_%s\8&4C387F7&0&0020)");
+}
+
+TEST_F(BluetoothLowEnergyWinTest, ExtractBluetoothAddress_Invalid) {
+  // No opening underscore
+  ExtractInvalidBluetoothAddress(R"(%s\)", kValidDeviceAddress);
+  // No trailing slash
+  ExtractInvalidBluetoothAddress(R"(_%s)", kValidDeviceAddress);
+  // An extra character
+  ExtractInvalidBluetoothAddress(R"(_%sA\)", kValidDeviceAddress);
+  // A missing character
+  ExtractInvalidBluetoothAddress(R"(_%s\)", kShortDeviceAddress);
+  // A lowercase character
+  ExtractInvalidBluetoothAddress(R"(_%sa\)", kShortDeviceAddress);
+  // A non-hex character
+  ExtractInvalidBluetoothAddress(R"(_%sG\)", kShortDeviceAddress);
+  // A non-alphanumeric character
+  ExtractInvalidBluetoothAddress(R"(_%s?\)", kShortDeviceAddress);
+}
+
+TEST_F(BluetoothLowEnergyWinTest, DeviceRegistryPropertyValueAsString) {
+  std::string test_value = "String used for round trip test.";
+  std::wstring wide_value = base::SysUTF8ToWide(test_value);
+  size_t buffer_size = (wide_value.size() + 1) * sizeof(wchar_t);
+  std::unique_ptr<uint8_t[]> buffer(new uint8_t[buffer_size]);
+  memcpy(buffer.get(), wide_value.c_str(), buffer_size);
+  std::unique_ptr<device::win::DeviceRegistryPropertyValue> value =
+      device::win::DeviceRegistryPropertyValue::Create(
+          REG_SZ, std::move(buffer), buffer_size);
+  EXPECT_EQ(test_value, value->AsString());
+}
+
+TEST_F(BluetoothLowEnergyWinTest, DeviceRegistryPropertyValueAsDWORD) {
+  DWORD test_value = 5u;
+  size_t buffer_size = sizeof(DWORD);
+  std::unique_ptr<uint8_t[]> buffer(new uint8_t[buffer_size]);
+  memcpy(buffer.get(), &test_value, buffer_size);
+  std::unique_ptr<device::win::DeviceRegistryPropertyValue> value =
+      device::win::DeviceRegistryPropertyValue::Create(
+          REG_DWORD, std::move(buffer), buffer_size);
+  EXPECT_EQ(test_value, value->AsDWORD());
+}
+
+TEST_F(BluetoothLowEnergyWinTest, DevicePropertyValueAsUint32) {
+  uint32_t test_value = 5u;
+  size_t buffer_size = sizeof(uint32_t);
+  std::unique_ptr<uint8_t[]> buffer(new uint8_t[buffer_size]);
+  memcpy(buffer.get(), &test_value, buffer_size);
+  std::unique_ptr<device::win::DevicePropertyValue> value(
+      new device::win::DevicePropertyValue(DEVPROP_TYPE_UINT32,
+                                           std::move(buffer), buffer_size));
+  EXPECT_EQ(test_value, value->AsUint32());
+}
+
+}  // namespace device
diff --git a/device/bluetooth/bluetooth_remote_gatt_characteristic_win.cc b/device/bluetooth/bluetooth_remote_gatt_characteristic_win.cc
new file mode 100644
index 0000000000000..d600e91c80cca
--- /dev/null
+++ b/device/bluetooth/bluetooth_remote_gatt_characteristic_win.cc
@@ -0,0 +1,441 @@
+// Copyright 2016 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "device/bluetooth/bluetooth_remote_gatt_characteristic_win.h"
+
+#include <memory>
+
+#include "base/functional/bind.h"
+#include "base/memory/ptr_util.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/task/single_thread_task_runner.h"
+#include "device/bluetooth/bluetooth_adapter_win.h"
+#include "device/bluetooth/bluetooth_gatt_notify_session.h"
+#include "device/bluetooth/bluetooth_remote_gatt_descriptor_win.h"
+#include "device/bluetooth/bluetooth_remote_gatt_service_win.h"
+#include "device/bluetooth/bluetooth_task_manager_win.h"
+
+namespace device {
+
+BluetoothRemoteGattCharacteristicWin::BluetoothRemoteGattCharacteristicWin(
+    BluetoothRemoteGattServiceWin* parent_service,
+    BTH_LE_GATT_CHARACTERISTIC* characteristic_info,
+    scoped_refptr<base::SequencedTaskRunner> ui_task_runner)
+    : parent_service_(parent_service),
+      characteristic_info_(characteristic_info),
+      ui_task_runner_(std::move(ui_task_runner)),
+      characteristic_added_notified_(false),
+      characteristic_value_read_or_write_in_progress_(false),
+      gatt_event_handle_(nullptr),
+      discovery_pending_count_(0) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  DCHECK(parent_service_);
+  DCHECK(characteristic_info_);
+
+  task_manager_ =
+      parent_service_->GetWinAdapter()->GetWinBluetoothTaskManager();
+  DCHECK(task_manager_);
+  characteristic_uuid_ =
+      BluetoothTaskManagerWin::BluetoothLowEnergyUuidToBluetoothUuid(
+          characteristic_info_->CharacteristicUuid);
+  characteristic_identifier_ =
+      parent_service_->GetIdentifier() + "_" +
+      std::to_string(characteristic_info_->AttributeHandle);
+  Update();
+}
+
+BluetoothRemoteGattCharacteristicWin::~BluetoothRemoteGattCharacteristicWin() {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  ClearIncludedDescriptors();
+
+  if (gatt_event_handle_ != nullptr) {
+    task_manager_->PostUnregisterGattCharacteristicValueChangedEvent(
+        gatt_event_handle_);
+    gatt_event_handle_ = nullptr;
+  }
+  parent_service_->GetWinAdapter()->NotifyGattCharacteristicRemoved(this);
+
+  if (read_characteristic_value_callback_) {
+    std::move(read_characteristic_value_callback_)
+        .Run(BluetoothGattService::GattErrorCode::kFailed,
+             /*value=*/std::vector<uint8_t>());
+  }
+
+  if (!write_characteristic_value_callbacks_.first.is_null()) {
+    DCHECK(!write_characteristic_value_callbacks_.second.is_null());
+    std::move(write_characteristic_value_callbacks_.second)
+        .Run(BluetoothGattService::GattErrorCode::kFailed);
+  }
+}
+
+std::string BluetoothRemoteGattCharacteristicWin::GetIdentifier() const {
+  return characteristic_identifier_;
+}
+
+BluetoothUUID BluetoothRemoteGattCharacteristicWin::GetUUID() const {
+  return characteristic_uuid_;
+}
+
+std::vector<uint8_t>& BluetoothRemoteGattCharacteristicWin::GetValue() const {
+  return const_cast<std::vector<uint8_t>&>(characteristic_value_);
+}
+
+BluetoothRemoteGattService* BluetoothRemoteGattCharacteristicWin::GetService()
+    const {
+  return parent_service_;
+}
+
+BluetoothRemoteGattCharacteristic::Properties
+BluetoothRemoteGattCharacteristicWin::GetProperties() const {
+  BluetoothRemoteGattCharacteristic::Properties properties = PROPERTY_NONE;
+
+  if (characteristic_info_->IsBroadcastable)
+    properties = properties | PROPERTY_BROADCAST;
+  if (characteristic_info_->IsReadable)
+    properties = properties | PROPERTY_READ;
+  if (characteristic_info_->IsWritableWithoutResponse)
+    properties = properties | PROPERTY_WRITE_WITHOUT_RESPONSE;
+  if (characteristic_info_->IsWritable)
+    properties = properties | PROPERTY_WRITE;
+  if (characteristic_info_->IsNotifiable)
+    properties = properties | PROPERTY_NOTIFY;
+  if (characteristic_info_->IsIndicatable)
+    properties = properties | PROPERTY_INDICATE;
+  if (characteristic_info_->IsSignedWritable)
+    properties = properties | PROPERTY_AUTHENTICATED_SIGNED_WRITES;
+  if (characteristic_info_->HasExtendedProperties)
+    properties = properties | PROPERTY_EXTENDED_PROPERTIES;
+
+  // TODO(crbug.com/589304): Information about PROPERTY_RELIABLE_WRITE and
+  // PROPERTY_WRITABLE_AUXILIARIES is not available in characteristic_info_
+  // (BTH_LE_GATT_CHARACTERISTIC).
+
+  return properties;
+}
+
+BluetoothRemoteGattCharacteristic::Permissions
+BluetoothRemoteGattCharacteristicWin::GetPermissions() const {
+  BluetoothRemoteGattCharacteristic::Permissions permissions = PERMISSION_NONE;
+
+  if (characteristic_info_->IsReadable)
+    permissions = permissions | PERMISSION_READ;
+  if (characteristic_info_->IsWritable)
+    permissions = permissions | PERMISSION_WRITE;
+
+  return permissions;
+}
+
+bool BluetoothRemoteGattCharacteristicWin::IsNotifying() const {
+  return gatt_event_handle_ != nullptr;
+}
+
+void BluetoothRemoteGattCharacteristicWin::ReadRemoteCharacteristic(
+    ValueCallback callback) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  if (!characteristic_info_.get()->IsReadable) {
+    std::move(callback).Run(BluetoothGattService::GattErrorCode::kNotPermitted,
+                            std::vector<uint8_t>());
+    return;
+  }
+
+  if (characteristic_value_read_or_write_in_progress_) {
+    std::move(callback).Run(BluetoothGattService::GattErrorCode::kInProgress,
+                            std::vector<uint8_t>());
+    return;
+  }
+
+  characteristic_value_read_or_write_in_progress_ = true;
+  read_characteristic_value_callback_ = std::move(callback);
+  task_manager_->PostReadGattCharacteristicValue(
+      parent_service_->GetServicePath(), characteristic_info_.get(),
+      base::BindOnce(&BluetoothRemoteGattCharacteristicWin::
+                         OnReadRemoteCharacteristicValueCallback,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
+void BluetoothRemoteGattCharacteristicWin::WriteRemoteCharacteristic(
+    base::span<const uint8_t> value,
+    WriteType write_type,
+    base::OnceClosure callback,
+    ErrorCallback error_callback) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  if (characteristic_value_read_or_write_in_progress_) {
+    std::move(error_callback)
+        .Run(BluetoothGattService::GattErrorCode::kInProgress);
+    return;
+  }
+
+  ULONG flags;
+  switch (write_type) {
+    case WriteType::kWithResponse:
+      flags = BLUETOOTH_GATT_FLAG_NONE;
+      break;
+    case WriteType::kWithoutResponse:
+      flags = BLUETOOTH_GATT_FLAG_WRITE_WITHOUT_RESPONSE;
+      break;
+  }
+
+  characteristic_value_read_or_write_in_progress_ = true;
+  write_characteristic_value_callbacks_ =
+      std::make_pair(std::move(callback), std::move(error_callback));
+  task_manager_->PostWriteGattCharacteristicValue(
+      parent_service_->GetServicePath(), characteristic_info_.get(), value,
+      flags,
+      base::BindOnce(&BluetoothRemoteGattCharacteristicWin::
+                         OnWriteRemoteCharacteristicValueCallback,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
+void BluetoothRemoteGattCharacteristicWin::DeprecatedWriteRemoteCharacteristic(
+    base::span<const uint8_t> value,
+    base::OnceClosure callback,
+    ErrorCallback error_callback) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  if (!characteristic_info_->IsWritable &&
+      !characteristic_info_->IsWritableWithoutResponse) {
+    std::move(error_callback)
+        .Run(BluetoothGattService::GattErrorCode::kNotPermitted);
+    return;
+  }
+
+  if (characteristic_value_read_or_write_in_progress_) {
+    std::move(error_callback)
+        .Run(BluetoothGattService::GattErrorCode::kInProgress);
+    return;
+  }
+
+  ULONG flags = BLUETOOTH_GATT_FLAG_NONE;
+  if (!characteristic_info_->IsWritable) {
+    flags |= BLUETOOTH_GATT_FLAG_WRITE_WITHOUT_RESPONSE;
+  }
+
+  characteristic_value_read_or_write_in_progress_ = true;
+  write_characteristic_value_callbacks_ =
+      std::make_pair(std::move(callback), std::move(error_callback));
+  task_manager_->PostWriteGattCharacteristicValue(
+      parent_service_->GetServicePath(), characteristic_info_.get(), value,
+      flags,
+      base::BindOnce(&BluetoothRemoteGattCharacteristicWin::
+                         OnWriteRemoteCharacteristicValueCallback,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
+void BluetoothRemoteGattCharacteristicWin::Update() {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  ++discovery_pending_count_;
+  task_manager_->PostGetGattIncludedDescriptors(
+      parent_service_->GetServicePath(), characteristic_info_.get(),
+      base::BindOnce(&BluetoothRemoteGattCharacteristicWin::
+                         OnGetIncludedDescriptorsCallback,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
+uint16_t BluetoothRemoteGattCharacteristicWin::GetAttributeHandle() const {
+  return characteristic_info_->AttributeHandle;
+}
+
+void BluetoothRemoteGattCharacteristicWin::SubscribeToNotifications(
+    BluetoothRemoteGattDescriptor* ccc_descriptor,
+    base::OnceClosure callback,
+    ErrorCallback error_callback) {
+  task_manager_->PostRegisterGattCharacteristicValueChangedEvent(
+      parent_service_->GetServicePath(), characteristic_info_.get(),
+      static_cast<BluetoothRemoteGattDescriptorWin*>(ccc_descriptor)
+          ->GetWinDescriptorInfo(),
+      base::BindOnce(
+          &BluetoothRemoteGattCharacteristicWin::GattEventRegistrationCallback,
+          weak_ptr_factory_.GetWeakPtr(), std::move(callback),
+          std::move(error_callback)),
+      base::BindRepeating(&BluetoothRemoteGattCharacteristicWin::
+                              OnGattCharacteristicValueChanged,
+                          weak_ptr_factory_.GetWeakPtr()));
+}
+
+void BluetoothRemoteGattCharacteristicWin::UnsubscribeFromNotifications(
+    BluetoothRemoteGattDescriptor* ccc_descriptor,
+    base::OnceClosure callback,
+    ErrorCallback error_callback) {
+  // TODO(crbug.com/735828): Implement this method.
+  base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(
+      FROM_HERE, std::move(callback));
+}
+
+void BluetoothRemoteGattCharacteristicWin::OnGetIncludedDescriptorsCallback(
+    std::unique_ptr<BTH_LE_GATT_DESCRIPTOR> descriptors,
+    uint16_t num,
+    HRESULT hr) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  UpdateIncludedDescriptors(descriptors.get(), num);
+  if (!characteristic_added_notified_) {
+    characteristic_added_notified_ = true;
+    parent_service_->GetWinAdapter()->NotifyGattCharacteristicAdded(this);
+  }
+
+  // Report discovery complete.
+  if (--discovery_pending_count_ == 0)
+    parent_service_->GattCharacteristicDiscoveryComplete(this);
+}
+
+void BluetoothRemoteGattCharacteristicWin::UpdateIncludedDescriptors(
+    PBTH_LE_GATT_DESCRIPTOR descriptors,
+    uint16_t num) {
+  if (num == 0) {
+    descriptors_.clear();
+    return;
+  }
+
+  // First, remove descriptors that no longer exist.
+  std::vector<std::string> to_be_removed;
+  for (const auto& d : descriptors_) {
+    if (!DoesDescriptorExist(
+            descriptors, num,
+            static_cast<BluetoothRemoteGattDescriptorWin*>(d.second.get())))
+      to_be_removed.push_back(d.second->GetIdentifier());
+  }
+  for (const auto& id : to_be_removed) {
+    auto iter = descriptors_.find(id);
+    auto pair = std::move(*iter);
+    descriptors_.erase(iter);
+  }
+
+  // Return if no new descriptors have been added.
+  if (descriptors_.size() == num)
+    return;
+
+  // Add new descriptors.
+  for (uint16_t i = 0; i < num; i++) {
+    if (!IsDescriptorDiscovered(descriptors[i].DescriptorUuid,
+                                descriptors[i].AttributeHandle)) {
+      PBTH_LE_GATT_DESCRIPTOR win_descriptor_info =
+          new BTH_LE_GATT_DESCRIPTOR();
+      *win_descriptor_info = descriptors[i];
+      BluetoothRemoteGattDescriptorWin* descriptor =
+          new BluetoothRemoteGattDescriptorWin(this, win_descriptor_info,
+                                               ui_task_runner_);
+      AddDescriptor(base::WrapUnique(descriptor));
+    }
+  }
+}
+
+bool BluetoothRemoteGattCharacteristicWin::IsDescriptorDiscovered(
+    const BTH_LE_UUID& uuid,
+    uint16_t attribute_handle) {
+  BluetoothUUID bt_uuid =
+      BluetoothTaskManagerWin::BluetoothLowEnergyUuidToBluetoothUuid(uuid);
+  for (const auto& d : descriptors_) {
+    if (bt_uuid == d.second->GetUUID() &&
+        attribute_handle ==
+            static_cast<BluetoothRemoteGattDescriptorWin*>(d.second.get())
+                ->GetAttributeHandle()) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool BluetoothRemoteGattCharacteristicWin::DoesDescriptorExist(
+    PBTH_LE_GATT_DESCRIPTOR descriptors,
+    uint16_t num,
+    BluetoothRemoteGattDescriptorWin* descriptor) {
+  for (uint16_t i = 0; i < num; i++) {
+    BluetoothUUID uuid =
+        BluetoothTaskManagerWin::BluetoothLowEnergyUuidToBluetoothUuid(
+            descriptors[i].DescriptorUuid);
+    if (descriptor->GetUUID() == uuid &&
+        descriptor->GetAttributeHandle() == descriptors[i].AttributeHandle) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void BluetoothRemoteGattCharacteristicWin::
+    OnReadRemoteCharacteristicValueCallback(
+        std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC_VALUE> value,
+        HRESULT hr) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  characteristic_value_read_or_write_in_progress_ = false;
+
+  ValueCallback callback = std::move(read_characteristic_value_callback_);
+  if (FAILED(hr)) {
+    std::move(callback).Run(HRESULTToGattErrorCode(hr), std::vector<uint8_t>());
+  } else {
+    characteristic_value_.clear();
+    for (ULONG i = 0; i < value->DataSize; i++)
+      characteristic_value_.push_back(value->Data[i]);
+
+    std::move(callback).Run(absl::nullopt, characteristic_value_);
+  }
+}
+
+void BluetoothRemoteGattCharacteristicWin::
+    OnWriteRemoteCharacteristicValueCallback(HRESULT hr) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  characteristic_value_read_or_write_in_progress_ = false;
+
+  std::pair<base::OnceClosure, ErrorCallback> callbacks;
+  callbacks.swap(write_characteristic_value_callbacks_);
+  if (FAILED(hr)) {
+    std::move(callbacks.second).Run(HRESULTToGattErrorCode(hr));
+  } else {
+    std::move(callbacks.first).Run();
+  }
+}
+
+BluetoothGattService::GattErrorCode
+BluetoothRemoteGattCharacteristicWin::HRESULTToGattErrorCode(HRESULT hr) {
+  if (HRESULT_FROM_WIN32(ERROR_INVALID_USER_BUFFER) == hr)
+    return BluetoothGattService::GattErrorCode::kInvalidLength;
+
+  switch (hr) {
+    case E_BLUETOOTH_ATT_READ_NOT_PERMITTED:
+    case E_BLUETOOTH_ATT_WRITE_NOT_PERMITTED:
+      return BluetoothGattService::GattErrorCode::kNotPermitted;
+    case E_BLUETOOTH_ATT_UNKNOWN_ERROR:
+      return BluetoothGattService::GattErrorCode::kUnknown;
+    case E_BLUETOOTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH:
+      return BluetoothGattService::GattErrorCode::kInvalidLength;
+    case E_BLUETOOTH_ATT_REQUEST_NOT_SUPPORTED:
+      return BluetoothGattService::GattErrorCode::kNotSupported;
+    default:
+      return BluetoothGattService::GattErrorCode::kFailed;
+  }
+}
+
+void BluetoothRemoteGattCharacteristicWin::OnGattCharacteristicValueChanged(
+    std::unique_ptr<std::vector<uint8_t>> new_value) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  characteristic_value_.assign(new_value->begin(), new_value->end());
+  parent_service_->GetWinAdapter()->NotifyGattCharacteristicValueChanged(
+      this, characteristic_value_);
+}
+
+void BluetoothRemoteGattCharacteristicWin::GattEventRegistrationCallback(
+    base::OnceClosure callback,
+    ErrorCallback error_callback,
+    BLUETOOTH_GATT_EVENT_HANDLE event_handle,
+    HRESULT hr) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  if (SUCCEEDED(hr)) {
+    gatt_event_handle_ = event_handle;
+    std::move(callback).Run();
+  } else {
+    std::move(error_callback).Run(HRESULTToGattErrorCode(hr));
+  }
+}
+
+void BluetoothRemoteGattCharacteristicWin::ClearIncludedDescriptors() {
+  // Explicitly reset to null to ensure that calling GetDescriptor() on the
+  // removed descriptor in GattDescriptorRemoved() returns null.
+  std::exchange(descriptors_, {});
+}
+
+}  // namespace device.
diff --git a/device/bluetooth/bluetooth_remote_gatt_characteristic_win.h b/device/bluetooth/bluetooth_remote_gatt_characteristic_win.h
new file mode 100644
index 0000000000000..767488cbd360c
--- /dev/null
+++ b/device/bluetooth/bluetooth_remote_gatt_characteristic_win.h
@@ -0,0 +1,144 @@
+// Copyright 2016 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef DEVICE_BLUETOOTH_BLUETOOTH_REMOTE_GATT_CHARACTERISTIC_WIN_H_
+#define DEVICE_BLUETOOTH_BLUETOOTH_REMOTE_GATT_CHARACTERISTIC_WIN_H_
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/memory/raw_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/task/sequenced_task_runner.h"
+#include "device/bluetooth/bluetooth_low_energy_defs_win.h"
+#include "device/bluetooth/bluetooth_remote_gatt_characteristic.h"
+#include "device/bluetooth/bluetooth_remote_gatt_service.h"
+
+namespace device {
+
+class BluetoothRemoteGattDescriptorWin;
+class BluetoothRemoteGattServiceWin;
+class BluetoothTaskManagerWin;
+
+// The BluetoothRemoteGattCharacteristicWin class implements
+// BluetoothRemoteGattCharacteristic for remote GATT services on Windows 8 and
+// later.
+class DEVICE_BLUETOOTH_EXPORT BluetoothRemoteGattCharacteristicWin
+    : public BluetoothRemoteGattCharacteristic {
+ public:
+  BluetoothRemoteGattCharacteristicWin(
+      BluetoothRemoteGattServiceWin* parent_service,
+      BTH_LE_GATT_CHARACTERISTIC* characteristic_info,
+      scoped_refptr<base::SequencedTaskRunner> ui_task_runner);
+
+  BluetoothRemoteGattCharacteristicWin(
+      const BluetoothRemoteGattCharacteristicWin&) = delete;
+  BluetoothRemoteGattCharacteristicWin& operator=(
+      const BluetoothRemoteGattCharacteristicWin&) = delete;
+
+  ~BluetoothRemoteGattCharacteristicWin() override;
+
+  // Override BluetoothRemoteGattCharacteristic interfaces.
+  std::string GetIdentifier() const override;
+  BluetoothUUID GetUUID() const override;
+  std::vector<uint8_t>& GetValue() const override;
+  BluetoothRemoteGattService* GetService() const override;
+  Properties GetProperties() const override;
+  Permissions GetPermissions() const override;
+  bool IsNotifying() const override;
+  void ReadRemoteCharacteristic(ValueCallback callback) override;
+  void WriteRemoteCharacteristic(base::span<const uint8_t> value,
+                                 WriteType write_type,
+                                 base::OnceClosure callback,
+                                 ErrorCallback error_callback) override;
+  void DeprecatedWriteRemoteCharacteristic(
+      base::span<const uint8_t> value,
+      base::OnceClosure callback,
+      ErrorCallback error_callback) override;
+
+  // Update included descriptors.
+  void Update();
+  uint16_t GetAttributeHandle() const;
+  BluetoothRemoteGattServiceWin* GetWinService() { return parent_service_; }
+
+ protected:
+  void SubscribeToNotifications(BluetoothRemoteGattDescriptor* ccc_descriptor,
+                                base::OnceClosure callback,
+                                ErrorCallback error_callback) override;
+  void UnsubscribeFromNotifications(
+      BluetoothRemoteGattDescriptor* ccc_descriptor,
+      base::OnceClosure callback,
+      ErrorCallback error_callback) override;
+
+ private:
+  void OnGetIncludedDescriptorsCallback(
+      std::unique_ptr<BTH_LE_GATT_DESCRIPTOR> descriptors,
+      uint16_t num,
+      HRESULT hr);
+  void UpdateIncludedDescriptors(PBTH_LE_GATT_DESCRIPTOR descriptors,
+                                 uint16_t num);
+
+  // Checks if the descriptor with |uuid| and |attribute_handle| has already
+  // been discovered as included descriptor.
+  bool IsDescriptorDiscovered(const BTH_LE_UUID& uuid,
+                              uint16_t attribute_handle);
+
+  // Checks if |descriptor| still exists in this characteristic according to
+  // newly discovered |num| of |descriptors|.
+  static bool DoesDescriptorExist(PBTH_LE_GATT_DESCRIPTOR descriptors,
+                                  uint16_t num,
+                                  BluetoothRemoteGattDescriptorWin* descriptor);
+
+  void OnReadRemoteCharacteristicValueCallback(
+      std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC_VALUE> value,
+      HRESULT hr);
+  void OnWriteRemoteCharacteristicValueCallback(HRESULT hr);
+  BluetoothGattService::GattErrorCode HRESULTToGattErrorCode(HRESULT hr);
+  void OnGattCharacteristicValueChanged(
+      std::unique_ptr<std::vector<uint8_t>> new_value);
+  void GattEventRegistrationCallback(base::OnceClosure callback,
+                                     ErrorCallback error_callback,
+                                     PVOID event_handle,
+                                     HRESULT hr);
+  void ClearIncludedDescriptors();
+
+  raw_ptr<BluetoothRemoteGattServiceWin> parent_service_;
+  scoped_refptr<BluetoothTaskManagerWin> task_manager_;
+
+  // Characteristic info from OS and used to interact with OS.
+  std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC> characteristic_info_;
+  scoped_refptr<base::SequencedTaskRunner> ui_task_runner_;
+  BluetoothUUID characteristic_uuid_;
+  std::vector<uint8_t> characteristic_value_;
+  std::string characteristic_identifier_;
+
+  // Flag indicates if characteristic added notification of this characteristic
+  // has been sent out to avoid duplicate notification.
+  bool characteristic_added_notified_;
+
+  // ReadRemoteCharacteristic request callback.
+  ValueCallback read_characteristic_value_callback_;
+
+  // WriteRemoteCharacteristic request callbacks.
+  std::pair<base::OnceClosure, ErrorCallback>
+      write_characteristic_value_callbacks_;
+
+  bool characteristic_value_read_or_write_in_progress_;
+
+  // GATT event handle returned by GattEventRegistrationCallback.
+  PVOID gatt_event_handle_;
+
+  // Counts the number of asynchronous operations that are discovering
+  // descriptors.
+  int discovery_pending_count_;
+
+  base::WeakPtrFactory<BluetoothRemoteGattCharacteristicWin> weak_ptr_factory_{
+      this};
+};
+
+}  // namespace device
+
+#endif  // DEVICE_BLUETOOTH_BLUETOOTH_REMOTE_GATT_CHARACTERISTIC_WIN_H_
diff --git a/device/bluetooth/bluetooth_remote_gatt_descriptor_win.cc b/device/bluetooth/bluetooth_remote_gatt_descriptor_win.cc
new file mode 100644
index 0000000000000..61b139eeb6ec2
--- /dev/null
+++ b/device/bluetooth/bluetooth_remote_gatt_descriptor_win.cc
@@ -0,0 +1,96 @@
+// Copyright 2016 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "device/bluetooth/bluetooth_remote_gatt_descriptor_win.h"
+
+#include "base/functional/bind.h"
+#include "base/task/sequenced_task_runner.h"
+#include "device/bluetooth/bluetooth_adapter_win.h"
+#include "device/bluetooth/bluetooth_remote_gatt_characteristic_win.h"
+#include "device/bluetooth/bluetooth_remote_gatt_service_win.h"
+
+namespace device {
+
+BluetoothRemoteGattDescriptorWin::BluetoothRemoteGattDescriptorWin(
+    BluetoothRemoteGattCharacteristicWin* parent_characteristic,
+    BTH_LE_GATT_DESCRIPTOR* descriptor_info,
+    scoped_refptr<base::SequencedTaskRunner>& ui_task_runner)
+    : parent_characteristic_(parent_characteristic),
+      descriptor_info_(descriptor_info),
+      ui_task_runner_(ui_task_runner) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  DCHECK(parent_characteristic_);
+  DCHECK(descriptor_info_.get());
+
+  task_manager_ = parent_characteristic_->GetWinService()
+                      ->GetWinAdapter()
+                      ->GetWinBluetoothTaskManager();
+  DCHECK(task_manager_);
+  service_path_ = parent_characteristic_->GetWinService()->GetServicePath();
+  DCHECK(!service_path_.empty());
+  descriptor_uuid_ =
+      BluetoothTaskManagerWin::BluetoothLowEnergyUuidToBluetoothUuid(
+          descriptor_info_.get()->DescriptorUuid);
+  DCHECK(descriptor_uuid_.IsValid());
+  descriptor_identifier_ = parent_characteristic_->GetIdentifier() + "_" +
+                           std::to_string(descriptor_info_->AttributeHandle);
+}
+
+BluetoothRemoteGattDescriptorWin::~BluetoothRemoteGattDescriptorWin() {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  parent_characteristic_->GetWinService()
+      ->GetWinAdapter()
+      ->NotifyGattDescriptorRemoved(this);
+}
+
+std::string BluetoothRemoteGattDescriptorWin::GetIdentifier() const {
+  return descriptor_identifier_;
+}
+
+BluetoothUUID BluetoothRemoteGattDescriptorWin::GetUUID() const {
+  return descriptor_uuid_;
+}
+
+std::vector<uint8_t>& BluetoothRemoteGattDescriptorWin::GetValue() const {
+  NOTIMPLEMENTED();
+  return const_cast<std::vector<uint8_t>&>(descriptor_value_);
+}
+
+BluetoothRemoteGattCharacteristic*
+BluetoothRemoteGattDescriptorWin::GetCharacteristic() const {
+  return parent_characteristic_;
+}
+
+BluetoothRemoteGattCharacteristic::Permissions
+BluetoothRemoteGattDescriptorWin::GetPermissions() const {
+  NOTIMPLEMENTED();
+  return descriptor_permissions_;
+}
+
+void BluetoothRemoteGattDescriptorWin::ReadRemoteDescriptor(
+    ValueCallback callback) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  NOTIMPLEMENTED();
+  std::move(callback).Run(BluetoothGattService::GattErrorCode::kNotSupported,
+                          /*value=*/std::vector<uint8_t>());
+}
+
+void BluetoothRemoteGattDescriptorWin::WriteRemoteDescriptor(
+    base::span<const uint8_t> new_value,
+    base::OnceClosure callback,
+    ErrorCallback error_callback) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  NOTIMPLEMENTED();
+  std::move(error_callback)
+      .Run(BluetoothGattService::GattErrorCode::kNotSupported);
+}
+
+uint16_t BluetoothRemoteGattDescriptorWin::GetAttributeHandle() const {
+  return descriptor_info_->AttributeHandle;
+}
+
+}  // namespace device.
diff --git a/device/bluetooth/bluetooth_remote_gatt_descriptor_win.h b/device/bluetooth/bluetooth_remote_gatt_descriptor_win.h
new file mode 100644
index 0000000000000..18a82cff7e47c
--- /dev/null
+++ b/device/bluetooth/bluetooth_remote_gatt_descriptor_win.h
@@ -0,0 +1,75 @@
+// Copyright 2016 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef DEVICE_BLUETOOTH_BLUETOOTH_REMOTE_GATT_DESCRIPTOR_WIN_H_
+#define DEVICE_BLUETOOTH_BLUETOOTH_REMOTE_GATT_DESCRIPTOR_WIN_H_
+
+#include <memory>
+
+#include "base/files/file_path.h"
+#include "base/memory/raw_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "device/bluetooth/bluetooth_low_energy_defs_win.h"
+#include "device/bluetooth/bluetooth_remote_gatt_characteristic.h"
+#include "device/bluetooth/bluetooth_remote_gatt_descriptor.h"
+
+namespace base {
+class SequencedTaskRunner;
+}
+
+namespace device {
+
+class BluetoothRemoteGattCharacteristicWin;
+class BluetoothTaskManagerWin;
+
+class DEVICE_BLUETOOTH_EXPORT BluetoothRemoteGattDescriptorWin
+    : public BluetoothRemoteGattDescriptor {
+ public:
+  BluetoothRemoteGattDescriptorWin(
+      BluetoothRemoteGattCharacteristicWin* parent_characteristic,
+      BTH_LE_GATT_DESCRIPTOR* descriptor_info,
+      scoped_refptr<base::SequencedTaskRunner>& ui_task_runner);
+
+  BluetoothRemoteGattDescriptorWin(const BluetoothRemoteGattDescriptorWin&) =
+      delete;
+  BluetoothRemoteGattDescriptorWin& operator=(
+      const BluetoothRemoteGattDescriptorWin&) = delete;
+
+  ~BluetoothRemoteGattDescriptorWin() override;
+
+  // Override BluetoothRemoteGattDescriptor interfaces.
+  std::string GetIdentifier() const override;
+  BluetoothUUID GetUUID() const override;
+  std::vector<uint8_t>& GetValue() const override;
+  BluetoothRemoteGattCharacteristic* GetCharacteristic() const override;
+  BluetoothRemoteGattCharacteristic::Permissions GetPermissions()
+      const override;
+  void ReadRemoteDescriptor(ValueCallback callback) override;
+  void WriteRemoteDescriptor(base::span<const uint8_t> new_value,
+                             base::OnceClosure callback,
+                             ErrorCallback error_callback) override;
+
+  uint16_t GetAttributeHandle() const;
+  PBTH_LE_GATT_DESCRIPTOR GetWinDescriptorInfo() const {
+    return descriptor_info_.get();
+  }
+
+ private:
+  raw_ptr<BluetoothRemoteGattCharacteristicWin> parent_characteristic_;
+  std::unique_ptr<BTH_LE_GATT_DESCRIPTOR> descriptor_info_;
+  scoped_refptr<base::SequencedTaskRunner> ui_task_runner_;
+
+  base::FilePath service_path_;
+  scoped_refptr<BluetoothTaskManagerWin> task_manager_;
+  BluetoothRemoteGattCharacteristic::Permissions descriptor_permissions_;
+  BluetoothUUID descriptor_uuid_;
+  std::string descriptor_identifier_;
+  std::vector<uint8_t> descriptor_value_;
+
+  base::WeakPtrFactory<BluetoothRemoteGattDescriptorWin> weak_ptr_factory_{
+      this};
+};
+
+}  // namespace device.
+#endif  // DEVICE_BLUETOOTH_BLUETOOTH_REMOTE_GATT_DESCRIPTOR_WIN_H_
diff --git a/device/bluetooth/bluetooth_remote_gatt_service_win.cc b/device/bluetooth/bluetooth_remote_gatt_service_win.cc
new file mode 100644
index 0000000000000..f96f45b9f12df
--- /dev/null
+++ b/device/bluetooth/bluetooth_remote_gatt_service_win.cc
@@ -0,0 +1,245 @@
+// Copyright 2016 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "device/bluetooth/bluetooth_remote_gatt_service_win.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/containers/contains.h"
+#include "base/functional/bind.h"
+#include "base/memory/ptr_util.h"
+#include "base/task/sequenced_task_runner.h"
+#include "device/bluetooth/bluetooth_adapter_win.h"
+#include "device/bluetooth/bluetooth_device_win.h"
+#include "device/bluetooth/bluetooth_remote_gatt_characteristic_win.h"
+#include "device/bluetooth/bluetooth_task_manager_win.h"
+
+namespace device {
+
+BluetoothRemoteGattServiceWin::BluetoothRemoteGattServiceWin(
+    BluetoothDeviceWin* device,
+    base::FilePath service_path,
+    BluetoothUUID service_uuid,
+    uint16_t service_attribute_handle,
+    bool is_primary,
+    BluetoothRemoteGattServiceWin* parent_service,
+    scoped_refptr<base::SequencedTaskRunner> ui_task_runner)
+    : device_(device),
+      service_path_(service_path),
+      service_uuid_(service_uuid),
+      service_attribute_handle_(service_attribute_handle),
+      is_primary_(is_primary),
+      parent_service_(parent_service),
+      ui_task_runner_(std::move(ui_task_runner)) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  DCHECK(!service_path_.empty());
+  DCHECK(service_uuid_.IsValid());
+  DCHECK(service_attribute_handle_);
+  DCHECK(device_);
+  if (!is_primary_)
+    DCHECK(parent_service_);
+
+  adapter_ = static_cast<BluetoothAdapterWin*>(device_->GetAdapter());
+  DCHECK(adapter_);
+  task_manager_ = adapter_->GetWinBluetoothTaskManager();
+  DCHECK(task_manager_);
+  service_identifier_ = device_->GetIdentifier() + "/" + service_uuid_.value() +
+                        "_" + std::to_string(service_attribute_handle_);
+  Update();
+}
+
+BluetoothRemoteGattServiceWin::~BluetoothRemoteGattServiceWin() {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  ClearIncludedCharacteristics();
+
+  adapter_->NotifyGattServiceRemoved(this);
+}
+
+std::string BluetoothRemoteGattServiceWin::GetIdentifier() const {
+  return service_identifier_;
+}
+
+BluetoothUUID BluetoothRemoteGattServiceWin::GetUUID() const {
+  return const_cast<BluetoothUUID&>(service_uuid_);
+}
+
+bool BluetoothRemoteGattServiceWin::IsPrimary() const {
+  return is_primary_;
+}
+
+BluetoothDevice* BluetoothRemoteGattServiceWin::GetDevice() const {
+  return device_;
+}
+
+std::vector<BluetoothRemoteGattService*>
+BluetoothRemoteGattServiceWin::GetIncludedServices() const {
+  NOTIMPLEMENTED();
+  // TODO(crbug.com/590008): Needs implementation.
+  return std::vector<BluetoothRemoteGattService*>();
+}
+
+void BluetoothRemoteGattServiceWin::GattCharacteristicDiscoveryComplete(
+    BluetoothRemoteGattCharacteristicWin* characteristic) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  DCHECK(base::Contains(characteristics_, characteristic->GetIdentifier()));
+
+  discovery_completed_included_characteristics_.insert(
+      characteristic->GetIdentifier());
+  SetDiscoveryComplete(characteristics_.size() ==
+                       discovery_completed_included_characteristics_.size());
+  adapter_->NotifyGattCharacteristicAdded(characteristic);
+  NotifyGattServiceDiscoveryCompleteIfNecessary();
+}
+
+void BluetoothRemoteGattServiceWin::Update() {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  ++discovery_pending_count_;
+  task_manager_->PostGetGattIncludedCharacteristics(
+      service_path_, service_uuid_, service_attribute_handle_,
+      base::BindOnce(
+          &BluetoothRemoteGattServiceWin::OnGetIncludedCharacteristics,
+          weak_ptr_factory_.GetWeakPtr()));
+}
+
+void BluetoothRemoteGattServiceWin::OnGetIncludedCharacteristics(
+    std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC> characteristics,
+    uint16_t num,
+    HRESULT hr) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+
+  if (--discovery_pending_count_ != 0)
+    return;
+
+  UpdateIncludedCharacteristics(characteristics.get(), num);
+  SetDiscoveryComplete(characteristics_.size() ==
+                       discovery_completed_included_characteristics_.size());
+
+  // In case there are new included characterisitics that haven't been
+  // discovered yet, observers should be notified once that the discovery of
+  // these characteristics is complete. Hence the discovery complete flag is
+  // reset.
+  if (!IsDiscoveryComplete()) {
+    discovery_complete_notified_ = false;
+    return;
+  }
+
+  adapter_->NotifyGattServiceChanged(this);
+  NotifyGattServiceDiscoveryCompleteIfNecessary();
+}
+
+void BluetoothRemoteGattServiceWin::UpdateIncludedCharacteristics(
+    PBTH_LE_GATT_CHARACTERISTIC characteristics,
+    uint16_t num) {
+  if (num == 0) {
+    if (!characteristics_.empty()) {
+      ClearIncludedCharacteristics();
+      adapter_->NotifyGattServiceChanged(this);
+    }
+    return;
+  }
+
+  // First, remove characteristics that no longer exist.
+  std::vector<std::string> to_be_removed;
+  for (const auto& c : characteristics_) {
+    if (!DoesCharacteristicExist(
+            characteristics, num,
+            static_cast<BluetoothRemoteGattCharacteristicWin*>(
+                c.second.get()))) {
+      to_be_removed.push_back(c.second->GetIdentifier());
+    }
+  }
+  for (const auto& id : to_be_removed) {
+    RemoveIncludedCharacteristic(id);
+  }
+
+  // Update previously known characteristics.
+  for (auto& c : characteristics_) {
+    static_cast<BluetoothRemoteGattCharacteristicWin*>(c.second.get())
+        ->Update();
+  }
+
+  // Return if no new characteristics have been added.
+  if (characteristics_.size() == num)
+    return;
+
+  // Add new characteristics.
+  for (uint16_t i = 0; i < num; i++) {
+    if (!IsCharacteristicDiscovered(characteristics[i].CharacteristicUuid,
+                                    characteristics[i].AttributeHandle)) {
+      PBTH_LE_GATT_CHARACTERISTIC info = new BTH_LE_GATT_CHARACTERISTIC();
+      *info = characteristics[i];
+      AddCharacteristic(std::make_unique<BluetoothRemoteGattCharacteristicWin>(
+          this, info, ui_task_runner_));
+    }
+  }
+}
+
+void BluetoothRemoteGattServiceWin::
+    NotifyGattServiceDiscoveryCompleteIfNecessary() {
+  if (IsDiscoveryComplete() && !discovery_complete_notified_) {
+    discovery_complete_notified_ = true;
+    device_->GattServiceDiscoveryComplete(this);
+  }
+}
+
+bool BluetoothRemoteGattServiceWin::IsCharacteristicDiscovered(
+    const BTH_LE_UUID& uuid,
+    uint16_t attribute_handle) {
+  BluetoothUUID bt_uuid =
+      BluetoothTaskManagerWin::BluetoothLowEnergyUuidToBluetoothUuid(uuid);
+  for (const auto& c : characteristics_) {
+    if (bt_uuid == c.second->GetUUID() &&
+        attribute_handle ==
+            static_cast<BluetoothRemoteGattCharacteristicWin*>(c.second.get())
+                ->GetAttributeHandle()) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool BluetoothRemoteGattServiceWin::DoesCharacteristicExist(
+    PBTH_LE_GATT_CHARACTERISTIC characteristics,
+    uint16_t num,
+    BluetoothRemoteGattCharacteristicWin* characteristic) {
+  for (uint16_t i = 0; i < num; i++) {
+    BluetoothUUID uuid =
+        BluetoothTaskManagerWin::BluetoothLowEnergyUuidToBluetoothUuid(
+            characteristics[i].CharacteristicUuid);
+    if (characteristic->GetUUID() == uuid &&
+        characteristic->GetAttributeHandle() ==
+            characteristics[i].AttributeHandle) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void BluetoothRemoteGattServiceWin::RemoveIncludedCharacteristic(
+    std::string identifier) {
+  discovery_completed_included_characteristics_.erase(identifier);
+
+  // Explicitly moving the to be deleted characteristic into a local variable,
+  // so that we can erase the entry from |characteristics_| before calling the
+  // characteristic's destructor. This will ensure that any call to
+  // GetCharacteristics() won't contain an entry corresponding to |identifier|.
+  // Note: `characteristics_.erase(identifier);` would not guarantee this.
+  DCHECK(base::Contains(characteristics_, identifier));
+  auto iter = characteristics_.find(identifier);
+  auto pair = std::move(*iter);
+  characteristics_.erase(iter);
+}
+
+void BluetoothRemoteGattServiceWin::ClearIncludedCharacteristics() {
+  discovery_completed_included_characteristics_.clear();
+  // Explicitly reset to null to ensure that calling GetCharacteristics() in
+  // GattCharacteristicRemoved() will return an empty collection.
+  // Note: `characteristics_.clear();` would not guarantee this.
+  std::exchange(characteristics_, {});
+}
+
+}  // namespace device.
diff --git a/device/bluetooth/bluetooth_remote_gatt_service_win.h b/device/bluetooth/bluetooth_remote_gatt_service_win.h
new file mode 100644
index 0000000000000..446a5af500699
--- /dev/null
+++ b/device/bluetooth/bluetooth_remote_gatt_service_win.h
@@ -0,0 +1,122 @@
+// Copyright 2016 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef DEVICE_BLUETOOTH_BLUETOOTH_REMOTE_GATT_SERVICE_WIN_H_
+#define DEVICE_BLUETOOTH_BLUETOOTH_REMOTE_GATT_SERVICE_WIN_H_
+
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/files/file.h"
+#include "base/memory/raw_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/task/sequenced_task_runner.h"
+#include "device/bluetooth/bluetooth_low_energy_defs_win.h"
+#include "device/bluetooth/bluetooth_remote_gatt_service.h"
+
+namespace device {
+
+class BluetoothAdapterWin;
+class BluetoothDeviceWin;
+class BluetoothRemoteGattCharacteristicWin;
+class BluetoothTaskManagerWin;
+
+// The BluetoothRemoteGattServiceWin class implements BluetoothRemoteGattService
+// for remote GATT services on Windows 8 and later.
+class DEVICE_BLUETOOTH_EXPORT BluetoothRemoteGattServiceWin
+    : public BluetoothRemoteGattService {
+ public:
+  BluetoothRemoteGattServiceWin(
+      BluetoothDeviceWin* device,
+      base::FilePath service_path,
+      BluetoothUUID service_uuid,
+      uint16_t service_attribute_handle,
+      bool is_primary,
+      BluetoothRemoteGattServiceWin* parent_service,
+      scoped_refptr<base::SequencedTaskRunner> ui_task_runner);
+
+  BluetoothRemoteGattServiceWin(const BluetoothRemoteGattServiceWin&) = delete;
+  BluetoothRemoteGattServiceWin& operator=(
+      const BluetoothRemoteGattServiceWin&) = delete;
+
+  ~BluetoothRemoteGattServiceWin() override;
+
+  // Override BluetoothRemoteGattService interfaces.
+  std::string GetIdentifier() const override;
+  BluetoothUUID GetUUID() const override;
+  bool IsPrimary() const override;
+  BluetoothDevice* GetDevice() const override;
+  std::vector<BluetoothRemoteGattService*> GetIncludedServices() const override;
+
+  // Notify |characteristic| discovery complete, |characteristic| is the
+  // included characteritic of this service.
+  void GattCharacteristicDiscoveryComplete(
+      BluetoothRemoteGattCharacteristicWin* characteristic);
+
+  // Update included services and characteristics.
+  void Update();
+  uint16_t GetAttributeHandle() const { return service_attribute_handle_; }
+  base::FilePath GetServicePath() { return service_path_; }
+  BluetoothAdapterWin* GetWinAdapter() { return adapter_; }
+
+ private:
+  void OnGetIncludedCharacteristics(
+      std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC> characteristics,
+      uint16_t num,
+      HRESULT hr);
+  void UpdateIncludedCharacteristics(
+      PBTH_LE_GATT_CHARACTERISTIC characteristics,
+      uint16_t num);
+
+  // Sends GattServiceDiscoveryComplete notification if necessary.
+  void NotifyGattServiceDiscoveryCompleteIfNecessary();
+
+  // Checks if the characteristic with |uuid| and |attribute_handle| has already
+  // been discovered as included characteristic.
+  bool IsCharacteristicDiscovered(const BTH_LE_UUID& uuid,
+                                  uint16_t attribute_handle);
+
+  // Checks if |characteristic| still exists in this service according to newly
+  // retreived |num| of included |characteristics|.
+  static bool DoesCharacteristicExist(
+      PBTH_LE_GATT_CHARACTERISTIC characteristics,
+      uint16_t num,
+      BluetoothRemoteGattCharacteristicWin* characteristic);
+
+  void RemoveIncludedCharacteristic(std::string identifier);
+  void ClearIncludedCharacteristics();
+
+  raw_ptr<BluetoothAdapterWin> adapter_;
+  raw_ptr<BluetoothDeviceWin> device_;
+  base::FilePath service_path_;
+  BluetoothUUID service_uuid_;
+  uint16_t service_attribute_handle_;
+  bool is_primary_;
+  raw_ptr<BluetoothRemoteGattServiceWin> parent_service_;
+  scoped_refptr<base::SequencedTaskRunner> ui_task_runner_;
+  std::string service_identifier_;
+
+  // BluetoothTaskManagerWin to handle asynchronously Bluetooth IO and platform
+  // dependent operations.
+  scoped_refptr<BluetoothTaskManagerWin> task_manager_;
+
+  // The element of the set is the identifier of
+  // BluetoothRemoteGattCharacteristicWin instance.
+  std::set<std::string> discovery_completed_included_characteristics_;
+
+  // Flag indicates if discovery complete notification has been send out to
+  // avoid duplicate notification.
+  bool discovery_complete_notified_ = false;
+
+  // Counts the number of asynchronous operations that are discovering
+  // characteristics.
+  int discovery_pending_count_ = 0;
+
+  base::WeakPtrFactory<BluetoothRemoteGattServiceWin> weak_ptr_factory_{this};
+};
+
+}  // namespace device.
+#endif  // DEVICE_BLUETOOTH_BLUETOOTH_REMOTE_GATT_SERVICE_WIN_H_
diff --git a/device/bluetooth/bluetooth_task_manager_win.cc b/device/bluetooth/bluetooth_task_manager_win.cc
index 03c26580d1653..9d62ad34789ce 100644
--- a/device/bluetooth/bluetooth_task_manager_win.cc
+++ b/device/bluetooth/bluetooth_task_manager_win.cc
@@ -56,6 +56,44 @@ std::string BluetoothAddressToCanonicalString(const BLUETOOTH_ADDRESS& btha) {
   return result;
 }
 
+bool BluetoothUUIDToWinBLEUUID(const device::BluetoothUUID& uuid,
+                               BTH_LE_UUID* out_win_uuid) {
+  if (!uuid.IsValid())
+    return false;
+
+  if (uuid.format() == device::BluetoothUUID::kFormat16Bit) {
+    out_win_uuid->IsShortUuid = TRUE;
+    unsigned int data = 0;
+    int result = sscanf_s(uuid.value().c_str(), "%04x", &data);
+    if (result != 1)
+      return false;
+    out_win_uuid->Value.ShortUuid = data;
+  } else {
+    out_win_uuid->IsShortUuid = FALSE;
+    unsigned int data[11];
+    int result =
+        sscanf_s(uuid.value().c_str(),
+                 "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x", &data[0],
+                 &data[1], &data[2], &data[3], &data[4], &data[5], &data[6],
+                 &data[7], &data[8], &data[9], &data[10]);
+    if (result != 11)
+      return false;
+    out_win_uuid->Value.LongUuid.Data1 = data[0];
+    out_win_uuid->Value.LongUuid.Data2 = data[1];
+    out_win_uuid->Value.LongUuid.Data3 = data[2];
+    out_win_uuid->Value.LongUuid.Data4[0] = data[3];
+    out_win_uuid->Value.LongUuid.Data4[1] = data[4];
+    out_win_uuid->Value.LongUuid.Data4[2] = data[5];
+    out_win_uuid->Value.LongUuid.Data4[3] = data[6];
+    out_win_uuid->Value.LongUuid.Data4[4] = data[7];
+    out_win_uuid->Value.LongUuid.Data4[5] = data[8];
+    out_win_uuid->Value.LongUuid.Data4[6] = data[9];
+    out_win_uuid->Value.LongUuid.Data4[7] = data[10];
+  }
+
+  return true;
+}
+
 // Populates bluetooth adapter state from the currently open adapter.
 void GetAdapterState(device::win::BluetoothClassicWrapper* classic_wrapper,
                      device::BluetoothTaskManagerWin::AdapterState* state) {
@@ -84,6 +122,71 @@ void GetDeviceState(const BLUETOOTH_DEVICE_INFO& device_info,
   state->authenticated = !!device_info.fAuthenticated;
 }
 
+struct CharacteristicValueChangedRegistration {
+  CharacteristicValueChangedRegistration();
+  ~CharacteristicValueChangedRegistration();
+
+  BLUETOOTH_GATT_EVENT_HANDLE win_event_handle;
+  device::BluetoothTaskManagerWin::GattCharacteristicValueChangedCallback
+      callback;
+  // The task runner the callback should run on.
+  scoped_refptr<base::SequencedTaskRunner> callback_task_runner;
+};
+
+CharacteristicValueChangedRegistration::
+    CharacteristicValueChangedRegistration() {}
+CharacteristicValueChangedRegistration::
+    ~CharacteristicValueChangedRegistration() {}
+
+// The key of CharacteristicValueChangedRegistrationMap is a
+// GattCharacteristicValueChangedCallback pointer (cast to PVOID) to make it
+// unique for different callbacks. It is also the context value passed into OS
+// when registering event.
+typedef std::unordered_map<
+    PVOID,
+    std::unique_ptr<CharacteristicValueChangedRegistration>>
+    CharacteristicValueChangedRegistrationMap;
+
+CharacteristicValueChangedRegistrationMap&
+GetCharacteristicValueChangedRegistrations() {
+  static base::NoDestructor<CharacteristicValueChangedRegistrationMap>
+      registrations;
+  return *registrations;
+}
+
+base::Lock& GetCharacteristicValueChangedRegistrationsLock() {
+  static base::NoDestructor<base::Lock> lock;
+  return *lock;
+}
+
+// Function to be registered to OS to monitor Bluetooth LE GATT event. It is
+// invoked in BluetoothApis.dll thread.
+void CALLBACK OnGetGattEventWin(BTH_LE_GATT_EVENT_TYPE type,
+                                PVOID event_parameter,
+                                PVOID context) {
+  if (type != CharacteristicValueChangedEvent) {
+    // Right now, only characteristic value changed event is supported.
+    NOTREACHED();
+  }
+
+  BLUETOOTH_GATT_VALUE_CHANGED_EVENT* event =
+      (BLUETOOTH_GATT_VALUE_CHANGED_EVENT*)event_parameter;
+  PBTH_LE_GATT_CHARACTERISTIC_VALUE new_value_win = event->CharacteristicValue;
+  std::unique_ptr<std::vector<uint8_t>> new_value(
+      new std::vector<uint8_t>(new_value_win->DataSize));
+  for (ULONG i = 0; i < new_value_win->DataSize; i++)
+    (*new_value)[i] = new_value_win->Data[i];
+
+  base::AutoLock auto_lock(GetCharacteristicValueChangedRegistrationsLock());
+  CharacteristicValueChangedRegistrationMap::const_iterator it =
+      GetCharacteristicValueChangedRegistrations().find(context);
+  if (it == GetCharacteristicValueChangedRegistrations().end())
+    return;
+
+  it->second->callback_task_runner->PostTask(
+      FROM_HERE, base::BindOnce(it->second->callback, std::move(new_value)));
+}
+
 }  // namespace
 
 namespace device {
@@ -116,7 +220,8 @@ BluetoothTaskManagerWin::DeviceState::~DeviceState() {
 BluetoothTaskManagerWin::BluetoothTaskManagerWin(
     scoped_refptr<base::SequencedTaskRunner> ui_task_runner)
     : ui_task_runner_(std::move(ui_task_runner)),
-      classic_wrapper_(std::make_unique<win::BluetoothClassicWrapper>()) {}
+      classic_wrapper_(std::make_unique<win::BluetoothClassicWrapper>()),
+      le_wrapper_(std::make_unique<win::BluetoothLowEnergyWrapper>()) {}
 
 BluetoothTaskManagerWin::BluetoothTaskManagerWin(
     std::unique_ptr<win::BluetoothClassicWrapper> classic_wrapper,
@@ -135,6 +240,28 @@ BluetoothTaskManagerWin::CreateForTesting(
                                      std::move(ui_task_runner));
 }
 
+// static
+BluetoothUUID BluetoothTaskManagerWin::BluetoothLowEnergyUuidToBluetoothUuid(
+    const BTH_LE_UUID& bth_le_uuid) {
+  if (bth_le_uuid.IsShortUuid) {
+    std::string uuid_hex =
+        base::StringPrintf("%04x", bth_le_uuid.Value.ShortUuid);
+    return BluetoothUUID(uuid_hex);
+  } else {
+    return BluetoothUUID(base::StringPrintf(
+        "%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+        bth_le_uuid.Value.LongUuid.Data1, bth_le_uuid.Value.LongUuid.Data2,
+        bth_le_uuid.Value.LongUuid.Data3, bth_le_uuid.Value.LongUuid.Data4[0],
+        bth_le_uuid.Value.LongUuid.Data4[1],
+        bth_le_uuid.Value.LongUuid.Data4[2],
+        bth_le_uuid.Value.LongUuid.Data4[3],
+        bth_le_uuid.Value.LongUuid.Data4[4],
+        bth_le_uuid.Value.LongUuid.Data4[5],
+        bth_le_uuid.Value.LongUuid.Data4[6],
+        bth_le_uuid.Value.LongUuid.Data4[7]));
+  }
+}
+
 void BluetoothTaskManagerWin::AddObserver(Observer* observer) {
   DCHECK(observer);
   DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
@@ -367,8 +494,9 @@ bool BluetoothTaskManagerWin::SearchDevices(
     int timeout_multiplier,
     bool search_cached_devices_only,
     std::vector<std::unique_ptr<DeviceState>>* device_list) {
-  return SearchClassicDevices(timeout_multiplier, search_cached_devices_only,
-                              device_list) &&
+  return SearchClassicDevices(
+             timeout_multiplier, search_cached_devices_only, device_list) &&
+         SearchLowEnergyDevices(device_list) &&
          DiscoverServices(device_list, search_cached_devices_only);
 }
 
@@ -428,6 +556,32 @@ bool BluetoothTaskManagerWin::SearchClassicDevices(
   return true;
 }
 
+bool BluetoothTaskManagerWin::SearchLowEnergyDevices(
+    std::vector<std::unique_ptr<DeviceState>>* device_list) {
+  std::vector<std::unique_ptr<win::BluetoothLowEnergyDeviceInfo>> btle_devices;
+  std::string error;
+  bool success = le_wrapper_->EnumerateKnownBluetoothLowEnergyDevices(
+      &btle_devices, &error);
+  if (!success) {
+    error.insert(0, "Error calling EnumerateKnownBluetoothLowEnergyDevices: ");
+    LogPollingError(error.c_str(), 0);
+    return false;
+  }
+
+  for (const auto& device_info : btle_devices) {
+    auto device_state = std::make_unique<DeviceState>();
+    device_state->name = device_info->friendly_name;
+    device_state->address =
+        BluetoothAddressToCanonicalString(device_info->address);
+    device_state->visible = device_info->visible;
+    device_state->authenticated = device_info->authenticated;
+    device_state->connected = device_info->connected;
+    device_state->path = device_info->path;
+    device_list->push_back(std::move(device_state));
+  }
+  return true;
+}
+
 bool BluetoothTaskManagerWin::DiscoverServices(
     std::vector<std::unique_ptr<DeviceState>>* device_list,
     bool search_cached_services_only) {
@@ -437,10 +591,22 @@ bool BluetoothTaskManagerWin::DiscoverServices(
     std::vector<std::unique_ptr<ServiceRecordState>>* service_record_states =
         &device->service_record_states;
 
-    if (!DiscoverClassicDeviceServices(device->address, L2CAP_PROTOCOL_UUID,
-                                       search_cached_services_only,
-                                       service_record_states)) {
-      return false;
+    if (device->is_bluetooth_classic()) {
+      if (!DiscoverClassicDeviceServices(device->address,
+                                         L2CAP_PROTOCOL_UUID,
+                                         search_cached_services_only,
+                                         service_record_states)) {
+        return false;
+      }
+    } else {
+      if (!DiscoverLowEnergyDeviceServices(device->path,
+                                           service_record_states)) {
+        return false;
+      }
+      if (!SearchForGattServiceDevicePaths(device->address,
+                                           service_record_states)) {
+        return false;
+      }
     }
   }
   return true;
@@ -545,4 +711,314 @@ int BluetoothTaskManagerWin::DiscoverClassicDeviceServicesWorker(
   return ERROR_SUCCESS;
 }
 
+bool BluetoothTaskManagerWin::DiscoverLowEnergyDeviceServices(
+    const base::FilePath& device_path,
+    std::vector<std::unique_ptr<ServiceRecordState>>* service_record_states) {
+  std::string error;
+  std::vector<std::unique_ptr<win::BluetoothLowEnergyServiceInfo>> services;
+  bool success = le_wrapper_->EnumerateKnownBluetoothLowEnergyServices(
+      device_path, &services, &error);
+  if (!success) {
+    error.insert(0, "Error calling EnumerateKnownBluetoothLowEnergyServices: ");
+    LogPollingError(error.c_str(), 0);
+    return false;
+  }
+
+  for (const auto& service : services) {
+    auto service_state = std::make_unique<ServiceRecordState>();
+    service_state->gatt_uuid =
+        BluetoothLowEnergyUuidToBluetoothUuid(service->uuid);
+    service_state->attribute_handle = service->attribute_handle;
+    service_record_states->push_back(std::move(service_state));
+  }
+  return true;
+}
+
+// Each GATT service of a BLE device will be listed on the machine as a BLE
+// device interface with a matching service attribute handle. This interface
+// lists all GATT service devices and matches them back to correspond GATT
+// service of the BLE device according to their address and included service
+// attribute handles, as we did not find a more neat way to bond them.
+bool BluetoothTaskManagerWin::SearchForGattServiceDevicePaths(
+    const std::string device_address,
+    std::vector<std::unique_ptr<ServiceRecordState>>* service_record_states) {
+  std::string error;
+
+  // List all known GATT service devices on the machine.
+  std::vector<std::unique_ptr<win::BluetoothLowEnergyDeviceInfo>>
+      gatt_service_devices;
+  bool success =
+      le_wrapper_->EnumerateKnownBluetoothLowEnergyGattServiceDevices(
+          &gatt_service_devices, &error);
+  if (!success) {
+    error.insert(
+        0,
+        "Error calling EnumerateKnownBluetoothLowEnergyGattServiceDevices: ");
+    LogPollingError(error.c_str(), 0);
+    return false;
+  }
+
+  for (const auto& gatt_service_device : gatt_service_devices) {
+    // Only care about the service devices with |device_address|.
+    if (BluetoothAddressToCanonicalString(gatt_service_device->address) !=
+        device_address) {
+      continue;
+    }
+
+    // Discover this service device's contained services.
+    std::vector<std::unique_ptr<win::BluetoothLowEnergyServiceInfo>>
+        gatt_services;
+    if (!le_wrapper_->EnumerateKnownBluetoothLowEnergyServices(
+            gatt_service_device->path, &gatt_services, &error)) {
+      error.insert(0,
+                   "Error calling EnumerateKnownBluetoothLowEnergyServices: ");
+      LogPollingError(error.c_str(), 0);
+      continue;
+    }
+
+    // Usually each service device correspond to one Gatt service.
+    if (gatt_services.size() > 1) {
+      LOG(WARNING) << "This GATT service device contains more than one ("
+                   << gatt_services.size() << ") services";
+    }
+
+    // Associate service device to corresponding service record. Attribute
+    // handle is unique on one device.
+    for (const auto& gatt_service : gatt_services) {
+      for (const auto& service_record_state : *service_record_states) {
+        if (service_record_state->attribute_handle ==
+            gatt_service->attribute_handle) {
+          service_record_state->path = gatt_service_device->path;
+          break;
+        }
+      }
+    }
+  }
+
+  // Service devices are known and available for enumeration shortly after a
+  // a service is known.  If we are searching for service device paths in that
+  // short window, we won't have a service device path for every service.
+  for (const auto& service_record_state : *service_record_states) {
+    if (service_record_state->path.empty())
+      return false;
+  }
+
+  return true;
+}
+
+void BluetoothTaskManagerWin::GetGattIncludedCharacteristics(
+    base::FilePath service_path,
+    BluetoothUUID uuid,
+    uint16_t attribute_handle,
+    GetGattIncludedCharacteristicsCallback callback) {
+  HRESULT hr = S_OK;
+  std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC> win_characteristics_info;
+  uint16_t number_of_charateristics = 0;
+
+  BTH_LE_GATT_SERVICE win_service;
+  if (BluetoothUUIDToWinBLEUUID(uuid, &(win_service.ServiceUuid))) {
+    win_service.AttributeHandle = attribute_handle;
+    hr = le_wrapper_->ReadCharacteristicsOfAService(service_path, &win_service,
+                                                    &win_characteristics_info,
+                                                    &number_of_charateristics);
+  } else {
+    hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
+  }
+
+  ui_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(std::move(callback), std::move(win_characteristics_info),
+                     number_of_charateristics, hr));
+}
+
+void BluetoothTaskManagerWin::GetGattIncludedDescriptors(
+    base::FilePath service_path,
+    BTH_LE_GATT_CHARACTERISTIC characteristic,
+    GetGattIncludedDescriptorsCallback callback) {
+  std::unique_ptr<BTH_LE_GATT_DESCRIPTOR> win_descriptors_info;
+  uint16_t number_of_descriptors = 0;
+
+  HRESULT hr = le_wrapper_->ReadDescriptorsOfACharacteristic(
+      service_path, (PBTH_LE_GATT_CHARACTERISTIC)(&characteristic),
+      &win_descriptors_info, &number_of_descriptors);
+
+  ui_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(std::move(callback), std::move(win_descriptors_info),
+                     number_of_descriptors, hr));
+}
+
+void BluetoothTaskManagerWin::ReadGattCharacteristicValue(
+    base::FilePath service_path,
+    BTH_LE_GATT_CHARACTERISTIC characteristic,
+    ReadGattCharacteristicValueCallback callback) {
+  std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC_VALUE> win_characteristic_value;
+  HRESULT hr = le_wrapper_->ReadCharacteristicValue(
+      service_path, (PBTH_LE_GATT_CHARACTERISTIC)(&characteristic),
+      &win_characteristic_value);
+
+  ui_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(std::move(callback),
+                                std::move(win_characteristic_value), hr));
+}
+
+void BluetoothTaskManagerWin::WriteGattCharacteristicValue(
+    base::FilePath service_path,
+    BTH_LE_GATT_CHARACTERISTIC characteristic,
+    base::span<const uint8_t> new_value,
+    ULONG flags,
+    HResultCallback callback) {
+  ULONG length = (ULONG)(sizeof(ULONG) + new_value.size());
+  std::vector<UCHAR> data(length);
+  auto* win_new_value =
+      reinterpret_cast<PBTH_LE_GATT_CHARACTERISTIC_VALUE>(&data[0]);
+  win_new_value->DataSize = (ULONG)new_value.size();
+  for (ULONG i = 0; i < new_value.size(); i++)
+    win_new_value->Data[i] = new_value[i];
+
+  HRESULT hr = le_wrapper_->WriteCharacteristicValue(
+      service_path, (PBTH_LE_GATT_CHARACTERISTIC)(&characteristic),
+      win_new_value, flags);
+
+  ui_task_runner_->PostTask(FROM_HERE, base::BindOnce(std::move(callback), hr));
+}
+
+void BluetoothTaskManagerWin::RegisterGattCharacteristicValueChangedEvent(
+    base::FilePath service_path,
+    BTH_LE_GATT_CHARACTERISTIC characteristic,
+    BTH_LE_GATT_DESCRIPTOR ccc_descriptor,
+    GattEventRegistrationCallback callback,
+    const GattCharacteristicValueChangedCallback& registered_callback) {
+  DCHECK(bluetooth_task_runner_->RunsTasksInCurrentSequence());
+  BLUETOOTH_GATT_EVENT_HANDLE win_event_handle = NULL;
+
+  BLUETOOTH_GATT_VALUE_CHANGED_EVENT_REGISTRATION win_event_parameter;
+  memcpy(&(win_event_parameter.Characteristics[0]), &characteristic,
+         sizeof(BTH_LE_GATT_CHARACTERISTIC));
+  win_event_parameter.NumCharacteristics = 1;
+  PVOID user_event_handle = (PVOID)&registered_callback;
+  HRESULT hr = le_wrapper_->RegisterGattEvents(
+      service_path, CharacteristicValueChangedEvent, &win_event_parameter,
+      &OnGetGattEventWin, user_event_handle, &win_event_handle);
+
+  // Sets the Client Characteristic Configuration descriptor.
+  if (SUCCEEDED(hr)) {
+    BTH_LE_GATT_DESCRIPTOR_VALUE new_cccd_value;
+    RtlZeroMemory(&new_cccd_value, sizeof(new_cccd_value));
+    new_cccd_value.DescriptorType = ClientCharacteristicConfiguration;
+    if (characteristic.IsNotifiable) {
+      new_cccd_value.ClientCharacteristicConfiguration
+          .IsSubscribeToNotification = TRUE;
+    } else {
+      new_cccd_value.ClientCharacteristicConfiguration.IsSubscribeToIndication =
+          TRUE;
+    }
+
+    hr = le_wrapper_->WriteDescriptorValue(
+        service_path, (PBTH_LE_GATT_DESCRIPTOR)(&ccc_descriptor),
+        &new_cccd_value);
+  }
+
+  if (SUCCEEDED(hr)) {
+    std::unique_ptr<CharacteristicValueChangedRegistration> registration(
+        new CharacteristicValueChangedRegistration());
+    registration->win_event_handle = win_event_handle;
+    registration->callback = registered_callback;
+    registration->callback_task_runner = ui_task_runner_;
+    base::AutoLock auto_lock(GetCharacteristicValueChangedRegistrationsLock());
+    GetCharacteristicValueChangedRegistrations()[user_event_handle] =
+        std::move(registration);
+  }
+
+  ui_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(std::move(callback), user_event_handle, hr));
+}
+
+void BluetoothTaskManagerWin::UnregisterGattCharacteristicValueChangedEvent(
+    PVOID event_handle) {
+  DCHECK(bluetooth_task_runner_->RunsTasksInCurrentSequence());
+
+  base::AutoLock auto_lock(GetCharacteristicValueChangedRegistrationsLock());
+  CharacteristicValueChangedRegistrationMap::const_iterator it =
+      GetCharacteristicValueChangedRegistrations().find(event_handle);
+  if (it != GetCharacteristicValueChangedRegistrations().end()) {
+    le_wrapper_->UnregisterGattEvent(it->second->win_event_handle);
+    GetCharacteristicValueChangedRegistrations().erase(event_handle);
+  }
+}
+
+void BluetoothTaskManagerWin::PostGetGattIncludedCharacteristics(
+    const base::FilePath& service_path,
+    const BluetoothUUID& uuid,
+    uint16_t attribute_handle,
+    GetGattIncludedCharacteristicsCallback callback) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  bluetooth_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&BluetoothTaskManagerWin::GetGattIncludedCharacteristics,
+                     this, service_path, uuid, attribute_handle,
+                     std::move(callback)));
+}
+
+void BluetoothTaskManagerWin::PostGetGattIncludedDescriptors(
+    const base::FilePath& service_path,
+    const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+    GetGattIncludedDescriptorsCallback callback) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  bluetooth_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&BluetoothTaskManagerWin::GetGattIncludedDescriptors, this,
+                     service_path, *characteristic, std::move(callback)));
+}
+
+void BluetoothTaskManagerWin::PostReadGattCharacteristicValue(
+    const base::FilePath& service_path,
+    const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+    ReadGattCharacteristicValueCallback callback) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  bluetooth_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&BluetoothTaskManagerWin::ReadGattCharacteristicValue,
+                     this, service_path, *characteristic, std::move(callback)));
+}
+
+void BluetoothTaskManagerWin::PostWriteGattCharacteristicValue(
+    const base::FilePath& service_path,
+    const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+    base::span<const uint8_t> new_value,
+    ULONG flags,
+    HResultCallback callback) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  bluetooth_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&BluetoothTaskManagerWin::WriteGattCharacteristicValue,
+                     this, service_path, *characteristic, new_value, flags,
+                     std::move(callback)));
+}
+
+void BluetoothTaskManagerWin::PostRegisterGattCharacteristicValueChangedEvent(
+    const base::FilePath& service_path,
+    const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+    const PBTH_LE_GATT_DESCRIPTOR ccc_descriptor,
+    GattEventRegistrationCallback callback,
+    const GattCharacteristicValueChangedCallback& registered_callback) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  bluetooth_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(
+          &BluetoothTaskManagerWin::RegisterGattCharacteristicValueChangedEvent,
+          this, service_path, *characteristic, *ccc_descriptor,
+          std::move(callback), registered_callback));
+}
+
+void BluetoothTaskManagerWin::PostUnregisterGattCharacteristicValueChangedEvent(
+    PVOID event_handle) {
+  DCHECK(ui_task_runner_->RunsTasksInCurrentSequence());
+  bluetooth_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&BluetoothTaskManagerWin::
+                         UnregisterGattCharacteristicValueChangedEvent,
+                     this, event_handle));
+}
+
 }  // namespace device
diff --git a/device/bluetooth/bluetooth_task_manager_win.h b/device/bluetooth/bluetooth_task_manager_win.h
index c3f54fdb6f819..15bb5657e1eb6 100644
--- a/device/bluetooth/bluetooth_task_manager_win.h
+++ b/device/bluetooth/bluetooth_task_manager_win.h
@@ -19,6 +19,7 @@
 #include "base/win/scoped_handle.h"
 #include "device/bluetooth/bluetooth_adapter.h"
 #include "device/bluetooth/bluetooth_export.h"
+#include "device/bluetooth/bluetooth_low_energy_win.h"
 
 namespace base {
 
@@ -30,6 +31,7 @@ namespace device {
 
 namespace win {
 class BluetoothClassicWrapper;
+class BluetoothLowEnergyWrapper;
 }  // namespace win
 
 // Manages the blocking Bluetooth tasks using |SequencedWorkerPool|. It runs
@@ -80,6 +82,8 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothTaskManagerWin
 
     ~DeviceState();
 
+    bool is_bluetooth_classic() const { return path.empty(); }
+
     // Properties common to Bluetooth Classic and LE devices.
     std::string address;  // This uniquely identifies the device.
     std::optional<std::string> name;  // Friendly name
@@ -87,7 +91,10 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothTaskManagerWin
     bool connected;
     bool authenticated;
     std::vector<std::unique_ptr<ServiceRecordState>> service_record_states;
+    // Properties specific to Bluetooth Classic devices.
     uint32_t bluetooth_class;
+    // Properties specific to Bluetooth LE devices.
+    base::FilePath path;
   };
 
   class DEVICE_BLUETOOTH_EXPORT Observer {
@@ -118,6 +125,9 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothTaskManagerWin
       std::unique_ptr<win::BluetoothClassicWrapper> classic_wrapper,
       scoped_refptr<base::SequencedTaskRunner> ui_task_runner);
 
+  static BluetoothUUID BluetoothLowEnergyUuidToBluetoothUuid(
+      const BTH_LE_UUID& bth_le_uuid);
+
   void AddObserver(Observer* observer);
   void RemoveObserver(Observer* observer);
 
@@ -132,6 +142,71 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothTaskManagerWin
   void PostStartDiscoveryTask();
   void PostStopDiscoveryTask();
 
+  // Callbacks of asynchronous operations of GATT service.
+  using HResultCallback = base::OnceCallback<void(HRESULT)>;
+  using GetGattIncludedCharacteristicsCallback = base::OnceCallback<
+      void(std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC>, uint16_t, HRESULT)>;
+  using GetGattIncludedDescriptorsCallback = base::OnceCallback<
+      void(std::unique_ptr<BTH_LE_GATT_DESCRIPTOR>, uint16_t, HRESULT)>;
+  using ReadGattCharacteristicValueCallback =
+      base::OnceCallback<void(std::unique_ptr<BTH_LE_GATT_CHARACTERISTIC_VALUE>,
+                              HRESULT)>;
+  using GattCharacteristicValueChangedCallback =
+      base::RepeatingCallback<void(std::unique_ptr<std::vector<uint8_t>>)>;
+  using GattEventRegistrationCallback =
+      base::OnceCallback<void(PVOID, HRESULT)>;
+
+  // Get all included characteristics of a given service. The service is
+  // uniquely identified by its |uuid| and |attribute_handle| with service
+  // device |service_path|. The result is returned asynchronously through
+  // |callback|.
+  void PostGetGattIncludedCharacteristics(
+      const base::FilePath& service_path,
+      const BluetoothUUID& uuid,
+      uint16_t attribute_handle,
+      GetGattIncludedCharacteristicsCallback callback);
+
+  // Get all included descriptors of a given |characterisitc| in service
+  // with |service_path|. The result is returned asynchronously through
+  // |callback|.
+  void PostGetGattIncludedDescriptors(
+      const base::FilePath& service_path,
+      const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+      GetGattIncludedDescriptorsCallback callback);
+
+  // Post read the value of a given |characteristic| in service with
+  // |service_path|. The result is returned asynchronously through |callback|.
+  void PostReadGattCharacteristicValue(
+      const base::FilePath& device_path,
+      const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+      ReadGattCharacteristicValueCallback callback);
+
+  // Post write the value of a given |characteristic| in service with
+  // |service_path| to |new_value|. The operation result is returned
+  // asynchronously through |callback|.
+  void PostWriteGattCharacteristicValue(
+      const base::FilePath& service_path,
+      const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+      base::span<const uint8_t> new_value,
+      ULONG flags,
+      HResultCallback callback);
+
+  // Post a task to register to receive value changed notifications from
+  // |characteristic| in service with |service_path|. |ccc_descriptor| is the
+  // Client Characteristic Configuration descriptor. |registered_callback| is
+  // the function to be invoked if the event occured. The operation result is
+  // returned asynchronously through |callback|.
+  void PostRegisterGattCharacteristicValueChangedEvent(
+      const base::FilePath& service_path,
+      const PBTH_LE_GATT_CHARACTERISTIC characteristic,
+      const PBTH_LE_GATT_DESCRIPTOR ccc_descriptor,
+      GattEventRegistrationCallback callback,
+      const GattCharacteristicValueChangedCallback& registered_callback);
+
+  // Post a task to unregister from value change notifications. |event_handle|
+  // was returned by PostRegisterGattCharacteristicValueChangedEvent.
+  void PostUnregisterGattCharacteristicValueChangedEvent(PVOID event_handle);
+
  private:
   friend class base::RefCountedThreadSafe<BluetoothTaskManagerWin>;
   friend class BluetoothTaskManagerWinTest;
@@ -193,6 +268,10 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothTaskManagerWin
       bool search_cached_devices_only,
       std::vector<std::unique_ptr<DeviceState>>* device_list);
 
+  // Enumerate Bluetooth Low Energy devices.
+  bool SearchLowEnergyDevices(
+      std::vector<std::unique_ptr<DeviceState>>* device_list);
+
   // Discover services for the devices in |device_list|.
   bool DiscoverServices(std::vector<std::unique_ptr<DeviceState>>* device_list,
                         bool search_cached_services_only);
@@ -212,6 +291,45 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothTaskManagerWin
       bool search_cached_services_only,
       std::vector<std::unique_ptr<ServiceRecordState>>* service_record_states);
 
+  // Discover Bluetooth Low Energy services for the given |device_path|.
+  bool DiscoverLowEnergyDeviceServices(
+      const base::FilePath& device_path,
+      std::vector<std::unique_ptr<ServiceRecordState>>* service_record_states);
+
+  // Search for device paths of the GATT services in |*service_record_states|
+  // from |device_address|.
+  // Return true if we were able to match all services with a service device
+  // path.
+  bool SearchForGattServiceDevicePaths(
+      const std::string device_address,
+      std::vector<std::unique_ptr<ServiceRecordState>>* service_record_states);
+
+  // GATT service related functions.
+  void GetGattIncludedCharacteristics(
+      base::FilePath device_path,
+      BluetoothUUID uuid,
+      uint16_t attribute_handle,
+      GetGattIncludedCharacteristicsCallback callback);
+  void GetGattIncludedDescriptors(base::FilePath service_path,
+                                  BTH_LE_GATT_CHARACTERISTIC characteristic,
+                                  GetGattIncludedDescriptorsCallback callback);
+  void ReadGattCharacteristicValue(
+      base::FilePath device_path,
+      BTH_LE_GATT_CHARACTERISTIC characteristic,
+      ReadGattCharacteristicValueCallback callback);
+  void WriteGattCharacteristicValue(base::FilePath service_path,
+                                    BTH_LE_GATT_CHARACTERISTIC characteristic,
+                                    base::span<const uint8_t> new_value,
+                                    ULONG flags,
+                                    HResultCallback callback);
+  void RegisterGattCharacteristicValueChangedEvent(
+      base::FilePath service_path,
+      BTH_LE_GATT_CHARACTERISTIC characteristic,
+      BTH_LE_GATT_DESCRIPTOR ccc_descriptor,
+      GattEventRegistrationCallback callback,
+      const GattCharacteristicValueChangedCallback& registered_callback);
+  void UnregisterGattCharacteristicValueChangedEvent(PVOID event_handle);
+
   // UI task runner reference.
   scoped_refptr<base::SequencedTaskRunner> ui_task_runner_;
 
@@ -229,6 +347,7 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothTaskManagerWin
 
   // Wrapper around the Windows Bluetooth APIs. Owns the radio handle.
   std::unique_ptr<win::BluetoothClassicWrapper> classic_wrapper_;
+  std::unique_ptr<win::BluetoothLowEnergyWrapper> le_wrapper_;
 };
 
 }  // namespace device
diff --git a/device/bluetooth/test/bluetooth_test_win.cc b/device/bluetooth/test/bluetooth_test_win.cc
index dcc8565b1b4f0..f53e637d496e7 100644
--- a/device/bluetooth/test/bluetooth_test_win.cc
+++ b/device/bluetooth/test/bluetooth_test_win.cc
@@ -32,8 +32,12 @@
 #include "device/bluetooth/bluetooth_adapter_winrt.h"
 #include "device/bluetooth/bluetooth_advertisement_winrt.h"
 #include "device/bluetooth/bluetooth_device_winrt.h"
+#include "device/bluetooth/bluetooth_low_energy_win.h"
+#include "device/bluetooth/bluetooth_remote_gatt_characteristic_win.h"
 #include "device/bluetooth/bluetooth_remote_gatt_characteristic_winrt.h"
+#include "device/bluetooth/bluetooth_remote_gatt_descriptor_win.h"
 #include "device/bluetooth/bluetooth_remote_gatt_descriptor_winrt.h"
+#include "device/bluetooth/bluetooth_remote_gatt_service_win.h"
 #include "device/bluetooth/public/cpp/bluetooth_uuid.h"
 #include "device/bluetooth/test/fake_bluetooth_adapter_winrt.h"
 #include "device/bluetooth/test/fake_bluetooth_le_advertisement_publisher_winrt.h"
